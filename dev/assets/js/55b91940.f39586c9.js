"use strict";(self.webpackChunkmydevdocs=self.webpackChunkmydevdocs||[]).push([[1764],{4253:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"tech-related/Chatbot/build-ai-chatbot","title":"Conversational Memory","description":"This document explores the crucial concept of conversational state, or memory, in the development of chatbots and AI agents. It focuses on how an application can remember messages from past conversations, comparing traditional memory management approaches with the simplified method provided by the OpenAI API.","source":"@site/docs/tech-related/Chatbot/build-ai-chatbot.md","sourceDirName":"tech-related/Chatbot","slug":"/tech-related/Chatbot/build-ai-chatbot","permalink":"/dev/docs/tech-related/Chatbot/build-ai-chatbot","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"chatbot development","permalink":"/dev/docs/tags/chatbot-development"},{"inline":true,"label":"conversational state","permalink":"/dev/docs/tags/conversational-state"},{"inline":true,"label":"OpenAI API","permalink":"/dev/docs/tags/open-ai-api"}],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Conversational Memory","sidebar_position":2,"tags":["chatbot development","conversational state","OpenAI API"]},"sidebar":"tutorialSidebar","previous":{"title":"How M3U8 works on VLC","permalink":"/dev/docs/tech-related/m3u8"},"next":{"title":"AI Agents Intro","permalink":"/dev/docs/tech-related/Chatbot/ai-agent-intro"}}');var s=t(4848),a=t(8453);const o={title:"Conversational Memory",sidebar_position:2,tags:["chatbot development","conversational state","OpenAI API"]},r="Conversational Memory in Chatbots and AI Agents",l={},c=[{value:"Key Themes and Concepts",id:"key-themes-and-concepts",level:2},{value:"1. The Concept of Conversational State (Memory)",id:"1-the-concept-of-conversational-state-memory",level:3},{value:"2. Traditional Memory Management Approach",id:"2-traditional-memory-management-approach",level:3},{value:"3. Simplification with the OpenAI API",id:"3-simplification-with-the-openai-api",level:3},{value:"4. Hybrid Scenario",id:"4-hybrid-scenario",level:3},{value:"Conclusion",id:"conclusion",level:2}];function h(e){const n={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"conversational-memory-in-chatbots-and-ai-agents",children:"Conversational Memory in Chatbots and AI Agents"})}),"\n",(0,s.jsx)(n.p,{children:"This document explores the crucial concept of conversational state, or memory, in the development of chatbots and AI agents. It focuses on how an application can remember messages from past conversations, comparing traditional memory management approaches with the simplified method provided by the OpenAI API."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"key-themes-and-concepts",children:"Key Themes and Concepts"}),"\n",(0,s.jsx)(n.h3,{id:"1-the-concept-of-conversational-state-memory",children:"1. The Concept of Conversational State (Memory)"}),"\n",(0,s.jsx)(n.p,{children:'Conversational state refers to an application\'s ability to remember messages and information provided during a conversation. This memory is essential for chatbots and AI agents to "recall information" in subsequent exchanges. A lack of memory is a significant limitation in basic chatbots, which cannot remember information from previous messages, even within the same conversation.'}),"\n",(0,s.jsx)(n.h3,{id:"2-traditional-memory-management-approach",children:"2. Traditional Memory Management Approach"}),"\n",(0,s.jsx)(n.p,{children:"Historically, implementing conversational memory required manual management of message history:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Create a History List:"})," Initialize an empty list (e.g., ",(0,s.jsx)(n.code,{children:"history"}),") at the start of the conversation."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Store Messages:"})," After each user input, append the message to the history list as a dictionary with properties like ",(0,s.jsx)(n.code,{children:"role"}),' (e.g., "user") and ',(0,s.jsx)(n.code,{children:"content"})," (the user's message)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Send Full History:"})," Pass the entire ",(0,s.jsx)(n.code,{children:"history"})," list (containing all previous messages) to the agent with each request."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Store Agent Responses:"})," Add the agent's response to the history list as a dictionary with ",(0,s.jsx)(n.code,{children:"role"}),' (e.g., "assistant") and ',(0,s.jsx)(n.code,{children:"content"})," (the response text)."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:'While functional ("Now it remembered our name"), this method required significant manual handling of the message list.'}),"\n",(0,s.jsx)(n.h3,{id:"3-simplification-with-the-openai-api",children:"3. Simplification with the OpenAI API"}),"\n",(0,s.jsx)(n.p,{children:"OpenAI has integrated memory management directly into its API, greatly simplifying the process:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Unique Response ID:"})," Each API response has a unique ID. By default, messages are treated as independent."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Maintaining Conversation Context:"}),' To indicate that messages belong to the same conversation, pass the same response ID ("previous response ID") with each API call.']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Workflow:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Initialize a variable (e.g., ",(0,s.jsx)(n.code,{children:"current_response_id"}),") as ",(0,s.jsx)(n.code,{children:"None"})," at the start."]}),"\n",(0,s.jsxs)(n.li,{children:["For each API call, add a parameter ",(0,s.jsx)(n.code,{children:"previous_response_id"})," set to the value of ",(0,s.jsx)(n.code,{children:"current_response_id"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["After receiving a response, update ",(0,s.jsx)(n.code,{children:"current_response_id"})," to the response's ID."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"No Manual List Management:"}),' This method eliminates the need to manually manage a history list: "No dealing with lists, no appending values, nothing."']}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"\"How awesome is that? We didn't have to deal with lists. All we had to do was pass in this response ID and that's it.\""}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"4-hybrid-scenario",children:"4. Hybrid Scenario"}),"\n",(0,s.jsx)(n.p,{children:'The traditional history list approach remains relevant in some scenarios, such as when conversation history is initially retrieved from a database and loaded into the application ("if you are first retrieving the conversations from a database and loading it into your application for the first time"). In these cases, a hybrid approach is used:'}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Retrieve history from the database and create a list for the initial request."}),"\n",(0,s.jsx)(n.li,{children:"For subsequent messages, use the response ID method to maintain conversation continuity."}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"Conversational memory is essential for functional chatbots and AI agents. The OpenAI API has transformed what was once a manual and complex task\u2014managing a message history list\u2014into a simple and efficient process using a unique response ID to maintain conversation continuity. The hybrid approach remains useful for initializing conversations from existing data sources."})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var i=t(6540);const s={},a=i.createContext(s);function o(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);