"use strict";(self.webpackChunkmydevdocs=self.webpackChunkmydevdocs||[]).push([[9726],{2973:(e,i,s)=>{s.r(i),s.d(i,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>t,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"Portfolio/Chatbot/syntax-highlight-glitch","title":"Markdown syntax highliting glitch","description":"Overview:","source":"@site/docs/Portfolio/Chatbot/09-syntax-highlight-glitch.md","sourceDirName":"Portfolio/Chatbot","slug":"/Portfolio/Chatbot/syntax-highlight-glitch","permalink":"/dev/docs/Portfolio/Chatbot/syntax-highlight-glitch","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":9,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Markdown Rendering with Syntax Highlighting Implementation","permalink":"/dev/docs/Portfolio/Chatbot/markdown-display"},"next":{"title":"Enhancing Code Block Usability: A Sticky Copy Button","permalink":"/dev/docs/Portfolio/Chatbot/copy-btn-on-code-block"}}');var r=s(4848),o=s(8453);const t={},c="Markdown syntax highliting glitch",l={},d=[{value:"Overview:",id:"overview",level:2},{value:"Explanation:",id:"explanation",level:2},{value:"1. Global Styling &amp; Theme Overhaul (<code>angular.json</code>, <code>src/styles.scss</code>, <code>message-bubble.component.ts</code>)",id:"1-global-styling--theme-overhaul-angularjson-srcstylesscss-message-bubblecomponentts",level:3},{value:"2. Simplified Highlighting Logic (<code>message-bubble.component.ts</code>)",id:"2-simplified-highlighting-logic-message-bubblecomponentts",level:3},{value:"3. Prism.js Service Refactor &amp; SSR Compatibility (<code>prism.service.ts</code>)",id:"3-prismjs-service-refactor--ssr-compatibility-prismservicets",level:3},{value:"4. Dependency Downgrades (<code>package.json</code>, <code>package-lock.json</code>)",id:"4-dependency-downgrades-packagejson-package-lockjson",level:3},{value:"Best Practices:",id:"best-practices",level:3},{value:"Suggestions:",id:"suggestions",level:3}];function a(e){const i={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.header,{children:(0,r.jsx)(i.h1,{id:"markdown-syntax-highliting-glitch",children:"Markdown syntax highliting glitch"})}),"\n",(0,r.jsx)(i.h2,{id:"overview",children:"Overview:"}),"\n",(0,r.jsxs)(i.p,{children:["The changes refactor the integration of Prism.js for syntax highlighting, moving from a dynamic, lazy-loading approach to static imports. This enhances Server-Side Rendering (SSR) compatibility, simplifies the highlighting logic, and introduces a new, highly customized theme based on ",(0,r.jsx)(i.code,{children:"prism-okaidia.css"})," to improve the visual presentation of code blocks."]}),"\n",(0,r.jsx)(i.h2,{id:"explanation",children:"Explanation:"}),"\n",(0,r.jsxs)(i.h3,{id:"1-global-styling--theme-overhaul-angularjson-srcstylesscss-message-bubblecomponentts",children:["1. Global Styling & Theme Overhaul (",(0,r.jsx)(i.code,{children:"angular.json"}),", ",(0,r.jsx)(i.code,{children:"src/styles.scss"}),", ",(0,r.jsx)(i.code,{children:"message-bubble.component.ts"}),")"]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Theme Switch"}),": The ",(0,r.jsx)(i.code,{children:"angular.json"})," file now includes ",(0,r.jsx)(i.code,{children:"node_modules/prismjs/themes/prism-okaidia.css"})," in the global ",(0,r.jsx)(i.code,{children:"styles"})," array. This means the application will now use the Okaidia theme as its base for code highlighting. This change is mirrored in ",(0,r.jsx)(i.code,{children:"src/styles.scss"}),", where the previous ",(0,r.jsx)(i.code,{children:"prism.css"})," import is replaced by ",(0,r.jsx)(i.code,{children:"prism-okaidia.css"}),"."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Centralized & Customizable Styling"}),": The extensive custom CSS rules in ",(0,r.jsx)(i.code,{children:"src/styles.scss"})," are introduced to override and enhance the Okaidia theme. This includes new CSS variables for colors (e.g., ",(0,r.jsx)(i.code,{children:"--prism-background"}),", ",(0,r.jsx)(i.code,{children:"--prism-keyword"}),"), font family adjustments (like adding 'Fira Code' for ligatures), and fine-tuning spacing and borders. This approach centralizes the styling for Prism.js, making it easier to manage and modify."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Component Styling Removal"}),": Correspondingly, the inline ",(0,r.jsx)(i.code,{children:"<style>"})," block in ",(0,r.jsx)(i.code,{children:"message-bubble.component.ts"})," has had its ",(0,r.jsx)(i.code,{children:"pre"})," and ",(0,r.jsx)(i.code,{children:"code"})," specific styling removed. This is because the global ",(0,r.jsx)(i.code,{children:"prism-okaidia.css"})," and the custom overrides in ",(0,r.jsx)(i.code,{children:"styles.scss"})," now handle the base styling for code blocks, reducing redundancy and improving modularity."]}),"\n"]}),"\n",(0,r.jsxs)(i.h3,{id:"2-simplified-highlighting-logic-message-bubblecomponentts",children:["2. Simplified Highlighting Logic (",(0,r.jsx)(i.code,{children:"message-bubble.component.ts"}),")"]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Synchronous Highlighting"}),": The ",(0,r.jsx)(i.code,{children:"highlightCode"})," method in ",(0,r.jsx)(i.code,{children:"MessageBubbleComponent"})," is no longer ",(0,r.jsx)(i.code,{children:"async"})," and directly calls ",(0,r.jsx)(i.code,{children:"this.prismService.highlightElement"}),". The loop iterating over ",(0,r.jsx)(i.code,{children:"codeBlocks"})," no longer uses ",(0,r.jsx)(i.code,{children:"await"}),". This change is a direct result of the ",(0,r.jsx)(i.code,{children:"PrismService"})," no longer performing asynchronous loading of Prism.js (see next point)."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Immediate Highlighting on Markdown Ready"}),": The ",(0,r.jsx)(i.code,{children:"onMarkdownReady"})," lifecycle hook now calls ",(0,r.jsx)(i.code,{children:"this.highlightCode()"})," directly, removing the ",(0,r.jsx)(i.code,{children:"setTimeout(..., 0)"})," wrapper. This suggests that ",(0,r.jsx)(i.code,{children:"ngx-markdown"}),"'s event now reliably fires ",(0,r.jsx)(i.em,{children:"after"})," the markdown content has been rendered into the DOM, making immediate synchronous highlighting possible without deferring to the next tick."]}),"\n"]}),"\n",(0,r.jsxs)(i.h3,{id:"3-prismjs-service-refactor--ssr-compatibility-prismservicets",children:["3. Prism.js Service Refactor & SSR Compatibility (",(0,r.jsx)(i.code,{children:"prism.service.ts"}),")"]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Static Imports"}),": The ",(0,r.jsx)(i.code,{children:"PrismService"})," has been fundamentally changed. The previous dynamic ",(0,r.jsx)(i.code,{children:"loadPrism()"})," and ",(0,r.jsx)(i.code,{children:"loadLanguageComponents()"})," methods, which used ",(0,r.jsx)(i.code,{children:"await import()"})," to lazy-load Prism.js and its language components at runtime, have been removed. Instead, Prism core (",(0,r.jsx)(i.code,{children:"import 'prismjs';"}),") and a specific set of commonly used language components (e.g., ",(0,r.jsx)(i.code,{children:"prism-typescript"}),", ",(0,r.jsx)(i.code,{children:"prism-javascript"}),", ",(0,r.jsx)(i.code,{children:"prism-json"}),") are now directly imported at the top of the ",(0,r.jsx)(i.code,{children:"prism.service.ts"})," file. This means Prism.js and its languages are bundled with the application at compile time.","\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Implication"}),": This simplifies the service and ensures Prism is immediately available, but it increases the initial bundle size slightly as Prism and all imported languages are always included."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"SSR Compatibility"}),": The service now injects ",(0,r.jsx)(i.code,{children:"PLATFORM_ID"})," and uses ",(0,r.jsx)(i.code,{children:"isPlatformBrowser"})," from ",(0,r.jsx)(i.code,{children:"@angular/common"}),". All calls to ",(0,r.jsx)(i.code,{children:"Prism.highlightElement"})," and ",(0,r.jsx)(i.code,{children:"Prism.highlightAll"})," are guarded by ",(0,r.jsx)(i.code,{children:"if (this.isBrowser)"}),". This is a critical improvement for Server-Side Rendering (SSR) support, as Prism.js is a client-side library that relies on browser DOM APIs. By performing these checks, the application prevents errors when attempting to render on the server, ensuring a smoother universal rendering experience."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Synchronous Methods"}),": The ",(0,r.jsx)(i.code,{children:"highlightElement"})," and ",(0,r.jsx)(i.code,{children:"highlightAll"})," methods are now synchronous, reflecting the fact that Prism is already loaded and available due to the static imports."]}),"\n"]}),"\n",(0,r.jsxs)(i.h3,{id:"4-dependency-downgrades-packagejson-package-lockjson",children:["4. Dependency Downgrades (",(0,r.jsx)(i.code,{children:"package.json"}),", ",(0,r.jsx)(i.code,{children:"package-lock.json"}),")"]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["Minor version downgrades for ",(0,r.jsx)(i.code,{children:"marked"}),", ",(0,r.jsx)(i.code,{children:"ngx-markdown"}),", ",(0,r.jsx)(i.code,{children:"prismjs"}),", and ",(0,r.jsx)(i.code,{children:"@types/prismjs"})," are observed. For example, ",(0,r.jsx)(i.code,{children:"prismjs"})," was downgraded from ",(0,r.jsx)(i.code,{children:"^1.30.0"})," to ",(0,r.jsx)(i.code,{children:"^1.29.0"}),". While generally minor, downgrades are less common than upgrades and usually indicate a specific compatibility issue or a deliberate choice to align with a known stable version of these libraries within the project's ecosystem."]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"best-practices",children:"Best Practices:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"SSR Awareness"}),": Using ",(0,r.jsx)(i.code,{children:"PLATFORM_ID"})," and ",(0,r.jsx)(i.code,{children:"isPlatformBrowser"})," is a standard and crucial best practice for ensuring client-side libraries function correctly and avoid errors in an Angular Universal (SSR) environment."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Modular Styling"}),": Centralizing third-party library styles in global stylesheets and using CSS variables for theming promotes maintainability and easier theme management."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Readiness for External Libraries"}),": The change in ",(0,r.jsx)(i.code,{children:"onMarkdownReady"})," from ",(0,r.jsx)(i.code,{children:"setTimeout"})," to direct call indicates improved understanding or guarantees of the timing of DOM readiness from ",(0,r.jsx)(i.code,{children:"ngx-markdown"}),", leading to more robust and immediate code highlighting."]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"suggestions",children:"Suggestions:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Document Dependency Downgrades"}),": For the minor version downgrades of ",(0,r.jsx)(i.code,{children:"marked"}),", ",(0,r.jsx)(i.code,{children:"ngx-markdown"}),", ",(0,r.jsx)(i.code,{children:"prismjs"}),", and ",(0,r.jsx)(i.code,{children:"@types/prismjs"}),", it would be beneficial to add a comment in the commit message or project documentation explaining the reason. This prevents future developers from re-introducing potential issues by upgrading back to those specific versions."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Consider Granularity of Prism Imports"}),": While static imports simplify the service, if this application were to grow significantly and only a few specific code languages were consistently highlighted, a more granular import approach (e.g., loading only ",(0,r.jsx)(i.code,{children:"prism-typescript"})," if only TS code is expected) could further optimize bundle size. However, for a chat application that might display various code types, the current broad import list is practical."]}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,o.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},8453:(e,i,s)=>{s.d(i,{R:()=>t,x:()=>c});var n=s(6540);const r={},o=n.createContext(r);function t(e){const i=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function c(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),n.createElement(o.Provider,{value:i},e.children)}}}]);