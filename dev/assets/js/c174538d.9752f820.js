"use strict";(self.webpackChunkmydevdocs=self.webpackChunkmydevdocs||[]).push([[7394],{3467:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"Portfolio/Jsonamic/utils/json-processing","title":"JSON Processing Utilities","description":"Overview","source":"@site/docs/Portfolio/Jsonamic/utils/json-processing.md","sourceDirName":"Portfolio/Jsonamic/utils","slug":"/Portfolio/Jsonamic/utils/json-processing","permalink":"/dev/docs/Portfolio/Jsonamic/utils/json-processing","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Data Structures and Types","permalink":"/dev/docs/Portfolio/Jsonamic/types/data-structures"},"next":{"title":"Movie List Application - Introduction","permalink":"/dev/docs/Portfolio/MovieList/introduction"}}');var t=r(4848),i=r(8453);const a={},l="JSON Processing Utilities",c={},o=[{value:"Overview",id:"overview",level:2},{value:"Key Extraction (<code>extractKeys</code>)",id:"key-extraction-extractkeys",level:2},{value:"Value Formatting (<code>formatValue</code>)",id:"value-formatting-formatvalue",level:2},{value:"JSON Parsing (<code>parseJson</code>)",id:"json-parsing-parsejson",level:2},{value:"Path-based Value Access (<code>getValueByPath</code>)",id:"path-based-value-access-getvaluebypath",level:2},{value:"Object Expansion Check (<code>isExpandableObject</code>)",id:"object-expansion-check-isexpandableobject",level:2},{value:"Data Filtering (<code>filterData</code>)",id:"data-filtering-filterdata",level:2},{value:"Recursive Search (<code>searchInObject</code>)",id:"recursive-search-searchinobject",level:3},{value:"Data Sorting (<code>sortData</code>)",id:"data-sorting-sortdata",level:2},{value:"Key Design Principles",id:"key-design-principles",level:2},{value:"Immutability",id:"immutability",level:3},{value:"Type Safety",id:"type-safety",level:3},{value:"Error Resilience",id:"error-resilience",level:3},{value:"Performance Optimization",id:"performance-optimization",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"json-processing-utilities",children:"JSON Processing Utilities"})}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"The JSON processing utilities provide essential functions for parsing, filtering, sorting, and manipulating JSON data within the application. These functions handle the core data operations that power the visualizer's search, display, and navigation features."}),"\n",(0,t.jsxs)(n.h2,{id:"key-extraction-extractkeys",children:["Key Extraction (",(0,t.jsx)(n.code,{children:"extractKeys"}),")"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"export const extractKeys = (data: JSONObject[]): string[] => {\r\n  const keys = new Set<string>();\r\n  \r\n  const processObject = (obj: JSONObject, prefix = '') => {\r\n    for (const [key, value] of Object.entries(obj)) {\r\n      // Skip internal properties\r\n      if (key.startsWith('__')) continue;\r\n      \r\n      const currentKey = prefix ? `${prefix}.${key}` : key;\r\n      keys.add(currentKey);\r\n      \r\n      // Process nested objects\r\n      if (value !== null && typeof value === 'object' && !Array.isArray(value)) {\r\n        processObject(value as JSONObject, currentKey);\r\n      }\r\n    }\r\n  };\r\n  \r\n  data.forEach(obj => processObject(obj));\r\n  return Array.from(keys);\r\n};\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose"}),": Extracts all possible field names from a dataset, including nested object properties."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"How it works"}),":"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Uses a Set"})," to automatically deduplicate field names"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Recursive processing"})," - The ",(0,t.jsx)(n.code,{children:"processObject"})," function calls itself for nested objects"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Dot notation"})," - Nested fields are represented as ",(0,t.jsx)(n.code,{children:"parent.child.grandchild"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Skips internal fields"})," - Properties starting with ",(0,t.jsx)(n.code,{children:"__"})," (like ",(0,t.jsx)(n.code,{children:"__id"}),", ",(0,t.jsx)(n.code,{children:"__flags"}),") are ignored"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Type checking"})," - Only processes actual objects, not arrays or primitive values"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'const data = [\r\n  { name: "John", address: { street: "123 Main St", city: "Boston" } },\r\n  { name: "Jane", phone: "555-1234" }\r\n];\r\n\r\nextractKeys(data); \r\n// Returns: ["name", "address", "address.street", "address.city", "phone"]\n'})}),"\n",(0,t.jsxs)(n.h2,{id:"value-formatting-formatvalue",children:["Value Formatting (",(0,t.jsx)(n.code,{children:"formatValue"}),")"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"export const formatValue = (value: JSONValue): string => {\r\n  if (value === null) return 'null';\r\n  if (value === undefined) return 'undefined';\r\n  if (typeof value === 'object') return JSON.stringify(value);\r\n  return String(value);\r\n};\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose"}),": Converts any JSON value to a string for display purposes."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Handling different types"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"null/undefined"}),' - Returns literal strings "null" and "undefined"']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Objects/Arrays"})," - Converts to JSON string representation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Primitives"})," - Converts to string using ",(0,t.jsx)(n.code,{children:"String()"})," constructor"]}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"json-parsing-parsejson",children:["JSON Parsing (",(0,t.jsx)(n.code,{children:"parseJson"}),")"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"export const parseJson = (jsonString: string): JSONObject[] | null => {\r\n  try {\r\n    const parsed = JSON.parse(jsonString);\r\n    if (Array.isArray(parsed)) {\r\n      return parsed;\r\n    } else if (typeof parsed === 'object' && parsed !== null) {\r\n      return [parsed];\r\n    }\r\n    return null;\r\n  } catch (error) {\r\n    console.error('Failed to parse JSON:', error);\r\n    return null;\r\n  }\r\n};\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose"}),": Safely parses JSON strings and normalizes the result to an array format."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Normalization logic"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Array input"})," - Returns as-is"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Object input"})," - Wraps in an array ",(0,t.jsx)(n.code,{children:"[object]"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Other types"})," - Returns ",(0,t.jsx)(n.code,{children:"null"})," (invalid)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Parse errors"})," - Returns ",(0,t.jsx)(n.code,{children:"null"})," and logs error"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This ensures the application always works with arrays of objects, regardless of input format."}),"\n",(0,t.jsxs)(n.h2,{id:"path-based-value-access-getvaluebypath",children:["Path-based Value Access (",(0,t.jsx)(n.code,{children:"getValueByPath"}),")"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"export const getValueByPath = (obj: JSONObject, path: string): JSONValue | undefined => {\r\n  const keys = path.split('.');\r\n  return keys.reduce<unknown>((o, key) => {\r\n    if (o && typeof o === 'object' && key in o) {\r\n      return (o as Record<string, unknown>)[key];\r\n    }\r\n    return undefined;\r\n  }, obj);\r\n};\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose"}),": Retrieves values from nested objects using dot notation paths."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"How it works"}),":"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Splits path"})," - ",(0,t.jsx)(n.code,{children:'"address.street"'})," becomes ",(0,t.jsx)(n.code,{children:'["address", "street"]'})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reduces through keys"})," - Traverses the object one key at a time"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Type safety"})," - Checks that each step is an object before accessing properties"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Graceful failure"})," - Returns ",(0,t.jsx)(n.code,{children:"undefined"})," if any part of the path doesn't exist"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'const obj = { user: { profile: { name: "John" } } };\r\ngetValueByPath(obj, "user.profile.name"); // Returns: "John"\r\ngetValueByPath(obj, "user.profile.age");  // Returns: undefined\n'})}),"\n",(0,t.jsxs)(n.h2,{id:"object-expansion-check-isexpandableobject",children:["Object Expansion Check (",(0,t.jsx)(n.code,{children:"isExpandableObject"}),")"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"export const isExpandableObject = (value: JSONValue): boolean => {\r\n  return (\r\n    value !== null && \r\n    typeof value === 'object' && \r\n    !Array.isArray(value) && \r\n    Object.keys(value).length > 0\r\n  );\r\n};\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose"}),": Determines if a value is a non-empty object that can be expanded in the UI."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Criteria for expandable objects"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Not ",(0,t.jsx)(n.code,{children:"null"})]}),"\n",(0,t.jsx)(n.li,{children:"Is an object type"}),"\n",(0,t.jsx)(n.li,{children:"Not an array"}),"\n",(0,t.jsx)(n.li,{children:"Has at least one property"}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"data-filtering-filterdata",children:["Data Filtering (",(0,t.jsx)(n.code,{children:"filterData"}),")"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"export const filterData = (data: JSONObject[], searchTerm: string): JSONObject[] => {\r\n  if (!searchTerm.trim()) return data;\r\n  \r\n  let regex: RegExp;\r\n  try {\r\n    // Try to use the search term as a regex pattern\r\n    regex = new RegExp(searchTerm, 'i');\r\n  } catch (error) {\r\n    // If invalid regex, use as literal string\r\n    regex = new RegExp(searchTerm.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'i');\r\n  }\r\n  \r\n  return data.filter(item => searchInObject(item, regex));\r\n};\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose"}),": Filters data based on a search term with automatic regex support."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Smart regex handling"}),":"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Attempts regex"})," - Tries to use search term as a regular expression"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Fallback to literal"})," - If regex is invalid, escapes special characters for literal matching"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Case insensitive"})," - Uses the ",(0,t.jsx)(n.code,{children:"'i'"})," flag for case-insensitive matching"]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"recursive-search-searchinobject",children:["Recursive Search (",(0,t.jsx)(n.code,{children:"searchInObject"}),")"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const searchInObject = (obj: JSONObject, regex: RegExp): boolean => {\r\n  for (const [key, value] of Object.entries(obj)) {\r\n    // Skip internal properties\r\n    if (key.startsWith('__')) continue;\r\n    \r\n    // Search in string values\r\n    if (typeof value === 'string' && regex.test(value)) {\r\n      return true;\r\n    }\r\n    \r\n    // Search in number values converted to string\r\n    if (typeof value === 'number' && regex.test(String(value))) {\r\n      return true;\r\n    }\r\n    \r\n    // Search in nested objects and arrays\r\n    if (value !== null && typeof value === 'object') {\r\n      if (Array.isArray(value)) {\r\n        for (const item of value) {\r\n          if (typeof item === 'object' && item !== null && searchInObject(item as JSONObject, regex)) {\r\n            return true;\r\n          } else if ((typeof item === 'string' && regex.test(item)) || \r\n                     (typeof item === 'number' && regex.test(String(item)))) {\r\n            return true;\r\n          }\r\n        }\r\n      } else if (searchInObject(value as JSONObject, regex)) {\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n  \r\n  return false;\r\n};\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Deep search capabilities"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"String matching"})," - Direct regex test on string values"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Number matching"})," - Converts numbers to strings for searching"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Nested objects"})," - Recursively searches child objects"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Array elements"})," - Searches both primitive and object array elements"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Skips internals"})," - Ignores ",(0,t.jsx)(n.code,{children:"__"})," prefixed properties"]}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"data-sorting-sortdata",children:["Data Sorting (",(0,t.jsx)(n.code,{children:"sortData"}),")"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"export const sortData = (\r\n  data: JSONObject[], \r\n  key: string, \r\n  direction: 'asc' | 'desc'\r\n): JSONObject[] => {\r\n  return [...data].sort((a, b) => {\r\n    const valueA = getValueByPath(a, key);\r\n    const valueB = getValueByPath(b, key);\r\n    \r\n    // Handle undefined or null values\r\n    if (valueA === undefined || valueA === null) return direction === 'asc' ? -1 : 1;\r\n    if (valueB === undefined || valueB === null) return direction === 'asc' ? 1 : -1;\r\n    \r\n    // Compare based on type\r\n    if (typeof valueA === 'string' && typeof valueB === 'string') {\r\n      return direction === 'asc' \r\n        ? valueA.localeCompare(valueB)\r\n        : valueB.localeCompare(valueA);\r\n    }\r\n    \r\n    if (typeof valueA === 'number' && typeof valueB === 'number') {\r\n      return direction === 'asc' ? valueA - valueB : valueB - valueA;\r\n    }\r\n    \r\n    // Convert to string for mixed types\r\n    const strA = String(valueA);\r\n    const strB = String(valueB);\r\n    \r\n    return direction === 'asc' ? strA.localeCompare(strB) : strB.localeCompare(strA);\r\n  });\r\n};\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose"}),": Sorts data by a specified field with proper type handling."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Sorting logic"}),":"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Immutable"})," - Creates a copy with ",(0,t.jsx)(n.code,{children:"[...data]"})," before sorting"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Path support"})," - Uses ",(0,t.jsx)(n.code,{children:"getValueByPath"})," for nested field access"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Null handling"})," - Places null/undefined values at the beginning (asc) or end (desc)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Type-specific comparison"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Strings"})," - Uses ",(0,t.jsx)(n.code,{children:"localeCompare()"})," for proper locale-aware sorting"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Numbers"})," - Uses arithmetic comparison for numerical sorting"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Mixed types"})," - Converts to strings as fallback"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Direction support"})," - Reverses comparison for descending order"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"key-design-principles",children:"Key Design Principles"}),"\n",(0,t.jsx)(n.h3,{id:"immutability",children:"Immutability"}),"\n",(0,t.jsxs)(n.p,{children:["Functions like ",(0,t.jsx)(n.code,{children:"sortData"})," create new arrays rather than modifying input data, preventing unintended side effects."]}),"\n",(0,t.jsx)(n.h3,{id:"type-safety",children:"Type Safety"}),"\n",(0,t.jsx)(n.p,{children:"All functions include proper TypeScript typing and runtime type checking to handle the dynamic nature of JSON data."}),"\n",(0,t.jsx)(n.h3,{id:"error-resilience",children:"Error Resilience"}),"\n",(0,t.jsx)(n.p,{children:"Functions gracefully handle edge cases like null values, invalid regex patterns, and missing object properties."}),"\n",(0,t.jsx)(n.h3,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Uses ",(0,t.jsx)(n.code,{children:"Set"})," for deduplication in ",(0,t.jsx)(n.code,{children:"extractKeys"})]}),"\n",(0,t.jsx)(n.li,{children:"Implements early returns in search functions"}),"\n",(0,t.jsx)(n.li,{children:"Minimizes object traversal where possible"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"These utilities form the foundation for all data manipulation in the application, providing reliable and efficient processing of JSON data structures."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>l});var s=r(6540);const t={},i=s.createContext(t);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);