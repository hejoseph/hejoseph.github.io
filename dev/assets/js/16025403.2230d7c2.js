"use strict";(self.webpackChunkmydevdocs=self.webpackChunkmydevdocs||[]).push([[8216],{1392:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"java/Core/OOP/solid-principles","title":"SOLID Principles","description":"The SOLID principles are a set of five design principles in object-oriented programming intended to make software designs more understandable, flexible, and maintainable. They were promoted by Robert C. Martin (Uncle Bob) and are widely considered best practices for writing clean, robust, and scalable code.","source":"@site/docs/java/1-Core/1-OOP/4-solid-principles.md","sourceDirName":"java/1-Core/1-OOP","slug":"/java/Core/OOP/solid-principles","permalink":"/dev/docs/java/Core/OOP/solid-principles","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"java","permalink":"/dev/docs/tags/java"},{"inline":true,"label":"oop","permalink":"/dev/docs/tags/oop"},{"inline":true,"label":"design patterns","permalink":"/dev/docs/tags/design-patterns"},{"inline":true,"label":"software engineering","permalink":"/dev/docs/tags/software-engineering"}],"version":"current","sidebarPosition":4,"frontMatter":{"title":"SOLID Principles","sidebar_position":4,"tags":["java","oop","design patterns","software engineering"]},"sidebar":"tutorialSidebar","previous":{"title":"Composition Over Inheritance","permalink":"/dev/docs/java/Core/OOP/composition-inheritance"},"next":{"title":"Object Equality - equals() and hashCode()","permalink":"/dev/docs/java/Core/OOP/object-equality"}}');var t=r(4848),s=r(8453);const l={title:"SOLID Principles",sidebar_position:4,tags:["java","oop","design patterns","software engineering"]},a=void 0,o={},c=[{value:"1. Single Responsibility Principle (SRP)",id:"1-single-responsibility-principle-srp",level:3},{value:"2. Open/Closed Principle (OCP)",id:"2-openclosed-principle-ocp",level:3},{value:"3. Liskov Substitution Principle (LSP)",id:"3-liskov-substitution-principle-lsp",level:3},{value:"4. Interface Segregation Principle (ISP)",id:"4-interface-segregation-principle-isp",level:3},{value:"5. Dependency Inversion Principle (DIP)",id:"5-dependency-inversion-principle-dip",level:3}];function d(e){const n={code:"code",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"The SOLID principles are a set of five design principles in object-oriented programming intended to make software designs more understandable, flexible, and maintainable. They were promoted by Robert C. Martin (Uncle Bob) and are widely considered best practices for writing clean, robust, and scalable code."}),"\n",(0,t.jsx)(n.p,{children:"Each letter in SOLID stands for a principle:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"S"})," - Single Responsibility Principle"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"O"})," - Open/Closed Principle"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"L"})," - Liskov Substitution Principle"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"I"})," - Interface Segregation Principle"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"D"})," - Dependency Inversion Principle"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"1-single-responsibility-principle-srp",children:"1. Single Responsibility Principle (SRP)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Definition:"})," A class should have only one reason to change. This means a class should have one, and only one, primary responsibility."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Explanation:"}),' This principle aims to prevent a class from becoming a "God object" that handles too many unrelated concerns. When a class has multiple responsibilities, changes to one responsibility might inadvertently affect others, leading to bugs and making the class harder to understand and maintain. Separating concerns means each class focuses on a specific task.']}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Benefits:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reduced Coupling:"})," Classes are less dependent on each other."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Improved Maintainability:"})," Changes to one responsibility are isolated to one class."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Increased Readability:"})," Each class's purpose is clear."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Easier Testing:"})," Smaller, focused classes are easier to test."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example (Violation vs. Adherence):"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Violation (Single class handles multiple responsibilities):"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Anti-pattern: UserProfile handles user data AND database operations\r\nclass UserProfile {\r\n    private String username;\r\n    private String email;\r\n\r\n    public UserProfile(String username, String email) {\r\n        this.username = username;\r\n        this.email = email;\r\n    }\r\n\r\n    // Responsibility 1: User Data Management\r\n    public String getUsername() { return username; }\r\n    public String getEmail() { return email; }\r\n    public void setUsername(String username) { this.username = username; }\r\n    public void setEmail(String email) { this.email = email; }\r\n\r\n    // Responsibility 2: Database Persistence\r\n    public void saveToDatabase() {\r\n        System.out.println("Saving " + username + " to database...");\r\n        // Logic to save user to DB\r\n    }\r\n\r\n    public void loadFromDatabase(String username) {\r\n        System.out.println("Loading " + username + " from database...");\r\n        // Logic to load user from DB and populate fields\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Adherence (Responsibilities separated):"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Responsibility 1: User Data Management\r\nclass User {\r\n    private String username;\r\n    private String email;\r\n\r\n    public User(String username, String email) {\r\n        this.username = username;\r\n        this.email = email;\r\n    }\r\n\r\n    public String getUsername() { return username; }\r\n    public String getgetEmail() { return email; }\r\n    public void setUsername(String username) { this.username = username; }\r\n    public void setEmail(String email) { this.email = email; }\r\n}\r\n\r\n// Responsibility 2: User Persistence\r\nclass UserRepository {\r\n    public void save(User user) {\r\n        System.out.println("Saving " + user.getUsername() + " to database...");\r\n        // Logic to save user to DB\r\n    }\r\n\r\n    public User load(String username) {\r\n        System.out.println("Loading " + username + " from database...");\r\n        // Logic to load user from DB and return User object\r\n        return new User(username, "loaded@example.com"); // Dummy return\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"2-openclosed-principle-ocp",children:"2. Open/Closed Principle (OCP)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Definition:"})," Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Explanation:"})," This means you should be able to add new functionality to a system without altering existing, working code. When you modify existing code, you risk introducing new bugs into previously stable parts of the system. OCP is often achieved through the use of interfaces, abstract classes, and polymorphism."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Benefits:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Stability:"})," Existing code remains untouched, reducing the risk of regressions."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Scalability:"})," Easier to add new features without breaking old ones."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Maintainability:"}),' Less prone to "ripple effect" changes.']}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example (Violation vs. Adherence):"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Violation (Modifying existing code for new functionality):"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Anti-pattern: Need to modify Calculator every time a new operation is added\r\nclass Calculator {\r\n    public double calculate(char operation, double a, double b) {\r\n        switch (operation) {\r\n            case '+': return a + b;\r\n            case '-': return a - b;\r\n            // If we need a 'multiply' operation, we modify this class!\r\n            // case '*': return a * b; // This modifies existing code\r\n            default: throw new IllegalArgumentException(\"Invalid operation\");\r\n        }\r\n    }\r\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Adherence (Extending with new functionality):"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Open for extension: New operations can be added by implementing this interface\r\ninterface Operation {\r\n    double apply(double a, double b);\r\n}\r\n\r\n// Concrete implementations of operations\r\nclass AddOperation implements Operation {\r\n    @Override\r\n    public double apply(double a, double b) {\r\n        return a + b;\r\n    }\r\n}\r\n\r\nclass SubtractOperation implements Operation {\r\n    @Override\r\n    public double apply(double a, double b) {\r\n        return a - b;\r\n    }\r\n}\r\n\r\n// New functionality added without modifying existing Calculator or Operation interfaces\r\nclass MultiplyOperation implements Operation {\r\n    @Override\r\n    public double apply(double a, double b) {\r\n        return a * b;\r\n    }\r\n}\r\n\r\n// Closed for modification: Calculator class doesn't need to change\r\nclass BetterCalculator {\r\n    public double calculate(Operation operation, double a, double b) {\r\n        return operation.apply(a, b);\r\n    }\r\n}\r\n\r\n// Usage:\r\n// BetterCalculator calc = new BetterCalculator();\r\n// System.out.println(calc.calculate(new AddOperation(), 5, 3)); // 8.0\r\n// System.out.println(calc.calculate(new MultiplyOperation(), 5, 3)); // 15.0\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"3-liskov-substitution-principle-lsp",children:"3. Liskov Substitution Principle (LSP)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Definition:"})," Subtypes must be substitutable for their base types without altering the correctness of the program."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Explanation:"})," This principle means that if a program uses a base class, it should be able to use any of its subclasses interchangeably without causing errors or unexpected behavior. It primarily deals with behavioral subtyping, ensuring that derived classes extend the functionality of the base class without breaking its inherent contract. A common violation occurs when a subclass throws an unexpected exception or provides a no-op implementation for a method defined in the superclass, thus breaking the expected behavior."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Benefits:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Robustness:"})," Ensures that polymorphism works reliably."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Maintainability:"})," Prevents unexpected side effects when using subclasses."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Correctness:"})," Guarantees that code using base types will function correctly with derived types."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example (Violation vs. Adherence):"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Violation (Square is not a perfect substitute for Rectangle):"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Anti-pattern: Square breaks Rectangle\'s contract\r\nclass Rectangle {\r\n    protected int width;\r\n    protected int height;\r\n\r\n    public void setWidth(int width) { this.width = width; }\r\n    public void setHeight(int height) { this.height = height; }\r\n    public int getArea() { return width * height; }\r\n}\r\n\r\nclass Square extends Rectangle {\r\n    @Override\r\n    public void setWidth(int width) {\r\n        this.width = width;\r\n        this.height = width; // Changing width also changes height\r\n    }\r\n    @Override\r\n    public void setHeight(int height) {\r\n        this.width = height; // Changing height also changes width\r\n        this.height = height;\r\n    }\r\n}\r\n\r\n// Test method that expects Rectangle behavior\r\nclass TestLSP {\r\n    public static void printArea(Rectangle r) {\r\n        r.setWidth(5);\r\n        r.setHeight(4); // We expect area to be 20\r\n        System.out.println("Expected Area: " + 5 * 4 + ", Actual Area: " + r.getArea());\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        Rectangle rect = new Rectangle();\r\n        printArea(rect); // Expected: 20, Actual: 20 (Correct)\r\n\r\n        Rectangle square = new Square();\r\n        printArea(square); // Expected: 20, Actual: 16 (Violation! Square changed height to 5 after setWidth)\r\n    }\r\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Adherence (Better design for shapes or using separate abstractions):"}),"\r\nInstead of forcing ",(0,t.jsx)(n.code,{children:"Square"})," into an ",(0,t.jsx)(n.code,{children:"is-a"})," ",(0,t.jsx)(n.code,{children:"Rectangle"})," relationship when it breaks its contract, consider:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Having an abstract ",(0,t.jsx)(n.code,{children:"Shape"})," base class with an ",(0,t.jsx)(n.code,{children:"getArea()"})," method. ",(0,t.jsx)(n.code,{children:"Rectangle"})," and ",(0,t.jsx)(n.code,{children:"Square"})," are both ",(0,t.jsx)(n.code,{children:"Shape"}),"s, but don't inherit from each other directly if their behaviors clash."]}),"\n",(0,t.jsxs)(n.li,{children:["If inheritance is desired, ensure ",(0,t.jsx)(n.code,{children:"Square"})," doesn't override methods in a way that breaks ",(0,t.jsx)(n.code,{children:"Rectangle"}),"'s contract. (Often, this means ",(0,t.jsx)(n.code,{children:"Square"})," should not inherit from ",(0,t.jsx)(n.code,{children:"Rectangle"})," directly if ",(0,t.jsx)(n.code,{children:"Rectangle"})," has mutable width/height setters)."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"A simpler adherence example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'interface Flyable {\r\n    void fly();\r\n}\r\n\r\nclass Bird implements Flyable {\r\n    @Override\r\n    public void fly() {\r\n        System.out.println("Bird is flying.");\r\n    }\r\n}\r\n\r\nclass Eagle extends Bird { // Eagle is a Bird, and can fly\r\n    // Overrides fly() behavior but still fulfills Flyable contract\r\n    @Override\r\n    public void fly() {\r\n        System.out.println("Eagle is soaring.");\r\n    }\r\n}\r\n\r\n// Violation example (if Penguin implements Flyable but can\'t fly):\r\n// class Penguin implements Flyable {\r\n//     @Override\r\n//     public void fly() {\r\n//         throw new UnsupportedOperationException("Penguins cannot fly!"); // Violates LSP\r\n//     }\r\n// }\r\n\r\n// Correct way for Penguin (don\'t force it to implement Flyable)\r\nclass Penguin {\r\n    public void swim() {\r\n        System.out.println("Penguin is swimming.");\r\n    }\r\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["LSP suggests that ",(0,t.jsx)(n.code,{children:"Penguin"})," should not implement ",(0,t.jsx)(n.code,{children:"Flyable"})," if it cannot truly fly, as it would break the expectation of any code expecting a ",(0,t.jsx)(n.code,{children:"Flyable"})," object to be able to fly."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"4-interface-segregation-principle-isp",children:"4. Interface Segregation Principle (ISP)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Definition:"})," Clients should not be forced to depend on interfaces they do not use. Rather than one large interface, many smaller, client-specific interfaces are better."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Explanation:"}),' This principle is about breaking down "fat" interfaces into smaller, more specific ones. If an interface has too many methods, some classes implementing it might only need a subset of those methods, being forced to implement others they don\'t use (often as empty or throwing methods). Segregating interfaces ensures that a class only depends on the methods it actually needs.']}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Benefits:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reduced Coupling:"})," Classes are only coupled to the interfaces they genuinely use."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Improved Maintainability:"})," Easier to change or refactor interfaces."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Increased Flexibility:"})," Easier to implement only the necessary behaviors."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example (Violation vs. Adherence):"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:'Violation (A single, "fat" interface):'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Anti-pattern: Multi-purpose Worker interface\r\ninterface Worker {\r\n    void work();\r\n    void eat();\r\n    void sleep(); // Not all workers might need to 'sleep' in a computational context\r\n    void manage(); // Not all workers are managers\r\n}\r\n\r\nclass HumanWorker implements Worker {\r\n    @Override public void work() { /* ... */ }\r\n    @Override public void eat() { /* ... */ }\r\n    @Override public void sleep() { /* ... */ }\r\n    @Override public void manage() { /* ... */ } // Human workers can manage\r\n}\r\n\r\nclass RobotWorker implements Worker {\r\n    @Override public void work() { /* ... */ }\r\n    @Override public void eat() { /* Robot doesn't eat */ } // Forced to implement\r\n    @Override public void sleep() { /* Robot doesn't sleep */ } // Forced to implement\r\n    @Override public void manage() { /* Robot doesn't manage */ } // Forced to implement\r\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Adherence (Segregated interfaces):"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Smaller, specific interfaces\r\ninterface Workable {\r\n    void work();\r\n}\r\n\r\ninterface Eatable {\r\n    void eat();\r\n}\r\n\r\ninterface Sleepable {\r\n    void sleep();\r\n}\r\n\r\ninterface Manageable {\r\n    void manage();\r\n}\r\n\r\nclass HumanWorker implements Workable, Eatable, Sleepable, Manageable {\r\n    @Override public void work() { System.out.println("Human working."); }\r\n    @Override public void eat() { System.out.println("Human eating."); }\r\n    @Override public void sleep() { System.out.println("Human sleeping."); }\r\n    @Override public void manage() { System.out.println("Human managing."); }\r\n}\r\n\r\nclass RobotWorker implements Workable { // Only implements what it needs\r\n    @Override public void work() { System.out.println("Robot working."); }\r\n}\r\n\r\n// If a robot could also be manageable:\r\n// class ManagerRobot implements Workable, Manageable {\r\n//     @Override public void work() { System.out.println("Manager robot working."); }\r\n//     @Override public void manage() { System.out.println("Manager robot managing."); }\r\n// }\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"5-dependency-inversion-principle-dip",children:"5. Dependency Inversion Principle (DIP)"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Definition:"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"High-level modules should not depend on low-level modules. Both should depend on abstractions."}),"\n",(0,t.jsx)(n.li,{children:"Abstractions should not depend on details. Details should depend on abstractions."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Explanation:"})," This principle promotes decoupling software modules. Instead of a high-level module (which contains complex logic) depending directly on a low-level module (which handles specific tasks like database access or hardware control), both should depend on an abstraction (an interface or abstract class). This allows for easier swapping of implementations and makes the system more testable and flexible."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Benefits:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Loose Coupling:"})," High-level and low-level modules are not directly connected."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Increased Flexibility:"})," Easy to change low-level implementations without affecting high-level logic."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Easier Testing:"})," Low-level dependencies can be mocked or stubbed for unit testing."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example (Violation vs. Adherence):"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Violation (High-level module depends on low-level concrete module):"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Anti-pattern: LightSwitch directly depends on a specific LightBulb implementation\r\nclass LightBulb { // Low-level module (detail)\r\n    public void turnOn() { System.out.println("LightBulb: On"); }\r\n    public void turnOff() { System.out.println("LightBulb: Off"); }\r\n}\r\n\r\nclass LightSwitch { // High-level module (logic)\r\n    private LightBulb bulb; // Direct dependency on concrete class\r\n\r\n    public LightSwitch() {\r\n        this.bulb = new LightBulb(); // Tightly coupled: LightSwitch creates its own LightBulb\r\n    }\r\n\r\n    public void press() {\r\n        // Logic to decide whether to turn on or off\r\n        // For simplicity, let\'s just toggle\r\n        if (bulb.isOn()) { // Assuming an isOn() method\r\n            bulb.turnOff();\r\n        } else {\r\n            bulb.turnOn();\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Adherence (Both depend on an abstraction):"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Abstraction (interface)\r\ninterface Switchable {\r\n    void turnOn();\r\n    void turnOff();\r\n    boolean isOn(); // Assume an isOn method for state\r\n}\r\n\r\n// Low-level module (details) depend on abstraction\r\nclass LightBulb implements Switchable {\r\n    private boolean on = false;\r\n    @Override public void turnOn() { System.out.println("LightBulb: On"); on = true; }\r\n    @Override public void turnOff() { System.out.println("LightBulb: Off"); on = false; }\r\n    @Override public boolean isOn() { return on; }\r\n}\r\n\r\nclass Fan implements Switchable { // Another low-level detail\r\n    private boolean on = false;\r\n    @Override public void turnOn() { System.out.println("Fan: On"); on = true; }\r\n    @Override public void turnOff() { System.out.println("Fan: Off"); on = false; }\r\n    @Override public boolean isOn() { return on; }\r\n}\r\n\r\n// High-level module (logic) depends on abstraction\r\nclass Button {\r\n    private Switchable device; // Depends on abstraction\r\n\r\n    // Dependency Injection: The Switchable device is injected (provided from outside)\r\n    public Button(Switchable device) {\r\n        this.device = device;\r\n    }\r\n\r\n    public void press() {\r\n        if (device.isOn()) {\r\n            device.turnOff();\r\n        } else {\r\n            device.turnOn();\r\n        }\r\n    }\r\n}\r\n\r\n// Usage:\r\n// Button lightButton = new Button(new LightBulb()); // Inject LightBulb\r\n// lightButton.press(); // LightBulb: On\r\n// lightButton.press(); // LightBulb: Off\r\n\r\n// Button fanButton = new Button(new Fan()); // Inject Fan\r\n// fanButton.press(); // Fan: On\n'})}),"\n",(0,t.jsxs)(n.p,{children:["In the adherence example, the ",(0,t.jsx)(n.code,{children:"Button"})," (high-level) doesn't know or care about the concrete type of ",(0,t.jsx)(n.code,{children:"Switchable"})," device it controls. It operates purely on the ",(0,t.jsx)(n.code,{children:"Switchable"})," interface, making it highly flexible. You can connect a ",(0,t.jsx)(n.code,{children:"Button"})," to a ",(0,t.jsx)(n.code,{children:"LightBulb"}),", a ",(0,t.jsx)(n.code,{children:"Fan"}),", or any other ",(0,t.jsx)(n.code,{children:"Switchable"})," device without modifying the ",(0,t.jsx)(n.code,{children:"Button"})," class. This is also the foundation for dependency injection frameworks."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>a});var i=r(6540);const t={},s=i.createContext(t);function l(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);