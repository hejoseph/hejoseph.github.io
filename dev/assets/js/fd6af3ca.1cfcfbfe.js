"use strict";(self.webpackChunkmydevdocs=self.webpackChunkmydevdocs||[]).push([[6167],{5429:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"Portfolio/CodeTyper/Code-Breakdown/CodeTyper","title":"CodeTyper Use Case: Code Breakdown - CodeTyper.tsx","description":"This document provides a detailed breakdown of the CodeTyper.tsx component, which is the most complex and important component in the application.","source":"@site/docs/Portfolio/CodeTyper/Code-Breakdown/01-CodeTyper.md","sourceDirName":"Portfolio/CodeTyper/Code-Breakdown","slug":"/Portfolio/CodeTyper/Code-Breakdown/CodeTyper","permalink":"/dev/docs/Portfolio/CodeTyper/Code-Breakdown/CodeTyper","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"CodeTyper Use Case: Code Deep Dive","permalink":"/dev/docs/Portfolio/CodeTyper/code-deep-dive"},"next":{"title":"CodeTyper Use Case: Code Breakdown - App.tsx","permalink":"/dev/docs/Portfolio/CodeTyper/Code-Breakdown/App"}}');var s=t(4848),i=t(8453);const a={},c="CodeTyper Use Case: Code Breakdown - CodeTyper.tsx",o={},d=[{value:"State Management",id:"state-management",level:2},{value:"Core Functions",id:"core-functions",level:2},{value:"Rendering Logic",id:"rendering-logic",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"codetyper-use-case-code-breakdown---codetypertsx",children:"CodeTyper Use Case: Code Breakdown - CodeTyper.tsx"})}),"\n",(0,s.jsxs)(n.p,{children:["This document provides a detailed breakdown of the ",(0,s.jsx)(n.code,{children:"CodeTyper.tsx"})," component, which is the most complex and important component in the application."]}),"\n",(0,s.jsx)(n.h2,{id:"state-management",children:"State Management"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"CodeTyper"})," component uses a number of state variables to manage its behavior. Here is a breakdown of each one, along with a code snippet that shows how it is initialized:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"selectedLanguage"}),": The programming language that is currently selected by the user."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const [selectedLanguage, setSelectedLanguage] = useState('javascript');\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"customCode"}),": The code that the user has provided to practice with."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const [customCode, setCustomCode] = useState('');\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"selectedTab"}),': The tab that is currently selected by the user (either "Sample Code" or "Custom Code").']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const [selectedTab, setSelectedTab] = useState(0);\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"selectedLLM"}),": The large language model that is currently selected by the user."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const [selectedLLM, setSelectedLLM] = useState('gemini');\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"prompt"}),": The prompt that the user has provided to generate code with."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const [prompt, setPrompt] = useState('');\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"isGenerating"}),": A boolean that indicates whether the application is currently generating code."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const [isGenerating, setIsGenerating] = useState(false);\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"geminiApiKey"}),": The user's Gemini API key."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const [geminiApiKey, setGeminiApiKey] = useState('');\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"typingCode"}),": The code that the user is currently typing."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const [typingCode, setTypingCode] = useState(() => getRandomCode(selectedLanguage));\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"wpm"}),": The user's words per minute."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const [wpm, setWpm] = useState(0);\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"accuracy"}),": The user's typing accuracy."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const [accuracy, setAccuracy] = useState(100);\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"errors"}),": The number of errors that the user has made."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const [errors, setErrors] = useState(0);\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"typingStarted"}),": A boolean that indicates whether the user has started typing."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const [typingStarted, setTypingStarted] = useState(false);\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"typedChars"}),": The characters that the user has typed so far."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const [typedChars, setTypedChars] = useState('');\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"currentCharIndex"}),": The index of the character that the user is currently typing."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const [currentCharIndex, setCurrentCharIndex] = useState(0);\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"cursorPosition"}),": The position of the cursor in the code editor."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const [cursorPosition, setCursorPosition] = useState<Position>({ line: 0, column: 0 });\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"startTime"}),": The time at which the user started typing."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const [startTime, setStartTime] = useState<number | null>(null);\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"typingErrors"}),": An array of objects that contains information about the errors that the user has made."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const [typingErrors, setTypingErrors] = useState<TypingErrorInfo[]>([]);\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"core-functions",children:"Core Functions"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"CodeTyper"})," component has a number of core functions that are responsible for its behavior. Here is a breakdown of each one, along with a code snippet that shows how it is implemented:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"handleKeyDown"}),": This function is called every time the user presses a key. It is responsible for handling all of the user's input, including special keys like ",(0,s.jsx)(n.code,{children:"Tab"}),", ",(0,s.jsx)(n.code,{children:"Enter"}),", and ",(0,s.jsx)(n.code,{children:"Backspace"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const handleKeyDown = (e: React.KeyboardEvent) => {\n  if (!typingStarted) return;\n\n  // Get expected character\n  const expectedChar = typingCode.charAt(currentCharIndex);\n\n  // Special key handling\n  if (e.key === 'Tab') {\n    e.preventDefault();\n    handleTabKey();\n    return;\n  }\n\n  if (e.key === 'Enter') {\n    e.preventDefault();\n    handleEnterKey();\n    return;\n  }\n\n  if (e.key === 'Backspace') {\n    e.preventDefault();\n    handleBackspaceKey();\n    return;\n  }\n\n  // Regular character handling\n  if (e.key.length === 1) {\n    e.preventDefault();\n\n    if (e.key === expectedChar) {\n      // Correct key\n      setTypedChars(prev => prev + e.key);\n      setCurrentCharIndex(prev => prev + 1);\n\n      // Remove any errors at this position if they exist (from backspace and retry)\n      setTypingErrors(prev => prev.filter(err => err.index !== currentCharIndex));\n    } else {\n      // Wrong key\n      setErrors(prev => prev + 1);\n\n      // Add to typing errors\n      setTypingErrors(prev => [\n        ...prev,\n        {\n          index: currentCharIndex,\n          expected: expectedChar,\n          actual: e.key\n        }\n      ]);\n\n      setTypedChars(prev => prev + e.key);\n      setCurrentCharIndex(prev => prev + 1);\n\n      // Recalculate accuracy\n      const totalChars = currentCharIndex + 1;\n      const totalErrors = errors + 1;\n      setAccuracy(Math.max(0, Math.round(100 - (totalErrors / totalChars) * 100)));\n    }\n\n    // Check if typing is completed\n    if (currentCharIndex + 1 >= typingCode.length) {\n      // Typing completed\n      setTypingStarted(false);\n\n      // Final WPM calculation\n      if (startTime) {\n        const now = Date.now();\n        const elapsedMinutes = (now - startTime) / 60000;\n        const wordCount = (typedChars.length + 1) / 5; // +1 for the last char\n        setWpm(Math.round(wordCount / elapsedMinutes));\n      }\n    }\n  }\n};\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"handleEnterKey"}),": This function is called when the user presses the ",(0,s.jsx)(n.code,{children:"Enter"})," key. It is responsible for adding a newline character to the user's typed text and then inserting the same indentation as the previous line."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const handleEnterKey = () => {\n  const expectedChar = typingCode.charAt(currentCharIndex);\n  if (expectedChar === '\\n') {\n    // Get the indentation from the current line BEFORE we move to the next.\n    const lines = typedChars.split('\\n');\n    const currentLine = lines[lines.length - 1] || '';\n    const indentationMatch = currentLine.match(/^(\\s*)/);\n    const indentation = indentationMatch ? indentationMatch[1] : '';\n\n    // Add the newline and the indentation from the previous line.\n    const textToInsert = '\\n' + indentation;\n    setTypedChars(prev => prev + textToInsert);\n\n    // We need to advance the character index, but only by the number of characters\n    // that actually match the typingCode. This handles cases where the auto-indent\n    // is incorrect (e.g., for a closing brace).\n    let matchingChars = 0;\n    for (let i = 0; i < textToInsert.length; i++) {\n      if (textToInsert[i] === typingCode.charAt(currentCharIndex + i)) {\n        matchingChars++;\n      } else {\n        // Stop counting when a mismatch occurs.\n        break;\n      }\n    }\n    \n    // The user is still responsible for typing the whole line, but we can advance\n    // past the auto-inserted newline and any correct indentation.\n    setCurrentCharIndex(prev => prev + matchingChars);\n\n  } else {\n    // Enter wasn't expected, count as an error.\n    setErrors(prev => prev + 1);\n  }\n};\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"handleBackspaceKey"}),": This function is called when the user presses the ",(0,s.jsx)(n.code,{children:"Backspace"}),' key. It is responsible for deleting characters from the user\'s typed text. It also includes a "smart backspace" feature that allows the user to delete entire blocks of indentation at once.']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const handleBackspaceKey = () => {\n  if (currentCharIndex > 0) {\n    // Handle backspace - check if we're at the beginning of indentation\n    const pos = cursorPosition;\n    const lines = typingCode.split('\\n');\n    const currentLine = lines[pos.line] || '';\n    const lineStart = currentLine.match(/^(\\s+)/);\n\n    // If at the start of a line with indentation, delete a full tab/indentation block\n    if (pos.column > 0 && pos.column === lineStart?.[1].length) {\n      // How many spaces to delete (2 or 4 based on indentation)\n      const spacesToDelete = (lineStart[1].length % 4 === 0) ?\n                           Math.min(4, pos.column) :\n                           Math.min(2, pos.column);\n\n      setTypedChars(prev => prev.slice(0, -spacesToDelete));\n      setCurrentCharIndex(prev => prev - spacesToDelete);\n    } else {\n      // Normal single character backspace\n      setTypedChars(prev => prev.slice(0, -1));\n      setCurrentCharIndex(prev => prev - 1);\n    }\n  }\n};\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"resetTyping"}),': This function is called when the user clicks the "Restart" button. It is responsible for resetting the application to its initial state.']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const resetTyping = useCallback((newCode?: string) => {\n  setTypingCode(newCode ?? getRandomCode(selectedLanguage));\n  setTypingStarted(false);\n  setTypedChars('');\n  setCurrentCharIndex(0);\n  setCursorPosition({ line: 0, column: 0 });\n  setWpm(0);\n  setAccuracy(100);\n  setErrors(0);\n  setStartTime(null);\n  setTypingErrors([]);\n}, [selectedLanguage, getRandomCode]);\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"rendering-logic",children:"Rendering Logic"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"CodeTyper"})," component uses the ",(0,s.jsx)(n.code,{children:"renderTypingArea"})," function to render the code editor. This function uses the ",(0,s.jsx)(n.code,{children:"highlight.js"})," library to provide syntax highlighting for the code. It also includes logic to display the user's typed text, the cursor, and any errors that the user has made."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const renderTypingArea = () => {\n  if (!typingStarted) {\n    // Show regular highlighted code when not typing in gray color\n    return (\n      <pre className=\"font-mono text-sm whitespace-pre-wrap\">\n        <code className={`language-${selectedLanguage} text-gray-400 dark:text-gray-500`}>\n          {typingCode}\n        </code>\n      </pre>\n    );\n  }\n\n  const highlightedCode = getHighlightedCode(typingCode, selectedLanguage);\n  const lines = typingCode.split('\\n');\n  let charIndex = 0;\n  let highlightedCharIndex = 0;\n\n  // Function to parse highlighted HTML and create spans with classes\n  const parseHighlightedHtml = (htmlString: string) => {\n    const parser = new DOMParser();\n    const doc = parser.parseFromString(htmlString, 'text/html');\n    const spans: { char: string; className: string; index: number }[] = [];\n\n    const traverse = (node: Node) => {\n      if (node.nodeType === Node.TEXT_NODE) {\n        const text = node.textContent || '';\n        for (const char of text) {\n          spans.push({ char, className: '', index: highlightedCharIndex });\n          highlightedCharIndex++;\n        }\n      } else if (node.nodeType === Node.ELEMENT_NODE) {\n        const element = node as HTMLElement;\n        const className = element.className;\n        for (const child of Array.from(element.childNodes)) {\n          if (child.nodeType === Node.TEXT_NODE) {\n            const text = child.textContent || '';\n            for (const char of text) {\n              spans.push({ char, className, index: highlightedCharIndex });\n              highlightedCharIndex++;\n            }\n          } else if (child.nodeType === Node.ELEMENT_NODE) {\n            traverse(child);\n          }\n        }\n      }\n    };\n\n    traverse(doc.body);\n    return spans;\n  };\n\n  const highlightedSpans = parseHighlightedHtml(highlightedCode);\n\n  return (\n    <div className=\"font-mono text-sm whitespace-pre\">\n      {lines.map((line, lineIdx) => {\n        const lineContent = [];\n        const lineStartCharIndex = charIndex;\n\n        for (let i = 0; i < line.length; i++) {\n          const char = line[i];\n          const currentIndex = lineStartCharIndex + i;\n          const isTyped = currentIndex < currentCharIndex;\n          const isCurrent = currentIndex === currentCharIndex;\n          const isError = hasError(currentIndex);\n          const highlightedSpan = highlightedSpans.find(s => s.index === currentIndex);\n          const syntaxClass = highlightedSpan ? highlightedSpan.className : '';\n\n          if (isTyped) {\n            lineContent.push(\n              <span\n                key={`char-${currentIndex}-${char.charCodeAt(0)}`}\n                className={`${isError ? 'text-red-500 underline decoration-red-500 decoration-wavy' : syntaxClass}`}\n              >\n                {char}\n              </span>\n            );\n          } else if (isCurrent) {\n            lineContent.push(\n              <span key={`cursor-${currentIndex}`} ref={cursorRef} className=\"bg-primary text-primary-foreground\">\n                {char}\n              </span>\n            );\n          } else {\n            lineContent.push(\n              <span key={`untyped-${currentIndex}`} className=\"text-gray-400 dark:text-gray-500\">\n                {char}\n              </span>\n            );\n          }\n        }\n\n        // Add cursor at end of line if needed\n        if (cursorPosition.line === lineIdx && cursorPosition.column === line.length) {\n          if (currentCharIndex === charIndex) {\n            // If the next character is a newline, show a special cursor\n            lineContent.push(\n              <span key={`cursor-eol-${charIndex}`} className=\"bg-primary text-primary-foreground\">\n                \u23ce\n              </span>\n            );\n          }\n        }\n\n        // Add newline character to the index count\n        if (lineIdx < lines.length - 1) {\n          charIndex += line.length + 1; // +1 for the newline character\n        } else {\n          charIndex += line.length;\n        }\n\n        return (\n          <div key={`line-${lineIdx}-${line.substring(0, Math.min(line.length, 5))}`} className=\"flex\">\n            {lineContent.length > 0 ? lineContent : <span>&nbsp;</span>}\n          </div>\n        );\n      })}\n    </div>\n  );\n};\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>c});var r=t(6540);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);