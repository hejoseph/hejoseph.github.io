"use strict";(self.webpackChunkmydevdocs=self.webpackChunkmydevdocs||[]).push([[9270],{8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var s=i(6540);const t={},r=s.createContext(t);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:n},e.children)}},8922:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"java/Core/OOP/composition-inheritance","title":"Composition Over Inheritance","description":"\\"Composition over Inheritance\\" (also known as \\"favor composition over inheritance\\") is a design principle in object-oriented programming that suggests that classes should achieve new functionality by composing objects of existing classes (i.e., by containing instances of other classes) rather than by inheriting from them. This principle promotes greater flexibility, reduced coupling, and better code reusability.","source":"@site/docs/java/1-Core/1-OOP/3-composition-inheritance.md","sourceDirName":"java/1-Core/1-OOP","slug":"/java/Core/OOP/composition-inheritance","permalink":"/dev/docs/java/Core/OOP/composition-inheritance","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"java","permalink":"/dev/docs/tags/java"},{"inline":true,"label":"oop","permalink":"/dev/docs/tags/oop"},{"inline":true,"label":"design patterns","permalink":"/dev/docs/tags/design-patterns"},{"inline":true,"label":"composition","permalink":"/dev/docs/tags/composition"},{"inline":true,"label":"inheritance","permalink":"/dev/docs/tags/inheritance"}],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Composition Over Inheritance","sidebar_position":3,"tags":["java","oop","design patterns","composition","inheritance"]},"sidebar":"tutorialSidebar","previous":{"title":"Interfaces vs. Abstract Classes","permalink":"/dev/docs/java/Core/OOP/interface-abstract"},"next":{"title":"SOLID Principles","permalink":"/dev/docs/java/Core/OOP/solid-principles"}}');var t=i(4848),r=i(8453);const o={title:"Composition Over Inheritance",sidebar_position:3,tags:["java","oop","design patterns","composition","inheritance"]},a=void 0,l={},c=[{value:"The Problem with Inheritance",id:"the-problem-with-inheritance",level:3},{value:"What is Composition?",id:"what-is-composition",level:3},{value:"Advantages of Composition",id:"advantages-of-composition",level:3},{value:"Disadvantages of Composition",id:"disadvantages-of-composition",level:3},{value:"Illustrative Example: A <code>Car</code> and its <code>Engine</code>",id:"illustrative-example-a-car-and-its-engine",level:3},{value:"When to Choose Which",id:"when-to-choose-which",level:3}];function d(e){const n={code:"code",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:'"Composition over Inheritance" (also known as "favor composition over inheritance") is a design principle in object-oriented programming that suggests that classes should achieve new functionality by composing objects of existing classes (i.e., by containing instances of other classes) rather than by inheriting from them. This principle promotes greater flexibility, reduced coupling, and better code reusability.'}),"\n",(0,t.jsx)(n.h3,{id:"the-problem-with-inheritance",children:"The Problem with Inheritance"}),"\n",(0,t.jsxs)(n.p,{children:["While inheritance (",(0,t.jsx)(n.code,{children:"extends"})," keyword in Java) is a fundamental OOP concept for achieving code reuse and polymorphism, it can lead to several issues, especially in complex systems:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Tight Coupling:"}),' Inheritance creates a strong, rigid relationship between the parent (superclass) and child (subclass). The subclass becomes dependent on the superclass\'s implementation details. Changes in the superclass can unexpectedly affect subclasses (the "fragile base class problem").']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Liskov Substitution Principle (LSP) Violations:"})," Sometimes, developers use inheritance purely for code reuse, even when the \"is-a\" relationship (which inheritance implies) doesn't strictly hold true. This can lead to subclasses that cannot be substituted for their superclass without breaking the program's correctness."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Limited Flexibility:"})," A class can only inherit from one superclass in Java (single inheritance). If a class needs functionality from multiple unrelated sources, inheritance becomes problematic."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Exposing Superclass Internals:"})," Inheritance often exposes the superclass's protected or even private members to subclasses, making encapsulation weaker."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Difficulty in Changing Behavior at Runtime:"})," The behavior inherited from a superclass is fixed at compile time. It's difficult to change an object's inherited behavior dynamically."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"what-is-composition",children:"What is Composition?"}),"\n",(0,t.jsx)(n.p,{children:'Composition involves building complex objects by combining simpler, existing objects. Instead of inheriting behavior from a base class, a class acquires new behavior by holding an instance of another class and delegating tasks to that instance. This creates a "has-a" relationship.'}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Example:"})," A ",(0,t.jsx)(n.code,{children:"Car"}),' "has an" ',(0,t.jsx)(n.code,{children:"Engine"}),", rather than a ",(0,t.jsx)(n.code,{children:"Car"}),' "is an" ',(0,t.jsx)(n.code,{children:"Engine"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"advantages-of-composition",children:"Advantages of Composition"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Flexibility and Adaptability:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Runtime Behavior Changes:"})," Behaviors can be changed at runtime by swapping out the composed object with another object that implements the same interface. This is a core idea behind strategies and dependency injection."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Multiple Behaviors:"})," A class can compose multiple different objects, effectively achieving multiple behaviors without the limitations of single inheritance."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Loose Coupling:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reduced Dependencies:"})," The composing class interacts with the composed object through its interface, not its implementation details. This reduces the dependency between classes."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Encapsulation:"})," The internal implementation of the composed object is hidden from the composing class, promoting better encapsulation."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Easier Testing:"})," Because components are less coupled, they are generally easier to test in isolation."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Better Code Reusability:"})," Individual components (the composed objects) can be reused across different contexts by being composed into various classes."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Better Follows Real-World Relationships:"}),' Often, real-world relationships are "has-a" (composition) rather than "is-a" (inheritance).']}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"disadvantages-of-composition",children:"Disadvantages of Composition"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Increased Number of Objects:"})," You might end up with more objects and classes compared to a pure inheritance hierarchy, which could seem more complex initially."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Delegation Overhead:"}),' You often need to write "delegation" code \u2013 methods in the composing class that simply call methods on the composed object. This can sometimes feel like boilerplate, though IDEs and sometimes language features can help.']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Interface Dependency:"})," The effectiveness of composition relies heavily on well-defined interfaces for the composed objects."]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"illustrative-example-a-car-and-its-engine",children:["Illustrative Example: A ",(0,t.jsx)(n.code,{children:"Car"})," and its ",(0,t.jsx)(n.code,{children:"Engine"})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Using Inheritance (Less Ideal for this scenario):"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Not a good design for typical car/engine relationship\r\nclass Engine {\r\n    public void start() {\r\n        System.out.println("Engine starts.");\r\n    }\r\n    public void stop() {\r\n        System.out.println("Engine stops.");\r\n    }\r\n}\r\n\r\nclass Car extends Engine { // Problem: A Car "is an" Engine, which isn\'t true\r\n    public void drive() {\r\n        start(); // Inherited method\r\n        System.out.println("Car is driving.");\r\n    }\r\n}\r\n\r\n// Problem: What if we want to change the Car\'s engine type at runtime? \r\n// Or have different engine types like ElectricEngine, PetrolEngine?\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Using Composition (Preferred):"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Define an interface for the behavior we need\r\ninterface Startable {\r\n    void start();\r\n    void stop();\r\n}\r\n\r\n// Concrete implementations of the behavior\r\nclass PetrolEngine implements Startable {\r\n    @Override\r\n    public void start() {\r\n        System.out.println("Petrol engine starts with a roar.");\r\n    }\r\n    @Override\r\n    public void stop() {\r\n        System.out.println("Petrol engine stops.");\r\n    }\r\n}\r\n\r\nclass ElectricEngine implements Startable {\r\n    @Override\r\n    public void start() {\r\n        System.out.println("Electric engine hums to life.");\r\n    }\r\n    @Override\r\n    public void stop() {\r\n        System.out.println("Electric engine powers down silently.");\r\n    }\r\n}\r\n\r\n// The Car class composes an Engine (or any Startable)\r\nclass Car {\r\n    private Startable engine; // Car "has a" Startable (interface type)\r\n\r\n    // Constructor injection: engine is provided from outside\r\n    public Car(Startable engine) {\r\n        this.engine = engine;\r\n    }\r\n\r\n    // Setter injection: allow changing engine at runtime\r\n    public void setEngine(Startable engine) {\r\n        this.engine = engine;\r\n    }\r\n\r\n    public void drive() {\r\n        if (engine != null) {\r\n            engine.start(); // Delegate to the composed object\r\n            System.out.println("Car is driving.");\r\n        } else {\r\n            System.out.println("No engine to drive the car.");\r\n        }\r\n    }\r\n\r\n    public void stopDriving() {\r\n        if (engine != null) {\r\n            engine.stop(); // Delegate to the composed object\r\n            System.out.println("Car has stopped.");\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        Car petrolCar = new Car(new PetrolEngine());\r\n        petrolCar.drive();\r\n        petrolCar.stopDriving();\r\n\r\n        System.out.println("--- Swapping Engine ---");\r\n\r\n        Car electricCar = new Car(new ElectricEngine());\r\n        electricCar.drive();\r\n        electricCar.stopDriving();\r\n        \r\n        // Example of changing engine at runtime (if allowed by design)\r\n        petrolCar.setEngine(new ElectricEngine());\r\n        petrolCar.drive(); \r\n    }\r\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["In the composition example, the ",(0,t.jsx)(n.code,{children:"Car"})," class doesn't inherit from ",(0,t.jsx)(n.code,{children:"Engine"}),". Instead, it contains an instance of an object that implements the ",(0,t.jsx)(n.code,{children:"Startable"})," interface. This allows us to easily swap out different types of engines (e.g., ",(0,t.jsx)(n.code,{children:"PetrolEngine"}),", ",(0,t.jsx)(n.code,{children:"ElectricEngine"}),") without changing the ",(0,t.jsx)(n.code,{children:"Car"})," class itself, achieving greater flexibility."]}),"\n",(0,t.jsx)(n.h3,{id:"when-to-choose-which",children:"When to Choose Which"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Choose Inheritance when:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:['There is a clear and undeniable "is-a" relationship (e.g., a ',(0,t.jsx)(n.code,{children:"Dog"})," ",(0,t.jsx)(n.code,{children:"is-a"})," ",(0,t.jsx)(n.code,{children:"Animal"}),")."]}),"\n",(0,t.jsx)(n.li,{children:"You want to reuse a common implementation and extend it."}),"\n",(0,t.jsx)(n.li,{children:"The base class and subclasses are tightly coupled and form a single, cohesive unit."}),"\n",(0,t.jsx)(n.li,{children:"You want to leverage polymorphism where subclasses are directly substitutable for the superclass (LSP holds true)."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Choose Composition when:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:['There is a "has-a" relationship (e.g., a ',(0,t.jsx)(n.code,{children:"Car"})," ",(0,t.jsx)(n.code,{children:"has-an"})," ",(0,t.jsx)(n.code,{children:"Engine"}),")."]}),"\n",(0,t.jsx)(n.li,{children:"You want to achieve flexibility and the ability to change behavior at runtime."}),"\n",(0,t.jsx)(n.li,{children:"You want to reduce coupling between classes."}),"\n",(0,t.jsx)(n.li,{children:"You need to reuse behavior from multiple, unrelated sources."}),"\n",(0,t.jsx)(n.li,{children:"The behavior you need is independent of the class hierarchy."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:'In modern OOP design, "Composition over Inheritance" is generally favored as it leads to more flexible, maintainable, and robust systems. Inheritance should be used judiciously, typically for creating well-defined hierarchies where the "is-a" relationship holds strong and the benefits of shared implementation outweigh the potential for tight coupling.'})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);