"use strict";(self.webpackChunkmydevdocs=self.webpackChunkmydevdocs||[]).push([[8092],{4518:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"java/Core/OOP/immutability","title":"Immutability - final and Defensive Copies","description":"Immutability is a core concept in object-oriented programming, particularly important in Java, which refers to the state of an object remaining unchanged after it has been created. An immutable object is one whose internal state cannot be modified once it has been fully constructed.","source":"@site/docs/java/1-Core/1-OOP/6-immutability.md","sourceDirName":"java/1-Core/1-OOP","slug":"/java/Core/OOP/immutability","permalink":"/dev/docs/java/Core/OOP/immutability","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"java","permalink":"/dev/docs/tags/java"},{"inline":true,"label":"immutability","permalink":"/dev/docs/tags/immutability"},{"inline":true,"label":"final","permalink":"/dev/docs/tags/final"},{"inline":true,"label":"defensive copies","permalink":"/dev/docs/tags/defensive-copies"},{"inline":true,"label":"thread safety","permalink":"/dev/docs/tags/thread-safety"},{"inline":true,"label":"defensive programming","permalink":"/dev/docs/tags/defensive-programming"}],"version":"current","sidebarPosition":6,"frontMatter":{"title":"Immutability - final and Defensive Copies","sidebar_position":6,"tags":["java","immutability","final","defensive copies","thread safety","defensive programming"]},"sidebar":"tutorialSidebar","previous":{"title":"Object Equality - equals() and hashCode()","permalink":"/dev/docs/java/Core/OOP/object-equality"},"next":{"title":"Access Modifiers & Visibility","permalink":"/dev/docs/java/Core/OOP/access-modifiers-visibility"}}');var r=n(4848),a=n(8453);const s={title:"Immutability - final and Defensive Copies",sidebar_position:6,tags:["java","immutability","final","defensive copies","thread safety","defensive programming"]},o=void 0,l={},c=[{value:"What is an Immutable Object?",id:"what-is-an-immutable-object",level:3},{value:"Why Immutability? (Benefits)",id:"why-immutability-benefits",level:3},{value:"How to Achieve Immutability",id:"how-to-achieve-immutability",level:3},{value:"Defensive Copies Explained",id:"defensive-copies-explained",level:3},{value:"Considerations and Trade-offs",id:"considerations-and-trade-offs",level:3}];function d(e){const t={code:"code",em:"em",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:"Immutability is a core concept in object-oriented programming, particularly important in Java, which refers to the state of an object remaining unchanged after it has been created. An immutable object is one whose internal state cannot be modified once it has been fully constructed."}),"\n",(0,r.jsx)(t.h3,{id:"what-is-an-immutable-object",children:"What is an Immutable Object?"}),"\n",(0,r.jsxs)(t.p,{children:["An object is considered immutable if its state cannot be modified after it's created. Once constructed, its field values remain constant for its entire lifetime. Examples of immutable classes in the Java standard library include ",(0,r.jsx)(t.code,{children:"String"}),", ",(0,r.jsx)(t.code,{children:"Integer"}),", ",(0,r.jsx)(t.code,{children:"Long"}),", ",(0,r.jsx)(t.code,{children:"Float"}),", ",(0,r.jsx)(t.code,{children:"Double"}),", and ",(0,r.jsx)(t.code,{children:"BigDecimal"}),"."]}),"\n",(0,r.jsx)(t.h3,{id:"why-immutability-benefits",children:"Why Immutability? (Benefits)"}),"\n",(0,r.jsx)(t.p,{children:"Immutability offers significant advantages in software development:"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Thread Safety:"})," Immutable objects are inherently thread-safe. Since their state cannot change, multiple threads can access them concurrently without the need for synchronization mechanisms (like locks), eliminating issues like race conditions or deadlocks. This simplifies concurrent programming significantly."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Simplicity and Predictability:"})," The state of an immutable object is fixed. This makes code easier to reason about, understand, and debug, as you don't have to worry about unexpected changes from other parts of the program."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Safer Sharing:"})," Immutable objects can be freely shared among different parts of an application without fear of one part corrupting the object's state for another. This is especially useful in multi-threaded environments."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Caching and Hashing:"})," Immutable objects are excellent candidates for keys in ",(0,r.jsx)(t.code,{children:"HashMap"})," or elements in ",(0,r.jsx)(t.code,{children:"HashSet"})," because their hash code (if calculated correctly) remains constant. They can also be easily cached."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Reduced Side Effects:"})," Functions or methods that operate on immutable objects cannot produce side effects on those objects. This leads to more predictable and testable code."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Security:"})," Immutable objects can be safer in terms of security, as their state cannot be tampered with after creation."]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"how-to-achieve-immutability",children:"How to Achieve Immutability"}),"\n",(0,r.jsx)(t.p,{children:"To create an immutable class in Java, you must follow a set of strict rules:"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsxs)(t.strong,{children:["Declare the class as ",(0,r.jsx)(t.code,{children:"final"}),":"]})," This prevents other classes from extending it and potentially overriding methods or modifying its state in a mutable way."]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.em,{children:"Alternative:"})," If you want to allow subclassing, you can make the constructor ",(0,r.jsx)(t.code,{children:"private"})," and provide static factory methods, or simply ensure all methods that could expose mutable state are handled correctly (less common for true immutability)."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:(0,r.jsxs)(t.strong,{children:["Declare all fields as ",(0,r.jsx)(t.code,{children:"private"})," and ",(0,r.jsx)(t.code,{children:"final"}),":"]})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"private"}),": Ensures that fields cannot be accessed or modified directly from outside the class."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"final"}),": Ensures that the field's value (or the object it refers to) is assigned only once during object construction and cannot be reassigned later."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsxs)(t.strong,{children:["Don't provide any ",(0,r.jsx)(t.code,{children:"setter"})," methods:"]})," There should be no methods that allow modification of the object's state after construction."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Initialize all fields via the constructor:"})," The constructor must fully initialize all ",(0,r.jsx)(t.code,{children:"final"})," fields."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Handle mutable object references carefully (Defensive Copies):"})," This is the most crucial and often overlooked rule. If your immutable class contains fields that are references to mutable objects (e.g., ",(0,r.jsx)(t.code,{children:"Date"}),", ",(0,r.jsx)(t.code,{children:"ArrayList"}),", custom mutable objects), you must perform ",(0,r.jsx)(t.strong,{children:"defensive copying"}),"."]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"For incoming arguments in the constructor:"})," Create a new copy of any mutable object passed into the constructor. Do not store the direct reference to the external mutable object. This prevents external code from modifying the state of your immutable object after construction."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"For outgoing references in getter methods:"})," Return a new copy of any mutable object that is part of your immutable object's state. Do not return the direct reference to the internal mutable object. This prevents external code from getting a reference to your internal state and modifying it."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"defensive-copies-explained",children:"Defensive Copies Explained"}),"\n",(0,r.jsx)(t.p,{children:'Defensive copies are essential to prevent "aliasing" issues where a reference to a mutable object is shared, allowing external code to change the internal state of your supposedly immutable object.'}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Example (Violation vs. Adherence):"})}),"\n",(0,r.jsxs)(t.p,{children:["Let's say we want to create an immutable ",(0,r.jsx)(t.code,{children:"Period"})," class with a ",(0,r.jsx)(t.code,{children:"startDate"})," and ",(0,r.jsx)(t.code,{children:"endDate"}),"."]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Violation (Without Defensive Copies):"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"import java.util.Date; // Date is a mutable class\r\n\r\npublic final class MutablePeriod {\r\n    private final Date startDate;\r\n    private final Date endDate;\r\n\r\n    public MutablePeriod(Date startDate, Date endDate) {\r\n        this.startDate = startDate; // Stores direct reference\r\n        this.endDate = endDate;     // Stores direct reference\r\n    }\r\n\r\n    public Date getStartDate() {\r\n        return startDate; // Returns direct reference\r\n    }\r\n\r\n    public Date getEndDate() {\r\n        return endDate; // Returns direct reference\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return startDate + \" - \" + endDate;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        Date start = new Date();\r\n        Date end = new Date();\r\n        MutablePeriod period = new MutablePeriod(start, end);\r\n\r\n        System.out.println(\"Original period: \" + period); // Prints dates\r\n\r\n        // External modification of the original Date objects:\r\n        start.setYear(1900); // Modifies the 'start' object\r\n        end.setYear(2500);   // Modifies the 'end' object\r\n\r\n        System.out.println(\"Modified period: \" + period); // Period object's internal state has changed!\r\n                                                       // Even though it's 'final' and has no setters.\r\n    }\r\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Adherence (With Defensive Copies):"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:'import java.util.Date; // Date is a mutable class\r\n\r\npublic final class ImmutablePeriod { // Class is final\r\n    private final Date startDate; // Fields are private and final\r\n    private final Date endDate;\r\n\r\n    public ImmutablePeriod(Date startDate, Date endDate) {\r\n        // Defensive copy for incoming mutable arguments:\r\n        // Create new Date objects to store internal state,\r\n        // so external Date objects cannot modify this object\'s state.\r\n        this.startDate = new Date(startDate.getTime());\r\n        this.endDate = new Date(endDate.getTime());\r\n\r\n        // Basic validation (optional but good practice for constructor)\r\n        if (this.startDate.compareTo(this.endDate) > 0) {\r\n            throw new IllegalArgumentException(startDate + " after " + endDate);\r\n        }\r\n    }\r\n\r\n    public Date getStartDate() {\r\n        // Defensive copy for outgoing mutable references:\r\n        // Return a new Date object, not the internal one,\r\n        // so external code cannot modify this object\'s state.\r\n        return new Date(startDate.getTime());\r\n    }\r\n\r\n    public Date getEndDate() {\r\n        // Defensive copy for outgoing mutable references:\r\n        return new Date(endDate.getTime());\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return startDate + " - " + endDate;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        Date start = new Date();\r\n        Date end = new Date();\r\n        ImmutablePeriod period = new ImmutablePeriod(start, end);\r\n\r\n        System.out.println("Original period: " + period);\r\n\r\n        // Attempt to externally modify the original Date objects:\r\n        start.setYear(1900);\r\n        end.setYear(2500);\r\n\r\n        System.out.println("Attempted modification: " + period); // Period object remains unchanged!\r\n\r\n        // Attempt to externally modify through getter:\r\n        period.getStartDate().setYear(1950);\r\n        period.getEndDate().setYear(2050);\r\n\r\n        System.out.println("Attempted modification via getter: " + period); // Period object remains unchanged!\r\n    }\r\n}\n'})}),"\n",(0,r.jsx)(t.h3,{id:"considerations-and-trade-offs",children:"Considerations and Trade-offs"}),"\n",(0,r.jsx)(t.p,{children:"While immutability offers many benefits, it's not always the best choice:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Performance Overhead:"})," Creating a new object for every modification (e.g., in a loop where a ",(0,r.jsx)(t.code,{children:"String"})," is repeatedly concatenated) can lead to increased garbage collection activity and performance overhead compared to modifying a mutable object in place. For such scenarios, mutable alternatives (like ",(0,r.jsx)(t.code,{children:"StringBuilder"}),") are often preferred."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Increased Object Creation:"})," In scenarios with frequent state changes, immutability can lead to a proliferation of objects, potentially increasing memory consumption and GC pressure."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Verbosity:"})," Sometimes, implementing immutability strictly can involve more boilerplate code, especially with complex objects containing many nested mutable fields."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Despite these trade-offs, the benefits of immutability, especially in concurrent and complex systems, often outweigh the costs. It's a powerful principle for building robust and reliable software."})]})}function m(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>o});var i=n(6540);const r={},a=i.createContext(r);function s(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);