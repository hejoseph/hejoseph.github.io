"use strict";(self.webpackChunkmydevdocs=self.webpackChunkmydevdocs||[]).push([[368],{7165:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"java/Memory/heap-stack","title":"Heap vs. Stack Memory","description":"In the context of the Java Virtual Machine (JVM) and the Java Memory Model (JMM), \\"Heap\\" and \\"Stack\\" are two fundamental memory regions with distinct purposes, characteristics, and management approaches. Understanding their differences is crucial for comprehending how Java programs execute, manage memory, and handle concurrent operations.","source":"@site/docs/java/2-Memory/1-heap-stack.md","sourceDirName":"java/2-Memory","slug":"/java/Memory/heap-stack","permalink":"/dev/docs/java/Memory/heap-stack","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"java","permalink":"/dev/docs/tags/java"},{"inline":true,"label":"jvm","permalink":"/dev/docs/tags/jvm"},{"inline":true,"label":"memory model","permalink":"/dev/docs/tags/memory-model"},{"inline":true,"label":"heap","permalink":"/dev/docs/tags/heap"},{"inline":true,"label":"stack","permalink":"/dev/docs/tags/stack"},{"inline":true,"label":"garbage collection","permalink":"/dev/docs/tags/garbage-collection"}],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Heap vs. Stack Memory","sidebar_position":1,"tags":["java","jvm","memory model","heap","stack","garbage collection"]},"sidebar":"tutorialSidebar","previous":{"title":"Garbage Collection","permalink":"/dev/docs/java/garbage-collector"},"next":{"title":"Javascript","permalink":"/dev/docs/category/javascript"}}');var r=n(4848),s=n(8453);const i={title:"Heap vs. Stack Memory",sidebar_position:1,tags:["java","jvm","memory model","heap","stack","garbage collection"]},l=void 0,o={},c=[{value:"1. The Stack (JVM Stack)",id:"1-the-stack-jvm-stack",level:3},{value:"2. The Heap",id:"2-the-heap",level:3},{value:"Key Differences Summarized",id:"key-differences-summarized",level:3},{value:"Interaction Between Stack and Heap",id:"interaction-between-stack-and-heap",level:3}];function d(e){const t={code:"code",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:'In the context of the Java Virtual Machine (JVM) and the Java Memory Model (JMM), "Heap" and "Stack" are two fundamental memory regions with distinct purposes, characteristics, and management approaches. Understanding their differences is crucial for comprehending how Java programs execute, manage memory, and handle concurrent operations.'}),"\n",(0,r.jsx)(t.h3,{id:"1-the-stack-jvm-stack",children:"1. The Stack (JVM Stack)"}),"\n",(0,r.jsx)(t.p,{children:"Each thread running in a JVM has its own private runtime stack, known as the JVM Stack. This memory area is primarily used for the execution of Java methods."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Key Characteristics:"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Thread-Specific:"})," Every thread in a Java application has its own independent stack. This makes stack operations thread-safe by nature."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Method Execution:"})," When a method is invoked, a new ",(0,r.jsx)(t.strong,{children:"frame"})," is pushed onto the stack. When the method completes, its frame is popped off the stack. This follows a Last-In, First-Out (LIFO) principle."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Contents of a Stack Frame:"})," Each frame contains:","\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Local Variables:"})," Primitive type variables (e.g., ",(0,r.jsx)(t.code,{children:"int"}),", ",(0,r.jsx)(t.code,{children:"boolean"}),", ",(0,r.jsx)(t.code,{children:"double"}),") and references to objects (but not the objects themselves)."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Operand Stack:"})," Used for intermediate calculations during expression evaluation."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Frame Data (e.g., Return Address):"})," Information needed to return control to the calling method."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Automatic Memory Management:"})," Memory on the stack is allocated and deallocated automatically by the JVM. There's no need for explicit memory management by the programmer. This makes stack operations very fast."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Limited Size:"})," Stacks typically have a relatively small, fixed, or configurable size. If a thread's stack becomes too large (e.g., due to deep recursion without a base case), a ",(0,r.jsx)(t.code,{children:"StackOverflowError"})," is thrown."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Short-Lived:"})," The data on the stack exists only for the duration of the method call. Once the method finishes, its frame and all its contents are discarded."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Example:"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"public class StackExample {\r\n    public static void main(String[] args) { // Frame for main() method\r\n        int a = 10; // 'a' is a local variable stored on the stack\r\n        String s = \"Hello\"; // 's' is a reference variable stored on the stack\r\n                             // The actual \"Hello\" String object is on the heap\r\n        \r\n        myMethod(a); // New frame for myMethod() pushed onto the stack\r\n    } // main() frame popped when method ends\r\n\r\n    public static void myMethod(int x) { // Frame for myMethod()\r\n        // 'x' is a method parameter, stored on the stack\r\n        boolean flag = true; // 'flag' is a local variable stored on the stack\r\n        \r\n        // ... some operations\r\n        \r\n    } // myMethod() frame popped when method ends\r\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"2-the-heap",children:"2. The Heap"}),"\n",(0,r.jsx)(t.p,{children:"The Heap is the largest memory area in the JVM, and it is shared by all threads. It is where all objects (instances of classes) and arrays are allocated at runtime."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Key Characteristics:"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Shared by All Threads:"})," All objects created by any thread reside on the heap and are accessible by all other threads (subject to visibility rules). This is why heap memory is where concurrency issues like race conditions often arise if not properly managed."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Dynamic Memory Allocation:"})," Objects are dynamically allocated on the heap using the ",(0,r.jsx)(t.code,{children:"new"})," keyword. The size of the object is determined at runtime."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Garbage Collection:"})," Memory on the heap is managed by the JVM's Garbage Collector (GC). When objects are no longer referenced by any part of the program, they become eligible for garbage collection, and the GC reclaims their memory. Programmers do not explicitly deallocate memory on the heap."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Larger Size:"})," The heap is typically much larger than the stack and can be configured to grow or shrink dynamically based on memory needs. If the heap runs out of memory, an ",(0,r.jsx)(t.code,{children:"OutOfMemoryError: Java heap space"})," is thrown."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Longer-Lived:"})," Objects on the heap can have a longer lifespan than stack variables. An object can persist as long as there is at least one active reference pointing to it, regardless of which method or thread created it."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Example:"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"public class HeapExample {\r\n    public static void main(String[] args) {\r\n        // 'obj1' is a reference on the stack, the actual MyObject instance is on the heap\r\n        MyObject obj1 = new MyObject(\"Instance 1\"); \r\n\r\n        // 'arr' is a reference on the stack, the actual array object is on the heap\r\n        int[] arr = new int[10];\r\n\r\n        // 'obj2' is a reference on the stack, the actual MyObject instance is on the heap\r\n        MyObject obj2 = new MyObject(\"Instance 2\"); \r\n\r\n        // obj1 and obj2 (the objects themselves) reside on the heap\r\n        // Their references (obj1, obj2, arr) reside on the stack of the main thread\r\n    }\r\n}\r\n\r\nclass MyObject {\r\n    String name;\r\n    public MyObject(String name) {\r\n        this.name = name;\r\n    }\r\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"key-differences-summarized",children:"Key Differences Summarized"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{style:{textAlign:"left"},children:"Feature"}),(0,r.jsx)(t.th,{style:{textAlign:"left"},children:"Stack"}),(0,r.jsx)(t.th,{style:{textAlign:"left"},children:"Heap"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.strong,{children:"Purpose"})}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Method execution, local variable storage."}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Object and array storage."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.strong,{children:"What it Stores"})}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Local variables (primitives), references to objects, method parameters, return addresses."}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"All objects (class instances), arrays."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.strong,{children:"Memory Mgmt."})}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Automatic (LIFO), by JVM. Fast."}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Garbage collected (GC). Slower, but automatic."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.strong,{children:"Access"})}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Thread-private."}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Shared among all threads."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.strong,{children:"Lifespan"})}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Short-lived (method call duration)."}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Long-lived (until no longer referenced and GC'd)."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.strong,{children:"Size"})}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Typically smaller, fixed or limited."}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Typically larger, can grow dynamically."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.strong,{children:"Error"})}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"StackOverflowError"})}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"OutOfMemoryError: Java heap space"})})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.strong,{children:"Performance"})}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Faster allocation/deallocation."}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Slower allocation, GC can introduce pauses."})]})]})]}),"\n",(0,r.jsx)(t.h3,{id:"interaction-between-stack-and-heap",children:"Interaction Between Stack and Heap"}),"\n",(0,r.jsx)(t.p,{children:"The stack and heap work together seamlessly. When you declare an object:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"MyClass myObject = new MyClass();\n"})}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:["The ",(0,r.jsx)(t.code,{children:"myObject"})," ",(0,r.jsx)(t.strong,{children:"reference variable"})," (which holds the memory address of the object) is stored on the ",(0,r.jsx)(t.strong,{children:"stack"})," of the currently executing thread."]}),"\n",(0,r.jsxs)(t.li,{children:["The actual ",(0,r.jsx)(t.code,{children:"MyClass()"})," ",(0,r.jsx)(t.strong,{children:"object instance"})," itself, along with its instance variables, is allocated on the ",(0,r.jsx)(t.strong,{children:"heap"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["This allows methods on the stack to manipulate objects on the heap by using their references. When the method finishes, the ",(0,r.jsx)(t.code,{children:"myObject"})," reference on the stack is popped, but the ",(0,r.jsx)(t.code,{children:"MyClass"})," object on the heap might still exist if other references to it exist elsewhere (e.g., another thread or a static field). Only when no references point to it does it become eligible for garbage collection."]}),"\n",(0,r.jsx)(t.p,{children:"In summary, the stack is about execution flow and temporary local data, while the heap is about long-term data storage for objects shared across your application."})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>l});var a=n(6540);const r={},s=a.createContext(r);function i(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);