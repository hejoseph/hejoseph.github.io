"use strict";(self.webpackChunkmydevdocs=self.webpackChunkmydevdocs||[]).push([[853],{6458:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>t,contentTitle:()=>c,default:()=>p,frontMatter:()=>a,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"java/Core/OOP/access-modifiers-visibility","title":"Access Modifiers & Visibility","description":"In Java, access modifiers are keywords that set the accessibility (visibility) of classes, constructors, methods, and fields. They are a fundamental aspect of encapsulation, an object-oriented programming principle that allows you to hide internal implementation details and control how other parts of the code can interact with your classes and their members.","source":"@site/docs/java/1-Core/1-OOP/7-access-modifiers-visibility.md","sourceDirName":"java/1-Core/1-OOP","slug":"/java/Core/OOP/access-modifiers-visibility","permalink":"/dev/docs/java/Core/OOP/access-modifiers-visibility","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"java","permalink":"/dev/docs/tags/java"},{"inline":true,"label":"oop","permalink":"/dev/docs/tags/oop"},{"inline":true,"label":"access modifiers","permalink":"/dev/docs/tags/access-modifiers"},{"inline":true,"label":"visibility","permalink":"/dev/docs/tags/visibility"},{"inline":true,"label":"encapsulation","permalink":"/dev/docs/tags/encapsulation"}],"version":"current","sidebarPosition":7,"frontMatter":{"title":"Access Modifiers & Visibility","sidebar_position":7,"tags":["java","oop","access modifiers","visibility","encapsulation"]},"sidebar":"tutorialSidebar","previous":{"title":"Immutability - final and Defensive Copies","permalink":"/dev/docs/java/Core/OOP/immutability"},"next":{"title":"Garbage Collection","permalink":"/dev/docs/java/garbage-collector"}}');var r=n(4848),l=n(8453);const a={title:"Access Modifiers & Visibility",sidebar_position:7,tags:["java","oop","access modifiers","visibility","encapsulation"]},c=void 0,t={},o=[{value:"1. <code>public</code>",id:"1-public",level:3},{value:"2. <code>protected</code>",id:"2-protected",level:3},{value:"3. <code>default</code> (Package-Private)",id:"3-default-package-private",level:3},{value:"4. <code>private</code>",id:"4-private",level:3},{value:"Summary Table",id:"summary-table",level:3},{value:"Key Takeaways",id:"key-takeaways",level:3}];function d(e){const s={code:"code",em:"em",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.p,{children:"In Java, access modifiers are keywords that set the accessibility (visibility) of classes, constructors, methods, and fields. They are a fundamental aspect of encapsulation, an object-oriented programming principle that allows you to hide internal implementation details and control how other parts of the code can interact with your classes and their members."}),"\n",(0,r.jsx)(s.p,{children:"There are four types of access modifiers in Java:"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"public"})})}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"protected"})})}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"default"})})," (or package-private)"]}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"private"})})}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"These modifiers specify who can access a member: the class itself, other classes in the same package, subclasses (even in different packages), or all classes."}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsxs)(s.h3,{id:"1-public",children:["1. ",(0,r.jsx)(s.code,{children:"public"})]}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.code,{children:"public"})," access modifier is the most permissive. When a class, method, or field is declared ",(0,r.jsx)(s.code,{children:"public"}),", it means it is accessible from ",(0,r.jsx)(s.strong,{children:"anywhere"})," in the application."]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Classes:"})," A ",(0,r.jsx)(s.code,{children:"public"})," class can be accessed by any other class."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Methods/Fields/Constructors:"})," ",(0,r.jsx)(s.code,{children:"public"})," members can be accessed from any class, regardless of the package."]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Visibility:"})," Accessible everywhere."]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-java",children:'// package com.example.model\r\npackage com.example.model;\r\n\r\npublic class PublicClass { // Public class\r\n    public int publicField = 10; // Public field\r\n\r\n    public PublicClass() { // Public constructor\r\n        System.out.println("PublicClass constructor called.");\r\n    }\r\n\r\n    public void publicMethod() { // Public method\r\n        System.out.println("This is a public method.");\r\n    }\r\n}\r\n\r\n// package com.example.app\r\npackage com.example.app;\r\n\r\nimport com.example.model.PublicClass;\r\n\r\npublic class AccessPublic {\r\n    public static void main(String[] args) {\r\n        PublicClass obj = new PublicClass(); // Accessible\r\n        System.out.println(obj.publicField); // Accessible\r\n        obj.publicMethod(); // Accessible\r\n    }\r\n}\n'})}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsxs)(s.h3,{id:"2-protected",children:["2. ",(0,r.jsx)(s.code,{children:"protected"})]}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.code,{children:"protected"})," access modifier allows members to be accessed within:"]}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsx)(s.li,{children:"The same class."}),"\n",(0,r.jsx)(s.li,{children:"Classes in the same package."}),"\n",(0,r.jsxs)(s.li,{children:["Subclasses (children classes) in ",(0,r.jsx)(s.em,{children:"any"})," package."]}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"It's primarily used when you want to allow subclasses to access a member, but prevent unrelated classes from doing so."}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Visibility:"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Within the same class."}),"\n",(0,r.jsx)(s.li,{children:"Within the same package."}),"\n",(0,r.jsx)(s.li,{children:"By subclasses (even if in a different package)."}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-java",children:'// package com.example.model\r\npackage com.example.model;\r\n\r\npublic class Vehicle {\r\n    protected String type = "Generic Vehicle";\r\n\r\n    protected void startEngine() {\r\n        System.out.println("Engine started for " + type);\r\n    }\r\n}\r\n\r\n// package com.example.model (same package)\r\npackage com.example.model;\r\n\r\nclass Garage {\r\n    public void testVehicle() {\r\n        Vehicle car = new Vehicle();\r\n        car.startEngine(); // Accessible, same package\r\n        System.out.println(car.type); // Accessible, same package\r\n    }\r\n}\r\n\r\n// package com.example.app (different package, subclass)\r\npackage com.example.app;\r\n\r\nimport com.example.model.Vehicle; // Import needed for subclassing\r\n\r\npublic class Car extends Vehicle { // Car is a subclass of Vehicle\r\n    public Car() {\r\n        this.type = "Car"; // Accessible, as Car is a subclass\r\n    }\r\n\r\n    public void drive() {\r\n        startEngine(); // Accessible, as Car is a subclass\r\n        System.out.println(type + " is driving.");\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        Car myCar = new Car();\r\n        myCar.drive(); // Output: Engine started for Car, Car is driving.\r\n    }\r\n}\r\n\r\n// package com.example.app (different package, NOT a subclass)\r\npackage com.example.app;\r\n\r\n// import com.example.model.Vehicle; // Uncomment if needed\r\n\r\npublic class Mechanic {\r\n    public static void main(String[] args) {\r\n        // Vehicle someVehicle = new Vehicle(); // Might need import\r\n        // someVehicle.startEngine(); // COMPILE ERROR: Cannot access protected member outside package unless subclass\r\n        // System.out.println(someVehicle.type); // COMPILE ERROR\r\n    }\r\n}\n'})}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsxs)(s.h3,{id:"3-default-package-private",children:["3. ",(0,r.jsx)(s.code,{children:"default"})," (Package-Private)"]}),"\n",(0,r.jsxs)(s.p,{children:["When no access modifier is explicitly specified for a class, method, or field, it gets the ",(0,r.jsx)(s.code,{children:"default"}),' access level. This is also known as "package-private" access.']}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"default"})," members are accessible only within:"]}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsx)(s.li,{children:"The same class."}),"\n",(0,r.jsxs)(s.li,{children:["Other classes within the ",(0,r.jsx)(s.strong,{children:"same package"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["They are ",(0,r.jsx)(s.strong,{children:"not"})," accessible by subclasses in different packages."]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Visibility:"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Within the same class."}),"\n",(0,r.jsx)(s.li,{children:"Within the same package."}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-java",children:'// package com.example.data\r\npackage com.example.data;\r\n\r\nclass UserProfile { // Default access class (only accessible within com.example.data)\r\n    String userName = "Guest"; // Default access field\r\n\r\n    void displayProfile() { // Default access method\r\n        System.out.println("User: " + userName);\r\n    }\r\n}\r\n\r\n// package com.example.data (same package)\r\npackage com.example.data;\r\n\r\npublic class ProfileManager {\r\n    public void showUserProfile() {\r\n        UserProfile user = new UserProfile(); // Accessible (same package)\r\n        System.out.println("Manager accessing: " + user.userName); // Accessible\r\n        user.displayProfile(); // Accessible\r\n    }\r\n}\r\n\r\n// package com.example.app (different package)\r\npackage com.example.app;\r\n\r\n// import com.example.data.UserProfile; // COMPILE ERROR: UserProfile is not public in com.example.data; cannot be accessed from outside package\r\n\r\npublic class MainApp {\r\n    public static void main(String[] args) {\r\n        // UserProfile user = new UserProfile(); // COMPILE ERROR (UserProfile is default access)\r\n        // new com.example.data.UserProfile(); // COMPILE ERROR (even with fully qualified name)\r\n\r\n        // However, if ProfileManager (public) exposes UserProfile, it\'s fine for public members\r\n        // ProfileManager manager = new ProfileManager();\r\n        // manager.showUserProfile(); // This would work if ProfileManager were imported and public\r\n    }\r\n}\n'})}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsxs)(s.h3,{id:"4-private",children:["4. ",(0,r.jsx)(s.code,{children:"private"})]}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.code,{children:"private"})," access modifier is the most restrictive. ",(0,r.jsx)(s.code,{children:"private"})," members (fields, methods, constructors) are accessible only from within the ",(0,r.jsx)(s.strong,{children:"same class"})," in which they are declared."]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"private"})," classes are not directly supported (except for nested classes)."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"private"})," is fundamental for encapsulation, allowing classes to hide their internal state and implementation details from the outside world."]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Visibility:"})," Accessible only within the same class."]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-java",children:'// package com.example.core\r\npackage com.example.core;\r\n\r\npublic class BankAccount {\r\n    private double balance; // Private field\r\n\r\n    public BankAccount(double initialBalance) { // Public constructor for external access\r\n        this.balance = initialBalance;\r\n    }\r\n\r\n    private void logTransaction(String message) { // Private method\r\n        System.out.println("Transaction Log: " + message);\r\n    }\r\n\r\n    public void deposit(double amount) { // Public method to interact with balance\r\n        if (amount > 0) {\r\n            this.balance += amount;\r\n            logTransaction("Deposited " + amount + ". New balance: " + balance); // Accessible within class\r\n        }\r\n    }\r\n\r\n    public double getBalance() { // Public getter\r\n        return balance;\r\n    }\r\n}\r\n\r\n// package com.example.app\r\npackage com.example.app;\r\n\r\nimport com.example.core.BankAccount;\r\n\r\npublic class BankingApp {\r\n    public static void main(String[] args) {\r\n        BankAccount myAccount = new BankAccount(1000.0);\r\n        myAccount.deposit(500.0); // Accessible\r\n\r\n        System.out.println("Current balance: " + myAccount.getBalance()); // Accessible\r\n\r\n        // myAccount.balance = 2000.0; // COMPILE ERROR: balance has private access\r\n        // myAccount.logTransaction("Unauthorized access"); // COMPILE ERROR: logTransaction has private access\r\n    }\r\n}\n'})}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h3,{id:"summary-table",children:"Summary Table"}),"\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{style:{textAlign:"left"},children:"Modifier"}),(0,r.jsx)(s.th,{style:{textAlign:"left"},children:"Same Class"}),(0,r.jsx)(s.th,{style:{textAlign:"left"},children:"Same Package"}),(0,r.jsx)(s.th,{style:{textAlign:"left"},children:"Subclass (different package)"}),(0,r.jsx)(s.th,{style:{textAlign:"left"},children:"Anywhere (different package, not subclass)"})]})}),(0,r.jsxs)(s.tbody,{children:[(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{style:{textAlign:"left"},children:(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"private"})})}),(0,r.jsx)(s.td,{style:{textAlign:"left"},children:"Yes"}),(0,r.jsx)(s.td,{style:{textAlign:"left"},children:"No"}),(0,r.jsx)(s.td,{style:{textAlign:"left"},children:"No"}),(0,r.jsx)(s.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{style:{textAlign:"left"},children:(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"default"})})}),(0,r.jsx)(s.td,{style:{textAlign:"left"},children:"Yes"}),(0,r.jsx)(s.td,{style:{textAlign:"left"},children:"Yes"}),(0,r.jsx)(s.td,{style:{textAlign:"left"},children:"No"}),(0,r.jsx)(s.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{style:{textAlign:"left"},children:(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"protected"})})}),(0,r.jsx)(s.td,{style:{textAlign:"left"},children:"Yes"}),(0,r.jsx)(s.td,{style:{textAlign:"left"},children:"Yes"}),(0,r.jsx)(s.td,{style:{textAlign:"left"},children:"Yes"}),(0,r.jsx)(s.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{style:{textAlign:"left"},children:(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"public"})})}),(0,r.jsx)(s.td,{style:{textAlign:"left"},children:"Yes"}),(0,r.jsx)(s.td,{style:{textAlign:"left"},children:"Yes"}),(0,r.jsx)(s.td,{style:{textAlign:"left"},children:"Yes"}),(0,r.jsx)(s.td,{style:{textAlign:"left"},children:"Yes"})]})]})]}),"\n",(0,r.jsx)(s.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Encapsulation:"})," Access modifiers are crucial for enforcing encapsulation. They allow you to hide the internal workings of a class, exposing only what is necessary, which makes code more maintainable and less prone to errors."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"API Design:"})," When designing APIs, you typically expose ",(0,r.jsx)(s.code,{children:"public"})," methods and classes that define the public contract of your component, while keeping internal state and helper methods ",(0,r.jsx)(s.code,{children:"private"})," or ",(0,r.jsx)(s.code,{children:"protected"}),"."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Flexibility vs. Control:"})," Each modifier offers a different balance between flexibility (how widely accessible a member is) and control (how much you restrict its usage)."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Class Level Access:"})," Top-level classes can only be ",(0,r.jsx)(s.code,{children:"public"})," or ",(0,r.jsx)(s.code,{children:"default"}),". Inner/nested classes can use all four access modifiers."]}),"\n"]})]})}function p(e={}){const{wrapper:s}={...(0,l.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>a,x:()=>c});var i=n(6540);const r={},l=i.createContext(r);function a(e){const s=i.useContext(l);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(l.Provider,{value:s},e.children)}}}]);