"use strict";(self.webpackChunkmydevdocs=self.webpackChunkmydevdocs||[]).push([[3335],{5692:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"java/Core/OOP/object-equality","title":"Object Equality - equals() and hashCode()","description":"In Java, determining whether two objects are \\"equal\\" is a fundamental concept, especially when working with collections. Java provides two methods in the Object class that are crucial for defining and managing object equality: equals() and hashCode(). Understanding their contract and how to override them correctly is vital for robust applications.","source":"@site/docs/java/1-Core/1-OOP/5-object-equality.md","sourceDirName":"java/1-Core/1-OOP","slug":"/java/Core/OOP/object-equality","permalink":"/dev/docs/java/Core/OOP/object-equality","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"java","permalink":"/dev/docs/tags/java"},{"inline":true,"label":"oop","permalink":"/dev/docs/tags/oop"},{"inline":true,"label":"object equality","permalink":"/dev/docs/tags/object-equality"},{"inline":true,"label":"collections","permalink":"/dev/docs/tags/collections"},{"inline":true,"label":"equals","permalink":"/dev/docs/tags/equals"},{"inline":true,"label":"hashCode","permalink":"/dev/docs/tags/hash-code"}],"version":"current","sidebarPosition":5,"frontMatter":{"title":"Object Equality - equals() and hashCode()","sidebar_position":5,"tags":["java","oop","object equality","collections","equals","hashCode"]},"sidebar":"tutorialSidebar","previous":{"title":"SOLID Principles","permalink":"/dev/docs/java/Core/OOP/solid-principles"},"next":{"title":"Immutability - final and Defensive Copies","permalink":"/dev/docs/java/Core/OOP/immutability"}}');var t=n(4848),o=n(8453);const r={title:"Object Equality - equals() and hashCode()",sidebar_position:5,tags:["java","oop","object equality","collections","equals","hashCode"]},c=void 0,l={},a=[{value:"1. The <code>equals()</code> Method",id:"1-the-equals-method",level:3},{value:"2. The <code>hashCode()</code> Method",id:"2-the-hashcode-method",level:3},{value:"Best Practices",id:"best-practices",level:3}];function d(e){const s={code:"code",em:"em",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(s.p,{children:['In Java, determining whether two objects are "equal" is a fundamental concept, especially when working with collections. Java provides two methods in the ',(0,t.jsx)(s.code,{children:"Object"})," class that are crucial for defining and managing object equality: ",(0,t.jsx)(s.code,{children:"equals()"})," and ",(0,t.jsx)(s.code,{children:"hashCode()"}),". Understanding their contract and how to override them correctly is vital for robust applications."]}),"\n",(0,t.jsxs)(s.h3,{id:"1-the-equals-method",children:["1. The ",(0,t.jsx)(s.code,{children:"equals()"})," Method"]}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"equals()"})," method is used to determine if two objects are logically equal, based on their content rather than their memory address."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsxs)(s.strong,{children:["Default Implementation (",(0,t.jsx)(s.code,{children:"Object.equals(Object obj)"}),"):"]}),"\r\nThe default implementation of ",(0,t.jsx)(s.code,{children:"equals()"})," in the ",(0,t.jsx)(s.code,{children:"Object"})," class simply compares the memory addresses of the two objects, meaning ",(0,t.jsx)(s.code,{children:"obj1.equals(obj2)"})," is equivalent to ",(0,t.jsx)(s.code,{children:"obj1 == obj2"}),". It returns ",(0,t.jsx)(s.code,{children:"true"})," only if both object references point to the exact same object in memory."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-java",children:"public boolean equals(Object obj) {\r\n    return (this == obj); // Checks for reference equality\r\n}\n"})}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsxs)(s.strong,{children:["Why Override ",(0,t.jsx)(s.code,{children:"equals()"}),"?"]}),"\r\nFor most custom classes, you'll want to define equality based on the ",(0,t.jsx)(s.em,{children:"state"})," (the values of their fields) of the objects, not just whether they are the same instance. For example, two ",(0,t.jsx)(s.code,{children:"Person"})," objects might be considered equal if they have the same ",(0,t.jsx)(s.code,{children:"id"})," and ",(0,t.jsx)(s.code,{children:"name"}),", even if they are distinct objects in memory."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsxs)(s.strong,{children:["Contract of ",(0,t.jsx)(s.code,{children:"equals()"})," (as specified in ",(0,t.jsx)(s.code,{children:"java.lang.Object"}),"):"]}),"\r\nWhen overriding ",(0,t.jsx)(s.code,{children:"equals()"}),", you ",(0,t.jsx)(s.em,{children:"must"})," adhere to these five properties for it to behave correctly and predictably, especially when used in collections:"]}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Reflexive:"})," For any non-null reference value ",(0,t.jsx)(s.code,{children:"x"}),", ",(0,t.jsx)(s.code,{children:"x.equals(x)"})," must return ",(0,t.jsx)(s.code,{children:"true"}),". (An object must be equal to itself)."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Symmetric:"})," For any non-null reference values ",(0,t.jsx)(s.code,{children:"x"})," and ",(0,t.jsx)(s.code,{children:"y"}),", ",(0,t.jsx)(s.code,{children:"x.equals(y)"})," must return ",(0,t.jsx)(s.code,{children:"true"})," if and only if ",(0,t.jsx)(s.code,{children:"y.equals(x)"})," returns ",(0,t.jsx)(s.code,{children:"true"}),". (If A is equal to B, then B must be equal to A)."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Transitive:"})," For any non-null reference values ",(0,t.jsx)(s.code,{children:"x"}),", ",(0,t.jsx)(s.code,{children:"y"}),", and ",(0,t.jsx)(s.code,{children:"z"}),", if ",(0,t.jsx)(s.code,{children:"x.equals(y)"})," returns ",(0,t.jsx)(s.code,{children:"true"})," and ",(0,t.jsx)(s.code,{children:"y.equals(z)"})," returns ",(0,t.jsx)(s.code,{children:"true"}),", then ",(0,t.jsx)(s.code,{children:"x.equals(z)"})," must return ",(0,t.jsx)(s.code,{children:"true"}),". (If A is equal to B, and B is equal to C, then A must be equal to C)."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Consistent:"})," For any non-null reference values ",(0,t.jsx)(s.code,{children:"x"})," and ",(0,t.jsx)(s.code,{children:"y"}),", multiple invocations of ",(0,t.jsx)(s.code,{children:"x.equals(y)"})," must consistently return ",(0,t.jsx)(s.code,{children:"true"})," or consistently return ",(0,t.jsx)(s.code,{children:"false"}),", provided no information used in ",(0,t.jsx)(s.code,{children:"equals"})," comparisons on the objects is modified. (Equality does not change unless the object's state changes)."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Null Handling:"})," For any non-null reference value ",(0,t.jsx)(s.code,{children:"x"}),", ",(0,t.jsx)(s.code,{children:"x.equals(null)"})," must return ",(0,t.jsx)(s.code,{children:"false"}),". (An object is never equal to ",(0,t.jsx)(s.code,{children:"null"}),")."]}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsxs)(s.strong,{children:["Typical ",(0,t.jsx)(s.code,{children:"equals()"})," Implementation Pattern:"]})}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-java",children:"public class MyClass {\r\n    private int id;\r\n    private String name;\r\n\r\n    public MyClass(int id, String name) {\r\n        this.id = id;\r\n        this.name = name;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object o) {\r\n        // 1. Check for reference equality (optimization)\r\n        if (this == o) return true;\r\n        // 2. Check for null and class type\r\n        if (o == null || getClass() != o.getClass()) return false;\r\n        // Or if using instanceof for polymorphism (be cautious with LSP and symmetry):\r\n        // if (!(o instanceof MyClass)) return false;\r\n\r\n        // 3. Cast the object to the current class type\r\n        MyClass myClass = (MyClass) o;\r\n\r\n        // 4. Compare relevant fields\r\n        if (id != myClass.id) return false;\r\n        return name != null ? name.equals(myClass.name) : myClass.name == null;\r\n    }\r\n\r\n    // ... getters, setters, etc.\r\n}\n"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsxs)(s.strong,{children:["Common Pitfalls with ",(0,t.jsx)(s.code,{children:"equals()"}),":"]})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsxs)(s.strong,{children:["Violating Symmetry (e.g., with ",(0,t.jsx)(s.code,{children:"instanceof"})," and inheritance):"]})," If ",(0,t.jsx)(s.code,{children:"A.equals(B)"})," is true, ",(0,t.jsx)(s.code,{children:"B.equals(A)"})," must be true. Using ",(0,t.jsx)(s.code,{children:"instanceof"})," for type checking can sometimes violate symmetry if subclasses are involved (e.g., ",(0,t.jsx)(s.code,{children:"ColorPoint"})," extends ",(0,t.jsx)(s.code,{children:"Point"})," and ",(0,t.jsx)(s.code,{children:"equals"})," checks ",(0,t.jsx)(s.code,{children:"instanceof Point"}),"). It's generally safer to use ",(0,t.jsx)(s.code,{children:"getClass() != o.getClass()"}),"."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsxs)(s.strong,{children:["Forgetting to override ",(0,t.jsx)(s.code,{children:"hashCode()"}),":"]})," This is the most critical pitfall, leading to incorrect behavior in hash-based collections."]}),"\n"]}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsxs)(s.h3,{id:"2-the-hashcode-method",children:["2. The ",(0,t.jsx)(s.code,{children:"hashCode()"})," Method"]}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"hashCode()"})," method returns an integer hash code value for the object. This hash code is primarily used by hash-based collections (like ",(0,t.jsx)(s.code,{children:"HashMap"}),", ",(0,t.jsx)(s.code,{children:"HashSet"}),", ",(0,t.jsx)(s.code,{children:"Hashtable"}),") to determine where to store and look up objects efficiently."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsxs)(s.strong,{children:["Default Implementation (",(0,t.jsx)(s.code,{children:"Object.hashCode()"}),"):"]}),"\r\nThe default implementation of ",(0,t.jsx)(s.code,{children:"hashCode()"})," in ",(0,t.jsx)(s.code,{children:"Object"})," typically returns a distinct integer for distinct objects. It's often the memory address of the object converted to an integer, or some other unique identifier based on the object's internal representation."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsxs)(s.strong,{children:["Why Override ",(0,t.jsx)(s.code,{children:"hashCode()"}),"?"]}),"\r\nIf you override ",(0,t.jsx)(s.code,{children:"equals()"}),", you ",(0,t.jsx)(s.em,{children:"must"})," override ",(0,t.jsx)(s.code,{children:"hashCode()"})," as well to maintain the general contract for ",(0,t.jsx)(s.code,{children:"Object.hashCode()"}),"."]}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsxs)(s.strong,{children:["Contract of ",(0,t.jsx)(s.code,{children:"hashCode()"})," (as specified in ",(0,t.jsx)(s.code,{children:"java.lang.Object"}),"):"]})}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Consistency:"})," Whenever it is invoked on the same object more than once during an execution of a Java application, the ",(0,t.jsx)(s.code,{children:"hashCode"})," method must consistently return the same integer, provided no information used in ",(0,t.jsx)(s.code,{children:"equals"})," comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Equality Implies Equality of Hash Codes:"})," If two objects are equal according to the ",(0,t.jsx)(s.code,{children:"equals(Object)"})," method, then calling the ",(0,t.jsx)(s.code,{children:"hashCode"})," method on each of the two objects must produce the same integer result."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Inequality Does NOT Imply Inequality of Hash Codes:"})," It is ",(0,t.jsx)(s.em,{children:"not"})," required that if two objects are unequal according to the ",(0,t.jsx)(s.code,{children:"equals(Object)"})," method, then calling the ",(0,t.jsx)(s.code,{children:"hashCode"})," method on each of the two objects must produce distinct integer results. However, producing distinct integer results for unequal objects can improve the performance of hash tables. (Collisions are allowed but should be minimized)."]}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsxs)(s.strong,{children:["Why the ",(0,t.jsx)(s.code,{children:"equals()"})," and ",(0,t.jsx)(s.code,{children:"hashCode()"})," contract is critical:"]})}),"\n",(0,t.jsxs)(s.p,{children:["Hash-based collections work by first calculating the ",(0,t.jsx)(s.code,{children:"hashCode()"}),' of an object to determine which "bucket" it belongs to. Only then does it use ',(0,t.jsx)(s.code,{children:"equals()"})," to compare objects within that bucket."]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsxs)(s.strong,{children:["If you override ",(0,t.jsx)(s.code,{children:"equals()"})," but not ",(0,t.jsx)(s.code,{children:"hashCode()"}),":"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"obj1.equals(obj2)"})," might return ",(0,t.jsx)(s.code,{children:"true"})," (because their content is the same)."]}),"\n",(0,t.jsxs)(s.li,{children:["But ",(0,t.jsx)(s.code,{children:"obj1.hashCode()"})," and ",(0,t.jsx)(s.code,{children:"obj2.hashCode()"})," might return different values (due to the default implementation returning distinct values for distinct objects)."]}),"\n",(0,t.jsxs)(s.li,{children:["This means ",(0,t.jsx)(s.code,{children:"HashMap"})," or ",(0,t.jsx)(s.code,{children:"HashSet"})," might put ",(0,t.jsx)(s.code,{children:"obj1"})," and ",(0,t.jsx)(s.code,{children:"obj2"})," into different buckets, and you'll be unable to retrieve ",(0,t.jsx)(s.code,{children:"obj1"})," using ",(0,t.jsx)(s.code,{children:"obj2"})," as a key, or a ",(0,t.jsx)(s.code,{children:"HashSet"}),' might contain two "equal" objects. This breaks the expected behavior of these collections.']}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsxs)(s.strong,{children:["Typical ",(0,t.jsx)(s.code,{children:"hashCode()"})," Implementation Pattern:"]}),"\r\nA good ",(0,t.jsx)(s.code,{children:"hashCode()"})," implementation combines the hash codes of all fields used in ",(0,t.jsx)(s.code,{children:"equals()"}),". For primitive fields, use their direct hash code (or their wrapper class's ",(0,t.jsx)(s.code,{children:"hashCode()"}),"). For reference types, use their ",(0,t.jsx)(s.code,{children:"hashCode()"}),". ",(0,t.jsx)(s.code,{children:"null"})," values need special handling (e.g., return 0 or a fixed constant)."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-java",children:"import java.util.Objects; // Utility for generating hash codes easily\r\n\r\npublic class MyClass {\r\n    private int id;\r\n    private String name;\r\n\r\n    // Constructor, equals() as above...\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        // Using Objects.hash() is the simplest and recommended way\r\n        return Objects.hash(id, name);\r\n\r\n        // Manual implementation example:\r\n        // int result = id;\r\n        // result = 31 * result + (name != null ? name.hashCode() : 0);\r\n        // return result;\r\n    }\r\n}\n"})}),"\n",(0,t.jsxs)(s.p,{children:["The number 31 is a common prime multiplier used in ",(0,t.jsx)(s.code,{children:"hashCode()"})," calculations because it's an odd prime number. Multiplying by an odd prime minimizes collisions and performs well in typical scenarios."]}),"\n",(0,t.jsx)(s.h3,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Always Override Both:"})," If you override ",(0,t.jsx)(s.code,{children:"equals()"}),", you ",(0,t.jsx)(s.em,{children:"must"})," override ",(0,t.jsx)(s.code,{children:"hashCode()"}),"."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsxs)(s.strong,{children:["Use Fields Used in ",(0,t.jsx)(s.code,{children:"equals()"}),":"]})," Ensure that the fields used to calculate ",(0,t.jsx)(s.code,{children:"hashCode()"})," are the ",(0,t.jsx)(s.em,{children:"exact same"})," fields used in ",(0,t.jsx)(s.code,{children:"equals()"})," comparison."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Consistency:"})," The ",(0,t.jsx)(s.code,{children:"hashCode()"})," should return the same value for an object as long as the fields used in ",(0,t.jsx)(s.code,{children:"equals()"}),' do not change. If an object\'s fields change, its hash code might change, which can cause issues if the object is already stored in a hash-based collection (it might become "lost"). For this reason, objects used as keys in ',(0,t.jsx)(s.code,{children:"HashMap"})," or elements in ",(0,t.jsx)(s.code,{children:"HashSet"})," are often made ",(0,t.jsx)(s.strong,{children:"immutable"})," or at least the fields used in ",(0,t.jsx)(s.code,{children:"equals()"})," and ",(0,t.jsx)(s.code,{children:"hashCode()"})," are immutable."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"IDE Generation:"})," Modern IDEs (like IntelliJ IDEA, Eclipse) can automatically generate ",(0,t.jsx)(s.code,{children:"equals()"})," and ",(0,t.jsx)(s.code,{children:"hashCode()"})," methods based on your selected fields. This is highly recommended as it helps ensure correctness and adheres to best practices."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsxs)(s.strong,{children:[(0,t.jsx)(s.code,{children:"Objects.hash()"}),":"]})," Since Java 7, ",(0,t.jsx)(s.code,{children:"java.util.Objects.hash(Object... values)"})," provides a convenient way to generate hash codes from multiple fields, handling nulls correctly."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Performance Considerations:"})," While the primary goal is correctness, a well-distributed hash code (minimizing collisions) is important for the performance of hash-based collections."]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["By correctly implementing ",(0,t.jsx)(s.code,{children:"equals()"})," and ",(0,t.jsx)(s.code,{children:"hashCode()"}),", you ensure that your custom objects behave as expected in all contexts where object equality is important, especially when they are used in Java's powerful collection framework."]})]})}function h(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>r,x:()=>c});var i=n(6540);const t={},o=i.createContext(t);function r(e){const s=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),i.createElement(o.Provider,{value:s},e.children)}}}]);