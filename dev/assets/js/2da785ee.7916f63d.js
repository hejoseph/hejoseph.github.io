"use strict";(self.webpackChunkmydevdocs=self.webpackChunkmydevdocs||[]).push([[7646],{6273:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"java/Core/OOP/interface-abstract","title":"Interfaces vs. Abstract Classes","description":"In Java\'s object-oriented programming (OOP) paradigm, both interfaces and abstract classes provide mechanisms for achieving abstraction and polymorphism. While they share some similarities, their primary purposes, capabilities, and use cases differ significantly.","source":"@site/docs/java/1-Core/1-OOP/2-interface-abstract.md","sourceDirName":"java/1-Core/1-OOP","slug":"/java/Core/OOP/interface-abstract","permalink":"/dev/docs/java/Core/OOP/interface-abstract","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"java","permalink":"/dev/docs/tags/java"},{"inline":true,"label":"oop","permalink":"/dev/docs/tags/oop"},{"inline":true,"label":"interfaces","permalink":"/dev/docs/tags/interfaces"},{"inline":true,"label":"abstract classes","permalink":"/dev/docs/tags/abstract-classes"},{"inline":true,"label":"polymorphism","permalink":"/dev/docs/tags/polymorphism"}],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Interfaces vs. Abstract Classes","sidebar_position":2,"tags":["java","oop","interfaces","abstract classes","polymorphism"]},"sidebar":"tutorialSidebar","previous":{"title":"Java OOP Principles","permalink":"/dev/docs/java/Core/OOP/java-oop-principles"},"next":{"title":"Composition Over Inheritance","permalink":"/dev/docs/java/Core/OOP/composition-inheritance"}}');var i=t(4848),r=t(8453);const a={title:"Interfaces vs. Abstract Classes",sidebar_position:2,tags:["java","oop","interfaces","abstract classes","polymorphism"]},l=void 0,c={},d=[{value:"Interfaces",id:"interfaces",level:3},{value:"Abstract Classes",id:"abstract-classes",level:3},{value:"Key Differences Summarized",id:"key-differences-summarized",level:3},{value:"When to Choose Which",id:"when-to-choose-which",level:3}];function o(e){const s={code:"code",em:"em",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.p,{children:"In Java's object-oriented programming (OOP) paradigm, both interfaces and abstract classes provide mechanisms for achieving abstraction and polymorphism. While they share some similarities, their primary purposes, capabilities, and use cases differ significantly."}),"\n",(0,i.jsx)(s.h3,{id:"interfaces",children:"Interfaces"}),"\n",(0,i.jsxs)(s.p,{children:["An interface in Java is a blueprint of a class. It can have static final fields (constants) and abstract methods. From Java 8 onwards, interfaces can also have ",(0,i.jsx)(s.code,{children:"default"})," and ",(0,i.jsx)(s.code,{children:"static"})," methods. From Java 9 onwards, ",(0,i.jsx)(s.code,{children:"private"})," methods are also allowed."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Key Characteristics:"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"100% Abstraction:"})," Historically, all methods in an interface were implicitly ",(0,i.jsx)(s.code,{children:"public abstract"})," and had no implementation."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Fields:"})," Can only declare ",(0,i.jsx)(s.code,{children:"public static final"})," fields (constants). These are implicitly ",(0,i.jsx)(s.code,{children:"public static final"}),"."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Methods:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"public abstract"})," methods (implicitly)."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"default"})," methods (from Java 8) provide a default implementation that implementing classes can override."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"static"})," methods (from Java 8) are utility methods related to the interface itself, not its implementing objects."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"private"})," and ",(0,i.jsx)(s.code,{children:"private static"})," methods (from Java 9) to support ",(0,i.jsx)(s.code,{children:"default"})," and ",(0,i.jsx)(s.code,{children:"static"})," methods within the interface."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Constructors:"})," Cannot have constructors."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Inheritance:"})," A class ",(0,i.jsx)(s.code,{children:"implements"})," an interface. A class can implement multiple interfaces (multiple inheritance of type). An interface can ",(0,i.jsx)(s.code,{children:"extend"})," multiple other interfaces."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Access Modifiers:"})," All members are implicitly ",(0,i.jsx)(s.code,{children:"public"})," (except private methods)."]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Use Cases:"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Defining Contracts:"})," Interfaces are ideal for defining contracts that classes must adhere to. Any class implementing an interface guarantees to provide implementations for its abstract methods."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Achieving Multiple Inheritance of Type:"})," Since a class can implement multiple interfaces, it can acquire behaviors from multiple sources, bypassing Java's single inheritance limitation for classes."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Loose Coupling:"})," Promotes loose coupling by allowing classes to interact based on defined interfaces rather than concrete implementations."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Callback Mechanisms:"})," Often used for defining callback methods."]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Example:"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-java",children:'interface Shape {\r\n    double PI = 3.14159; // public static final by default\r\n\r\n    double calculateArea(); // public abstract by default\r\n    double calculatePerimeter();\r\n\r\n    default void display() { // Default method\r\n        System.out.println("This is a shape.");\r\n    }\r\n}\r\n\r\nclass Circle implements Shape {\r\n    private double radius;\r\n\r\n    public Circle(double radius) {\r\n        this.radius = radius;\r\n    }\r\n\r\n    @Override\r\n    public double calculateArea() {\r\n        return PI * radius * radius;\r\n    }\r\n\r\n    @Override\r\n    public double calculatePerimeter() {\r\n        return 2 * PI * radius;\r\n    }\r\n}\n'})}),"\n",(0,i.jsx)(s.h3,{id:"abstract-classes",children:"Abstract Classes"}),"\n",(0,i.jsx)(s.p,{children:"An abstract class is a class that cannot be instantiated on its own and may contain abstract methods (methods without an implementation) as well as concrete (implemented) methods. It serves as a base class for other classes, providing common functionality and defining a template for subclasses."}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Key Characteristics:"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Partial Abstraction:"})," Can have both abstract methods and concrete methods. It can be 0% abstract (no abstract methods but still declared ",(0,i.jsx)(s.code,{children:"abstract"}),") or up to 100% abstract (all methods are abstract)."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Fields:"})," Can have any type of fields (static, non-static, final, non-final) with any access modifier (",(0,i.jsx)(s.code,{children:"public"}),", ",(0,i.jsx)(s.code,{children:"protected"}),", ",(0,i.jsx)(s.code,{children:"private"}),", default)."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Methods:"})," Can have abstract methods (declared with the ",(0,i.jsx)(s.code,{children:"abstract"})," keyword) and concrete methods."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Constructors:"})," Can have constructors. These constructors are called when a concrete subclass is instantiated."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Inheritance:"})," A class ",(0,i.jsx)(s.code,{children:"extends"})," an abstract class. A class can extend only one abstract class (single inheritance). An abstract class can ",(0,i.jsx)(s.code,{children:"extend"})," another class or abstract class and can ",(0,i.jsx)(s.code,{children:"implement"})," interfaces."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Access Modifiers:"})," Members can have any access modifier."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsxs)(s.strong,{children:[(0,i.jsx)(s.code,{children:"final"})," Methods:"]})," An abstract class can have ",(0,i.jsx)(s.code,{children:"final"})," methods, which cannot be overridden by subclasses."]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Use Cases:"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Code Reusability:"})," Provides a common base for related classes, allowing subclasses to share common implemented methods and fields."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Template Method Pattern:"})," Often used to implement the template method design pattern, where a skeleton of an algorithm is defined in the abstract class, and concrete steps are left for subclasses to implement."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Hierarchy of Related Objects:"}),' Best suited when there is an "is-a" relationship and you want to provide common state and behavior to a group of tightly related objects.']}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Version Control:"})," Easier to evolve than interfaces without breaking existing implementations, as you can add new concrete methods without forcing subclasses to implement them."]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Example:"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-java",children:'abstract class Vehicle {\r\n    String brand;\r\n    int year;\r\n\r\n    public Vehicle(String brand, int year) { // Constructor\r\n        this.brand = brand;\r\n        this.year = year;\r\n    }\r\n\r\n    public void displayInfo() { // Concrete method\r\n        System.out.println("Brand: " + brand + ", Year: " + year);\r\n    }\r\n\r\n    public abstract void start(); // Abstract method\r\n    public abstract void stop();\r\n}\r\n\r\nclass Car extends Vehicle {\r\n    public Car(String brand, int year) {\r\n        super(brand, year);\r\n    }\r\n\r\n    @Override\r\n    public void start() {\r\n        System.out.println("Car starts with a key.");\r\n    }\r\n\r\n    @Override\r\n    public void stop() {\r\n        System.out.println("Car stops by pressing brake.");\r\n    }\r\n}\n'})}),"\n",(0,i.jsx)(s.h3,{id:"key-differences-summarized",children:"Key Differences Summarized"}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{style:{textAlign:"left"},children:"Feature"}),(0,i.jsx)(s.th,{style:{textAlign:"left"},children:"Interface"}),(0,i.jsx)(s.th,{style:{textAlign:"left"},children:"Abstract Class"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{style:{textAlign:"left"},children:(0,i.jsx)(s.strong,{children:"Type of Members"})}),(0,i.jsxs)(s.td,{style:{textAlign:"left"},children:["Only ",(0,i.jsx)(s.code,{children:"public static final"})," fields. Abstract, default, static, and private methods."]}),(0,i.jsx)(s.td,{style:{textAlign:"left"},children:"Any type of fields (static, non-static, final, non-final) with any access modifier. Abstract and concrete methods."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{style:{textAlign:"left"},children:(0,i.jsx)(s.strong,{children:"Abstraction"})}),(0,i.jsxs)(s.td,{style:{textAlign:"left"},children:["Historically, 100% abstract. Now, can have concrete ",(0,i.jsx)(s.code,{children:"default"})," and ",(0,i.jsx)(s.code,{children:"static"})," methods."]}),(0,i.jsx)(s.td,{style:{textAlign:"left"},children:"Can be 0% to 100% abstract (can have zero or more abstract methods)."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{style:{textAlign:"left"},children:(0,i.jsx)(s.strong,{children:"Methods"})}),(0,i.jsxs)(s.td,{style:{textAlign:"left"},children:["Abstract methods are implicitly ",(0,i.jsx)(s.code,{children:"public abstract"}),". Can have ",(0,i.jsx)(s.code,{children:"default"}),", ",(0,i.jsx)(s.code,{children:"static"}),", ",(0,i.jsx)(s.code,{children:"private"})," methods."]}),(0,i.jsxs)(s.td,{style:{textAlign:"left"},children:["Abstract methods are explicitly ",(0,i.jsx)(s.code,{children:"abstract"}),". Can have concrete methods with any access modifier."]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{style:{textAlign:"left"},children:(0,i.jsx)(s.strong,{children:"Constructors"})}),(0,i.jsx)(s.td,{style:{textAlign:"left"},children:"Cannot have constructors."}),(0,i.jsx)(s.td,{style:{textAlign:"left"},children:"Can have constructors."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{style:{textAlign:"left"},children:(0,i.jsx)(s.strong,{children:"Inheritance"})}),(0,i.jsxs)(s.td,{style:{textAlign:"left"},children:["A class ",(0,i.jsx)(s.code,{children:"implements"})," interfaces. Supports multiple inheritance of type. An interface ",(0,i.jsx)(s.code,{children:"extends"})," other interfaces."]}),(0,i.jsxs)(s.td,{style:{textAlign:"left"},children:["A class ",(0,i.jsx)(s.code,{children:"extends"})," an abstract class. Supports single inheritance only."]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{style:{textAlign:"left"},children:(0,i.jsx)(s.strong,{children:'"Is-a" vs "Can-do"'})}),(0,i.jsx)(s.td,{style:{textAlign:"left"},children:'Defines a "can-do" ability or a contract.'}),(0,i.jsx)(s.td,{style:{textAlign:"left"},children:'Defines an "is-a" relationship or a common base.'})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{style:{textAlign:"left"},children:(0,i.jsx)(s.strong,{children:"Keywords"})}),(0,i.jsxs)(s.td,{style:{textAlign:"left"},children:[(0,i.jsx)(s.code,{children:"interface"}),", ",(0,i.jsx)(s.code,{children:"implements"}),", ",(0,i.jsx)(s.code,{children:"extends"})]}),(0,i.jsxs)(s.td,{style:{textAlign:"left"},children:[(0,i.jsx)(s.code,{children:"abstract"}),", ",(0,i.jsx)(s.code,{children:"class"}),", ",(0,i.jsx)(s.code,{children:"extends"}),", ",(0,i.jsx)(s.code,{children:"implements"})]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{style:{textAlign:"left"},children:(0,i.jsx)(s.strong,{children:"Final Methods"})}),(0,i.jsxs)(s.td,{style:{textAlign:"left"},children:["Methods can't be ",(0,i.jsx)(s.code,{children:"final"})," (but ",(0,i.jsx)(s.code,{children:"default"})," and ",(0,i.jsx)(s.code,{children:"static"})," methods are implicitly not meant for overriding by subclasses directly)."]}),(0,i.jsxs)(s.td,{style:{textAlign:"left"},children:["Can have ",(0,i.jsx)(s.code,{children:"final"})," methods, which cannot be overridden."]})]})]})]}),"\n",(0,i.jsx)(s.h3,{id:"when-to-choose-which",children:"When to Choose Which"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Choose an Interface when:"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["You want to define a contract for what classes ",(0,i.jsx)(s.em,{children:"can do"}),", regardless of their position in the inheritance hierarchy."]}),"\n",(0,i.jsx)(s.li,{children:"You need to achieve multiple inheritance of type."}),"\n",(0,i.jsx)(s.li,{children:"You want to promote loose coupling between components."}),"\n",(0,i.jsx)(s.li,{children:"You are defining an API or a set of behaviors that unrelated classes might implement."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Choose an Abstract Class when:"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"You want to provide a common base implementation for related classes, sharing code and state."}),"\n",(0,i.jsx)(s.li,{children:"You have methods that should be implemented by subclasses, but also methods with a default implementation that can be inherited."}),"\n",(0,i.jsx)(s.li,{children:"You need to define common fields (variables) that subclasses will share."}),"\n",(0,i.jsx)(s.li,{children:"You want to enforce a specific hierarchy for a set of classes."}),"\n",(0,i.jsx)(s.li,{children:"You need to provide constructors for subclasses."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["In essence, interfaces define what an object can do (its contract/behavior), while abstract classes define what an object ",(0,i.jsx)(s.em,{children:"is"})," (its type and shared implementation). Often, complex designs might utilize a combination of both to achieve robust and extensible architectures."]})]})}function h(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},8453:(e,s,t)=>{t.d(s,{R:()=>a,x:()=>l});var n=t(6540);const i={},r=n.createContext(i);function a(e){const s=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),n.createElement(r.Provider,{value:s},e.children)}}}]);