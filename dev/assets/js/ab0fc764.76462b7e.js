"use strict";(self.webpackChunkmydevdocs=self.webpackChunkmydevdocs||[]).push([[5944],{6967:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"Portfolio/Timelock/bug/translation_performance_problem","title":"Translation Performance Case Study","description":"Executive Summary","source":"@site/docs/Portfolio/Timelock/bug/translation_performance_problem.md","sourceDirName":"Portfolio/Timelock/bug","slug":"/Portfolio/Timelock/bug/translation_performance_problem","permalink":"/dev/docs/Portfolio/Timelock/bug/translation_performance_problem","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Tooltip Flickering Bug Analysis","permalink":"/dev/docs/Portfolio/Timelock/bug/tooltip_flickering_bug_analysis"},"next":{"title":"Code Structure","permalink":"/dev/docs/Portfolio/Timelock/code-structure/"}}');var s=r(4848),i=r(8453);const a={},l="Translation Performance Case Study",c={},o=[{value:"Executive Summary",id:"executive-summary",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Symptoms Observed",id:"symptoms-observed",level:3},{value:"Performance Impact",id:"performance-impact",level:3},{value:"Root Cause Analysis",id:"root-cause-analysis",level:2},{value:"1. <strong>Architectural Misunderstanding: Pure vs Impure Pipes</strong>",id:"1-architectural-misunderstanding-pure-vs-impure-pipes",level:3},{value:"2. <strong>Excessive Signal Reads and Redundant Operations</strong>",id:"2-excessive-signal-reads-and-redundant-operations",level:3},{value:"3. <strong>Template Pipe Overuse</strong>",id:"3-template-pipe-overuse",level:3},{value:"4. <strong>No Caching Strategy</strong>",id:"4-no-caching-strategy",level:3},{value:"Solution Architecture",id:"solution-architecture",level:2},{value:"1. <strong>Fixed Pipe Purity and Added Intelligent Caching</strong>",id:"1-fixed-pipe-purity-and-added-intelligent-caching",level:3},{value:"2. <strong>Optimized Translation Service with Multi-Layer Caching</strong>",id:"2-optimized-translation-service-with-multi-layer-caching",level:3},{value:"3. <strong>Reduced Template Pipe Usage with Computed Translations</strong>",id:"3-reduced-template-pipe-usage-with-computed-translations",level:3},{value:"Performance Results",id:"performance-results",level:2},{value:"Before Optimization",id:"before-optimization",level:3},{value:"After Optimization",id:"after-optimization",level:3},{value:"Key Lessons Learned",id:"key-lessons-learned",level:2},{value:"1. <strong>Understanding Angular Pipe Purity</strong>",id:"1-understanding-angular-pipe-purity",level:3},{value:"2. <strong>Caching Strategy Design</strong>",id:"2-caching-strategy-design",level:3},{value:"3. <strong>Template Optimization Patterns</strong>",id:"3-template-optimization-patterns",level:3},{value:"4. <strong>Performance Monitoring</strong>",id:"4-performance-monitoring",level:3},{value:"Best Practices Established",id:"best-practices-established",level:2},{value:"1. <strong>Translation System Architecture</strong>",id:"1-translation-system-architecture",level:3},{value:"2. <strong>Caching Implementation</strong>",id:"2-caching-implementation",level:3},{value:"3. <strong>Performance Testing</strong>",id:"3-performance-testing",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"translation-performance-case-study",children:"Translation Performance Case Study"})}),"\n",(0,s.jsx)(n.h2,{id:"executive-summary",children:"Executive Summary"}),"\n",(0,s.jsx)(n.p,{children:"This case study documents a critical performance issue in an Angular application's internationalization (i18n) system that was causing significant UI lag and poor user experience. The problem stemmed from inefficient pipe usage, lack of caching, and architectural misunderstandings about Angular's change detection system."}),"\n",(0,s.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,s.jsx)(n.h3,{id:"symptoms-observed",children:"Symptoms Observed"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Noticeable UI lag when switching between languages"}),"\n",(0,s.jsx)(n.li,{children:"Slow rendering of components with many translated strings"}),"\n",(0,s.jsxs)(n.li,{children:["Poor performance in components like ",(0,s.jsx)(n.code,{children:"TodoItemComponent"})," (20+ translations per item)"]}),"\n",(0,s.jsx)(n.li,{children:"Excessive CPU usage during change detection cycles"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"performance-impact",children:"Performance Impact"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Language switching took 200-500ms instead of expected <50ms"}),"\n",(0,s.jsx)(n.li,{children:"Components with heavy translation usage showed 3-5x slower rendering"}),"\n",(0,s.jsx)(n.li,{children:"Change detection cycles were 2-3x longer than optimal"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"root-cause-analysis",children:"Root Cause Analysis"}),"\n",(0,s.jsxs)(n.h3,{id:"1-architectural-misunderstanding-pure-vs-impure-pipes",children:["1. ",(0,s.jsx)(n.strong,{children:"Architectural Misunderstanding: Pure vs Impure Pipes"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"The Problem:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"@Pipe({\r\n  name: 'translate',\r\n  standalone: true,\r\n  pure: true // \u274c INCORRECT - This was the main issue\r\n})\r\nexport class TranslatePipe implements PipeTransform {\r\n  transform(key: string): string {\r\n    const currentLang = this.translationService.currentLanguage(); // External state dependency\r\n    return this.translationService.translate(key);\r\n  }\r\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Why This Was Wrong:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Pure pipes"})," should only depend on their input parameters"]}),"\n",(0,s.jsxs)(n.li,{children:["This pipe depended on external state (",(0,s.jsx)(n.code,{children:"currentLanguage"})," signal)"]}),"\n",(0,s.jsx)(n.li,{children:"Angular's change detection couldn't track external dependencies"}),"\n",(0,s.jsx)(n.li,{children:"Result: Translations didn't update when language changed OR updated too frequently"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"The Fundamental Issue:"}),"\r\nPure pipes are cached based on input parameters only. When the language changed, the pipe input (",(0,s.jsx)(n.code,{children:"key"}),") remained the same, so Angular returned the cached result in the old language."]}),"\n",(0,s.jsxs)(n.h3,{id:"2-excessive-signal-reads-and-redundant-operations",children:["2. ",(0,s.jsx)(n.strong,{children:"Excessive Signal Reads and Redundant Operations"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"The Problem:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"translate(key: string): string {\r\n  const keys = key.split('.'); // \u274c Repeated string splitting\r\n  const currentLang = this.currentLanguageSignal(); // \u274c Signal read on every call\r\n  let translation: any = this.translations[currentLang]; // \u274c Object traversal every time\r\n  \r\n  for (const k of keys) {\r\n    if (translation && typeof translation === 'object' && k in translation) {\r\n      translation = translation[k];\r\n    } else {\r\n      // \u274c Inefficient fallback logic with nested loops\r\n      translation = this.translations['en'];\r\n      for (const fallbackKey of keys) {\r\n        // ... more object traversal\r\n      }\r\n    }\r\n  }\r\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Performance Issues:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"String splitting"}),": ",(0,s.jsx)(n.code,{children:"key.split('.')"})," called for every translation, even for the same keys"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Signal reads"}),": ",(0,s.jsx)(n.code,{children:"currentLanguageSignal()"})," called multiple times per change detection cycle"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Object traversal"}),": Deep object navigation repeated for identical keys"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Inefficient fallbacks"}),": Nested loops and redundant object traversal"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"3-template-pipe-overuse",children:["3. ",(0,s.jsx)(n.strong,{children:"Template Pipe Overuse"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"The Problem:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:"\x3c!-- TodoItemComponent template had 20+ pipe usages like this: --\x3e\r\n<span [title]=\"'todoItem.taskOverlaps' | translate\">\u23f1\ufe0f</span>\r\n<span [title]=\"'todoItem.recurringTask' | translate\">\ud83d\udd04</span>\r\n<span [title]=\"'todoItem.generatedFromRecurring' | translate\">\ud83d\udcc5</span>\r\n<button [title]=\"'todoItem.editTask' | translate\">Edit</button>\r\n<button [title]=\"'todoItem.deleteTask' | translate\">Delete</button>\r\n\x3c!-- ... 15+ more similar usages --\x3e\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Why This Was Problematic:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Each pipe usage triggered the expensive translation logic"}),"\n",(0,s.jsx)(n.li,{children:"20+ translations per component \xd7 multiple components = hundreds of unnecessary operations"}),"\n",(0,s.jsx)(n.li,{children:"No sharing of translation results between similar components"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"4-no-caching-strategy",children:["4. ",(0,s.jsx)(n.strong,{children:"No Caching Strategy"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"The Problem:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Same translation keys were processed repeatedly"}),"\n",(0,s.jsx)(n.li,{children:"No memory of previous translation results"}),"\n",(0,s.jsx)(n.li,{children:"Language changes required re-processing all translations from scratch"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"solution-architecture",children:"Solution Architecture"}),"\n",(0,s.jsxs)(n.h3,{id:"1-fixed-pipe-purity-and-added-intelligent-caching",children:["1. ",(0,s.jsx)(n.strong,{children:"Fixed Pipe Purity and Added Intelligent Caching"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"@Pipe({\r\n  name: 'translate',\r\n  standalone: true,\r\n  pure: false // \u2705 CORRECT - Handles external state dependencies\r\n})\r\nexport class TranslatePipe implements PipeTransform {\r\n  private translationCache = new Map<string, string>();\r\n  private currentLanguageCache = signal<string>('');\r\n\r\n  constructor() {\r\n    // \u2705 Smart cache invalidation\r\n    effect(() => {\r\n      const currentLang = this.translationService.currentLanguage();\r\n      if (this.currentLanguageCache() !== currentLang) {\r\n        this.translationCache.clear(); // Clear cache only when language changes\r\n        this.currentLanguageCache.set(currentLang);\r\n      }\r\n    });\r\n  }\r\n\r\n  transform(key: string): string {\r\n    if (!key) return '';\r\n    \r\n    // \u2705 Cache lookup with language-specific keys\r\n    const cacheKey = `${this.translationService.currentLanguage()}_${key}`;\r\n    if (this.translationCache.has(cacheKey)) {\r\n      return this.translationCache.get(cacheKey)!; // Cache hit - instant return\r\n    }\r\n    \r\n    // \u2705 Cache miss - compute and store\r\n    const translation = this.translationService.translate(key);\r\n    this.translationCache.set(cacheKey, translation);\r\n    return translation;\r\n  }\r\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key Improvements:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Correct purity"}),": Impure pipe properly handles external dependencies"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Smart caching"}),": Results cached with language-specific keys"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Automatic invalidation"}),": Cache cleared only when language actually changes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Performance"}),": Cache hits return instantly, cache misses computed once"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"2-optimized-translation-service-with-multi-layer-caching",children:["2. ",(0,s.jsx)(n.strong,{children:"Optimized Translation Service with Multi-Layer Caching"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export class TranslationService {\r\n  // \u2705 Layer 1: Key parsing cache\r\n  private keyCache = new Map<string, string[]>();\r\n  \r\n  // \u2705 Layer 2: Translation result cache\r\n  private translationCache = new Map<string, string>();\r\n\r\n  translate(key: string): string {\r\n    if (!key) return '';\r\n    \r\n    const currentLang = this.currentLanguageSignal();\r\n    const cacheKey = `${currentLang}_${key}`;\r\n    \r\n    // \u2705 Check result cache first\r\n    if (this.translationCache.has(cacheKey)) {\r\n      return this.translationCache.get(cacheKey)!;\r\n    }\r\n    \r\n    // \u2705 Get or cache parsed keys\r\n    let keys: string[];\r\n    if (this.keyCache.has(key)) {\r\n      keys = this.keyCache.get(key)!; // Avoid repeated string splitting\r\n    } else {\r\n      keys = key.split('.');\r\n      this.keyCache.set(key, keys);\r\n    }\r\n    \r\n    // \u2705 Optimized translation lookup\r\n    let translation = this.getTranslationByKeys(keys, currentLang);\r\n    \r\n    // \u2705 Efficient fallback\r\n    if (translation === null && currentLang !== 'en') {\r\n      translation = this.getTranslationByKeys(keys, 'en');\r\n    }\r\n    \r\n    const result = translation ?? key;\r\n    this.translationCache.set(cacheKey, result); // Cache the result\r\n    return result;\r\n  }\r\n\r\n  // \u2705 Optimized helper method\r\n  private getTranslationByKeys(keys: string[], language: Language): string | null {\r\n    let translation: any = this.translations[language];\r\n    \r\n    for (const k of keys) {\r\n      if (translation && typeof translation === 'object' && k in translation) {\r\n        translation = translation[k];\r\n      } else {\r\n        return null; // Early exit instead of nested loops\r\n      }\r\n    }\r\n    \r\n    return typeof translation === 'string' ? translation : null;\r\n  }\r\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Performance Optimizations:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Dual-layer caching"}),": Key parsing + translation results"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Efficient fallbacks"}),": Single pass with early exit"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reduced signal reads"}),": Language read once per translation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory efficient"}),": Caches cleared only when necessary"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"3-reduced-template-pipe-usage-with-computed-translations",children:["3. ",(0,s.jsx)(n.strong,{children:"Reduced Template Pipe Usage with Computed Translations"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export class TodoItemComponent {\r\n  // \u2705 Computed translations - calculated once per language change\r\n  protected translations = computed(() => ({\r\n    taskOverlaps: this.translationService.translate('todoItem.taskOverlaps'),\r\n    recurringTask: this.translationService.translate('todoItem.recurringTask'),\r\n    editTask: this.translationService.translate('todoItem.editTask'),\r\n    deleteTask: this.translationService.translate('todoItem.deleteTask'),\r\n    // ... all frequently used translations\r\n  }));\r\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'\x3c!-- \u2705 Template using computed translations --\x3e\r\n<span [title]="translations().taskOverlaps">\u23f1\ufe0f</span>\r\n<span [title]="translations().recurringTask">\ud83d\udd04</span>\r\n<button [title]="translations().editTask">Edit</button>\r\n<button [title]="translations().deleteTask">Delete</button>\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Benefits:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reduced pipe calls"}),": From 20+ pipes to 1 computed signal"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Shared computation"}),": All translations computed together"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Automatic reactivity"}),": Updates when language changes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Better performance"}),": Computed signals are more efficient than multiple pipes"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"performance-results",children:"Performance Results"}),"\n",(0,s.jsx)(n.h3,{id:"before-optimization",children:"Before Optimization"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Language Switch: 200-500ms\r\nComponent Rendering: 50-150ms (with 20+ translations)\r\nChange Detection Cycle: 15-25ms\r\nCache Hit Rate: 0% (no caching)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"after-optimization",children:"After Optimization"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Language Switch: <50ms (10x improvement)\r\nComponent Rendering: 10-30ms (3-5x improvement)\r\nChange Detection Cycle: 5-10ms (2-3x improvement)\r\nCache Hit Rate: 95%+ after initial load\n"})}),"\n",(0,s.jsx)(n.h2,{id:"key-lessons-learned",children:"Key Lessons Learned"}),"\n",(0,s.jsxs)(n.h3,{id:"1-understanding-angular-pipe-purity",children:["1. ",(0,s.jsx)(n.strong,{children:"Understanding Angular Pipe Purity"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Pure pipes"}),": Only for transformations that depend solely on input parameters"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Impure pipes"}),": For transformations that depend on external state"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Performance trade-off"}),": Pure pipes are faster but limited; impure pipes are flexible but need careful optimization"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"2-caching-strategy-design",children:["2. ",(0,s.jsx)(n.strong,{children:"Caching Strategy Design"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Multi-layer caching"}),": Different cache levels for different operations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cache invalidation"}),": Clear caches only when necessary, not on every change"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cache keys"}),": Include all relevant context (language + translation key)"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"3-template-optimization-patterns",children:["3. ",(0,s.jsx)(n.strong,{children:"Template Optimization Patterns"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Computed signals"}),": Better than multiple pipes for related data"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Batch operations"}),": Group related translations together"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Minimize pipe usage"}),": Use pipes for dynamic content, computed values for static translations"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"4-performance-monitoring",children:["4. ",(0,s.jsx)(n.strong,{children:"Performance Monitoring"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Measure before optimizing"}),": Establish baseline performance metrics"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Profile systematically"}),": Use browser dev tools to identify bottlenecks"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Test edge cases"}),": Language switching, large datasets, rapid interactions"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"best-practices-established",children:"Best Practices Established"}),"\n",(0,s.jsxs)(n.h3,{id:"1-translation-system-architecture",children:["1. ",(0,s.jsx)(n.strong,{children:"Translation System Architecture"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// \u2705 DO: Use computed signals for static translations\r\nprotected translations = computed(() => ({\r\n  save: this.translationService.translate('actions.save'),\r\n  cancel: this.translationService.translate('actions.cancel')\r\n}));\r\n\r\n// \u274c DON'T: Use pipes for every static translation\r\n// {{ 'actions.save' | translate }} {{ 'actions.cancel' | translate }}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"2-caching-implementation",children:["2. ",(0,s.jsx)(n.strong,{children:"Caching Implementation"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// \u2705 DO: Implement smart cache invalidation\r\neffect(() => {\r\n  const currentLang = this.service.currentLanguage();\r\n  if (this.lastLanguage !== currentLang) {\r\n    this.cache.clear();\r\n    this.lastLanguage = currentLang;\r\n  }\r\n});\r\n\r\n// \u274c DON'T: Clear cache on every operation\r\n// this.cache.clear(); // Too aggressive\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"3-performance-testing",children:["3. ",(0,s.jsx)(n.strong,{children:"Performance Testing"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// \u2705 DO: Add performance tests for critical paths\r\nit('should handle 1000 translations in <50ms', () => {\r\n  const start = performance.now();\r\n  for (let i = 0; i < 1000; i++) {\r\n    pipe.transform('common.loading');\r\n  }\r\n  expect(performance.now() - start).toBeLessThan(50);\r\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"This case study demonstrates how seemingly simple features like internationalization can become performance bottlenecks when not properly architected. The key takeaways are:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Understand the framework"}),": Angular's pipe purity rules and change detection system"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Implement proper caching"}),": Multi-layer caching with smart invalidation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Optimize template usage"}),": Use computed signals for static content, pipes for dynamic content"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Measure and monitor"}),": Establish performance baselines and test optimizations"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The implemented solution achieved a ",(0,s.jsx)(n.strong,{children:"10x improvement"})," in language switching performance and ",(0,s.jsx)(n.strong,{children:"3-5x improvement"})," in component rendering, while maintaining code readability and maintainability."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>l});var t=r(6540);const s={},i=t.createContext(s);function a(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);