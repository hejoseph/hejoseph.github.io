"use strict";(self.webpackChunkmydevdocs=self.webpackChunkmydevdocs||[]).push([[880],{9726:e=>{e.exports=JSON.parse('{"tag":{"label":"java","permalink":"/dev/fr/docs/tags/java","allTagsPath":"/dev/fr/docs/tags","count":9,"items":[{"id":"java/Core/OOP/composition-inheritance","title":"Composition plut\xf4t qu\'h\xe9ritage","description":"\\"Composition plut\xf4t qu\'h\xe9ritage\\" (\xe9galement connu sous le nom de \\"privil\xe9gier la composition \xe0 l\'h\xe9ritage\\") est un principe de conception en programmation orient\xe9e objet qui sugg\xe8re que les classes devraient acqu\xe9rir de nouvelles fonctionnalit\xe9s en composant des objets de classes existantes (c\'est-\xe0-dire en contenant des instances d\'autres classes) plut\xf4t qu\'en h\xe9ritant d\'elles. Ce principe favorise une plus grande flexibilit\xe9, un couplage r\xe9duit et une meilleure r\xe9utilisabilit\xe9 du code.","permalink":"/dev/fr/docs/java/Core/OOP/composition-inheritance"},{"id":"java/Core/OOP/object-equality","title":"\xc9galit\xe9 des Objets - equals() et hashCode()","description":"En Java, d\xe9terminer si deux objets sont \\"\xe9gaux\\" est un concept fondamental, surtout lorsque l\'on travaille avec des collections. Java fournit deux m\xe9thodes dans la classe Object qui sont cruciales pour d\xe9finir et g\xe9rer l\'\xe9galit\xe9 des objets : equals() et hashCode(). Comprendre leur contrat et comment les surcharger correctement est vital pour des applications robustes.","permalink":"/dev/fr/docs/java/Core/OOP/object-equality"},{"id":"java/garbage-collector","title":"Garbage Collection","description":"java-garbage-collector.png","permalink":"/dev/fr/docs/java/garbage-collector"},{"id":"java/Core/OOP/immutability","title":"Immutabilit\xe9 - `final` et copies d\xe9fensives","description":"L\'immutabilit\xe9 est un concept fondamental en programmation orient\xe9e objet, particuli\xe8rement important en Java, qui d\xe9signe l\'\xe9tat d\'un objet restant inchang\xe9 apr\xe8s sa cr\xe9ation. Un objet immuable est un objet dont l\'\xe9tat interne ne peut pas \xeatre modifi\xe9 une fois qu\'il a \xe9t\xe9 enti\xe8rement construit.","permalink":"/dev/fr/docs/java/Core/OOP/immutability"},{"id":"java/Core/OOP/interface-abstract","title":"Interfaces vs. Classes Abstraites","description":"Dans le paradigme de la programmation orient\xe9e objet (POO) en Java, les interfaces et les classes abstraites fournissent toutes deux des m\xe9canismes pour atteindre l\'abstraction et le polymorphisme. Bien qu\'elles partagent certaines similitudes, leurs objectifs principaux, leurs capacit\xe9s et leurs cas d\'utilisation diff\xe8rent significativement.","permalink":"/dev/fr/docs/java/Core/OOP/interface-abstract"},{"id":"java/Core/OOP/java-oop-principles","title":"Java OOP Principles","description":"Object-Oriented Programming (OOP) is a programming paradigm that organizes software design around data, or objects, rather than functions and logic. Java is a purely object-oriented language, meaning almost everything in Java revolves around classes and objects.","permalink":"/dev/fr/docs/java/Core/OOP/java-oop-principles"},{"id":"java/Memory/heap-stack","title":"M\xe9moire Tas vs. Pile","description":"Dans le contexte de la Machine Virtuelle Java (JVM) et du Mod\xe8le de M\xe9moire Java (JMM), le \\"Tas\\" (Heap) et la \\"Pile\\" (Stack) sont deux r\xe9gions de m\xe9moire fondamentales avec des objectifs, des caract\xe9ristiques et des approches de gestion distincts. Comprendre leurs diff\xe9rences est crucial pour saisir la mani\xe8re dont les programmes Java s\'ex\xe9cutent, g\xe8rent la m\xe9moire et traitent les op\xe9rations concurrentes.","permalink":"/dev/fr/docs/java/Memory/heap-stack"},{"id":"java/Core/OOP/access-modifiers-visibility","title":"Modificateurs d\'acc\xe8s et visibilit\xe9","description":"En Java, les modificateurs d\'acc\xe8s sont des mots-cl\xe9s qui d\xe9finissent l\'accessibilit\xe9 (visibilit\xe9) des classes, des constructeurs, des m\xe9thodes et des champs. Ils constituent un aspect fondamental de l\'encapsulation, un principe de programmation orient\xe9e objet qui permet de masquer les d\xe9tails d\'impl\xe9mentation internes et de contr\xf4ler la mani\xe8re dont d\'autres parties du code peuvent interagir avec vos classes et leurs membres.","permalink":"/dev/fr/docs/java/Core/OOP/access-modifiers-visibility"},{"id":"java/Core/OOP/solid-principles","title":"Principes SOLID","description":"Les principes SOLID sont un ensemble de cinq principes de conception en programmation orient\xe9e objet, destin\xe9s \xe0 rendre les conceptions logicielles plus compr\xe9hensibles, flexibles et maintenables. Ils ont \xe9t\xe9 promus par Robert C. Martin (Uncle Bob) et sont largement consid\xe9r\xe9s comme des meilleures pratiques pour \xe9crire du code propre, robuste et \xe9volutif.","permalink":"/dev/fr/docs/java/Core/OOP/solid-principles"}],"unlisted":false}}')}}]);