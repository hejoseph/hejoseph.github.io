"use strict";(self.webpackChunkmydevdocs=self.webpackChunkmydevdocs||[]).push([[256],{255:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>a,contentTitle:()=>s,default:()=>h,frontMatter:()=>d,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"Portfolio/PreviewMd/editor","title":"Editor Component","description":"The Editor component is responsible for rendering the Monaco Editor, which provides a rich text editing experience for Markdown.","source":"@site/docs/Portfolio/PreviewMd/editor.md","sourceDirName":"Portfolio/PreviewMd","slug":"/Portfolio/PreviewMd/editor","permalink":"/dev/fr/docs/Portfolio/PreviewMd/editor","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"App Component","permalink":"/dev/fr/docs/Portfolio/PreviewMd/app"},"next":{"title":"Preview Component","permalink":"/dev/fr/docs/Portfolio/PreviewMd/preview"}}');var r=o(4848),i=o(8453);const d={},s="Editor Component",a={},c=[{value:"Props",id:"props",level:2},{value:"State",id:"state",level:2},{value:"Key Features",id:"key-features",level:2},{value:"Theme Synchronization",id:"theme-synchronization",level:3},{value:"Editor Options",id:"editor-options",level:3},{value:"Code Breakdown",id:"code-breakdown",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"editor-component",children:"Editor Component"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"Editor"})," component is responsible for rendering the Monaco Editor, which provides a rich text editing experience for Markdown."]}),"\n",(0,r.jsx)(n.h2,{id:"props",children:"Props"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"value: string"}),": The current Markdown content to be displayed in the editor."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"onChange: (value: string) => void"}),": A callback function that is called whenever the content of the editor changes."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"minimapEnabled: boolean"}),": A boolean to control the visibility of the minimap."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"wordWrapEnabled?: boolean"}),": An optional boolean to control word wrapping. It defaults to ",(0,r.jsx)(n.code,{children:"true"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"state",children:"State"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"theme"}),": Manages the theme of the Monaco Editor, switching between ",(0,r.jsx)(n.code,{children:"'vs-dark'"})," and ",(0,r.jsx)(n.code,{children:"'vs-light'"})," based on the application's theme."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"key-features",children:"Key Features"}),"\n",(0,r.jsx)(n.h3,{id:"theme-synchronization",children:"Theme Synchronization"}),"\n",(0,r.jsxs)(n.p,{children:["The editor's theme is automatically synchronized with the application's theme (light/dark mode). This is achieved using a ",(0,r.jsx)(n.code,{children:"MutationObserver"})," that watches for changes to the ",(0,r.jsx)(n.code,{children:"class"})," attribute of the ",(0,r.jsx)(n.code,{children:"<html>"})," element. When the ",(0,r.jsx)(n.code,{children:"dark"})," class is added or removed, the editor's theme is updated accordingly."]}),"\n",(0,r.jsx)(n.h3,{id:"editor-options",children:"Editor Options"}),"\n",(0,r.jsxs)(n.p,{children:["The component exposes props to control editor features like the minimap and word wrapping. These options are dynamically updated using a ",(0,r.jsx)(n.code,{children:"useEffect"})," hook that listens for changes to the ",(0,r.jsx)(n.code,{children:"minimapEnabled"})," and ",(0,r.jsx)(n.code,{children:"wordWrapEnabled"})," props."]}),"\n",(0,r.jsx)(n.h2,{id:"code-breakdown",children:"Code Breakdown"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"import { useRef, useEffect, useState } from 'react';\nimport MonacoEditor, { type OnMount } from '@monaco-editor/react';\nimport type { editor } from 'monaco-editor';\n\ninterface EditorProps {\n  value: string;\n  onChange: (value: string) => void;\n  minimapEnabled: boolean;\n  wordWrapEnabled?: boolean;\n}\n\nconst Editor: React.FC<EditorProps> = ({\n  value,\n  onChange,\n  minimapEnabled,\n  wordWrapEnabled = true\n}) => {\n  const editorRef = useRef<editor.IStandaloneCodeEditor | null>(null);\n  const [theme, setTheme] = useState<'vs-dark' | 'vs-light'>('vs-dark');\n\n  const handleEditorDidMount: OnMount = (editor) => {\n    editorRef.current = editor;\n  };\n\n  useEffect(() => {\n    if (editorRef.current) {\n      editorRef.current.updateOptions({\n        minimap: {\n          enabled: minimapEnabled,\n        },\n        wordWrap: wordWrapEnabled ? 'on' : 'off',\n      });\n    }\n  }, [minimapEnabled, wordWrapEnabled]);\n\n  useEffect(() => {\n    const updateTheme = () => {\n      const isDark = document.documentElement.classList.contains('dark');\n      setTheme(isDark ? 'vs-dark' : 'vs-light');\n    };\n    updateTheme();\n    const observer = new MutationObserver(() => updateTheme());\n    observer.observe(document.documentElement, { attributes: true, attributeFilter: ['class'] });\n    return () => observer.disconnect();\n  }, []);\n\n  return (\n    <div className=\"h-full w-full\">\n      <MonacoEditor\n        height=\"100%\"\n        defaultLanguage=\"markdown\"\n        value={value}\n        onChange={(value) => onChange(value || '')}\n        onMount={handleEditorDidMount}\n        theme={theme}\n        options={{\n          wordWrap: wordWrapEnabled ? 'on' : 'off',\n          minimap: {\n            enabled: minimapEnabled,\n          },\n          // ... other options\n        }}\n      />\n    </div>\n  );\n};\n\nexport default Editor;\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"editorRef"})}),": A ",(0,r.jsx)(n.code,{children:"useRef"})," hook to hold a reference to the Monaco Editor instance. This allows direct interaction with the editor's API."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"handleEditorDidMount"})}),": A callback function that runs when the editor is first mounted. It saves the editor instance to ",(0,r.jsx)(n.code,{children:"editorRef"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"useEffect"})," for Options"]}),": This effect runs whenever ",(0,r.jsx)(n.code,{children:"minimapEnabled"})," or ",(0,r.jsx)(n.code,{children:"wordWrapEnabled"})," props change. It calls the editor's ",(0,r.jsx)(n.code,{children:"updateOptions"})," method to apply the new settings."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"useEffect"})," for Theme"]}),": This effect sets up the ",(0,r.jsx)(n.code,{children:"MutationObserver"})," to listen for theme changes on the main document and updates the editor's theme state accordingly. It also cleans up the observer when the component unmounts."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>d,x:()=>s});var t=o(6540);const r={},i=t.createContext(r);function d(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);