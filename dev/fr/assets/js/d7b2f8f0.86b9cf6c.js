"use strict";(self.webpackChunkmydevdocs=self.webpackChunkmydevdocs||[]).push([[3904],{7381:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>u,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"java/Core/OOP/solid-principles","title":"Principes SOLID","description":"Les principes SOLID sont un ensemble de cinq principes de conception en programmation orient\xe9e objet, destin\xe9s \xe0 rendre les conceptions logicielles plus compr\xe9hensibles, flexibles et maintenables. Ils ont \xe9t\xe9 promus par Robert C. Martin (Uncle Bob) et sont largement consid\xe9r\xe9s comme des meilleures pratiques pour \xe9crire du code propre, robuste et \xe9volutif.","source":"@site/i18n/fr/docusaurus-plugin-content-docs/current/java/1-Core/1-OOP/4-solid-principles.md","sourceDirName":"java/1-Core/1-OOP","slug":"/java/Core/OOP/solid-principles","permalink":"/dev/fr/docs/java/Core/OOP/solid-principles","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"java","permalink":"/dev/fr/docs/tags/java"},{"inline":true,"label":"oop","permalink":"/dev/fr/docs/tags/oop"},{"inline":true,"label":"design patterns","permalink":"/dev/fr/docs/tags/design-patterns"},{"inline":true,"label":"software engineering","permalink":"/dev/fr/docs/tags/software-engineering"}],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Principes SOLID","sidebar_position":4,"tags":["java","oop","design patterns","software engineering"]},"sidebar":"tutorialSidebar","previous":{"title":"Composition plut\xf4t qu\'h\xe9ritage","permalink":"/dev/fr/docs/java/Core/OOP/composition-inheritance"},"next":{"title":"\xc9galit\xe9 des Objets - equals() et hashCode()","permalink":"/dev/fr/docs/java/Core/OOP/object-equality"}}');var s=r(4848),t=r(8453);const l={title:"Principes SOLID",sidebar_position:4,tags:["java","oop","design patterns","software engineering"]},a=void 0,o={},c=[{value:"1. Principe de Responsabilit\xe9 Unique (SRP)",id:"1-principe-de-responsabilit\xe9-unique-srp",level:3},{value:"2. Principe Ouvert/Ferm\xe9 (OCP)",id:"2-principe-ouvertferm\xe9-ocp",level:3},{value:"3. Principe de Substitution de Liskov (LSP)",id:"3-principe-de-substitution-de-liskov-lsp",level:3},{value:"4. Principe de S\xe9gr\xe9gation des Interfaces (ISP)",id:"4-principe-de-s\xe9gr\xe9gation-des-interfaces-isp",level:3},{value:"5. Principe d&#39;Inversion de D\xe9pendances (DIP)",id:"5-principe-dinversion-de-d\xe9pendances-dip",level:3}];function d(e){const n={code:"code",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Les principes SOLID sont un ensemble de cinq principes de conception en programmation orient\xe9e objet, destin\xe9s \xe0 rendre les conceptions logicielles plus compr\xe9hensibles, flexibles et maintenables. Ils ont \xe9t\xe9 promus par Robert C. Martin (Uncle Bob) et sont largement consid\xe9r\xe9s comme des meilleures pratiques pour \xe9crire du code propre, robuste et \xe9volutif."}),"\n",(0,s.jsx)(n.p,{children:"Chaque lettre de SOLID repr\xe9sente un principe :"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"S"})," - Principe de Responsabilit\xe9 Unique (Single Responsibility Principle)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"O"})," - Principe Ouvert/Ferm\xe9 (Open/Closed Principle)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"L"})," - Principe de Substitution de Liskov (Liskov Substitution Principle)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"I"})," - Principe de S\xe9gr\xe9gation des Interfaces (Interface Segregation Principle)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"D"})," - Principe d'Inversion de D\xe9pendances (Dependency Inversion Principle)"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"1-principe-de-responsabilit\xe9-unique-srp",children:"1. Principe de Responsabilit\xe9 Unique (SRP)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"D\xe9finition :"})," Une classe ne devrait avoir qu'une seule raison de changer. Cela signifie qu'une classe devrait avoir une, et une seule, responsabilit\xe9 principale."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Explication :"})," Ce principe vise \xe0 emp\xeacher une classe de devenir un \"objet Dieu\" qui g\xe8re trop de pr\xe9occupations non li\xe9es. Lorsqu'une classe a plusieurs responsabilit\xe9s, les modifications apport\xe9es \xe0 l'une d'elles peuvent par inadvertance affecter les autres, entra\xeenant des bugs et rendant la classe plus difficile \xe0 comprendre et \xe0 maintenir. S\xe9parer les pr\xe9occupations signifie que chaque classe se concentre sur une t\xe2che sp\xe9cifique."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Avantages :"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Couplage r\xe9duit :"})," Les classes sont moins d\xe9pendantes les unes des autres."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Maintenabilit\xe9 am\xe9lior\xe9e :"})," Les changements li\xe9s \xe0 une responsabilit\xe9 sont isol\xe9s dans une seule classe."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Lisibilit\xe9 accrue :"})," L'objectif de chaque classe est clair."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Tests plus faciles :"})," Les classes plus petites et cibl\xe9es sont plus faciles \xe0 tester."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Exemple (Non-respect vs. Respect) :"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Non-respect (Une seule classe g\xe8re plusieurs responsabilit\xe9s) :"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'// Anti-patron : UserProfile g\xe8re les donn\xe9es utilisateur ET les op\xe9rations de base de donn\xe9es\r\nclass UserProfile {\r\n    private String username;\r\n    private String email;\r\n\r\n    public UserProfile(String username, String email) {\r\n        this.username = username;\r\n        this.email = email;\r\n    }\r\n\r\n    // Responsabilit\xe9 1 : Gestion des donn\xe9es utilisateur\r\n    public String getUsername() { return username; }\r\n    public String getEmail() { return email; }\r\n    public void setUsername(String username) { this.username = username; }\r\n    public void setEmail(String email) { this.email = email; }\r\n\r\n    // Responsabilit\xe9 2 : Persistance en base de donn\xe9es\r\n    public void saveToDatabase() {\r\n        System.out.println("Saving " + username + " to database...");\r\n        // Logique pour sauvegarder l\'utilisateur dans la BD\r\n    }\r\n\r\n    public void loadFromDatabase(String username) {\r\n        System.out.println("Loading " + username + " from database...");\r\n        // Logique pour charger l\'utilisateur depuis la BD et remplir les champs\r\n    }\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Respect (Responsabilit\xe9s s\xe9par\xe9es) :"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'// Responsabilit\xe9 1 : Gestion des donn\xe9es utilisateur\r\nclass User {\r\n    private String username;\r\n    private String email;\r\n\r\n    public User(String username, String email) {\r\n        this.username = username;\r\n        this.email = email;\r\n    }\r\n\r\n    public String getUsername() { return username; }\r\n    public String getgetEmail() { return email; }\r\n    public void setUsername(String username) { this.username = username; }\r\n    public void setEmail(String email) { this.email = email; }\r\n}\r\n\r\n// Responsabilit\xe9 2 : Persistance utilisateur\r\nclass UserRepository {\r\n    public void save(User user) {\r\n        System.out.println("Saving " + user.getUsername() + " to database...");\r\n        // Logique pour sauvegarder l\'utilisateur dans la BD\r\n    }\r\n\r\n    public User load(String username) {\r\n        System.out.println("Loading " + username + " from database...");\r\n        // Logique pour charger l\'utilisateur depuis la BD et retourner l\'objet User\r\n        return new User(username, "loaded@example.com"); // Retour fictif\r\n    }\r\n}\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"2-principe-ouvertferm\xe9-ocp",children:"2. Principe Ouvert/Ferm\xe9 (OCP)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"D\xe9finition :"})," Les entit\xe9s logicielles (classes, modules, fonctions, etc.) devraient \xeatre ouvertes \xe0 l'extension, mais ferm\xe9es \xe0 la modification."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Explication :"})," Cela signifie que vous devriez \xeatre en mesure d'ajouter de nouvelles fonctionnalit\xe9s \xe0 un syst\xe8me sans modifier le code existant qui fonctionne. Lorsque vous modifiez du code existant, vous risquez d'introduire de nouveaux bugs dans des parties du syst\xe8me auparavant stables. L'OCP est souvent r\xe9alis\xe9 par l'utilisation d'interfaces, de classes abstraites et de polymorphisme."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Avantages :"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Stabilit\xe9 :"})," Le code existant reste inchang\xe9, r\xe9duisant le risque de r\xe9gressions."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"\xc9volutivit\xe9 :"})," Plus facile d'ajouter de nouvelles fonctionnalit\xe9s sans casser les anciennes."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Maintenabilit\xe9 :"}),' Moins sujet aux changements par "effet domino".']}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Exemple (Non-respect vs. Respect) :"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Non-respect (Modification du code existant pour une nouvelle fonctionnalit\xe9) :"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"// Anti-patron : N\xe9cessit\xe9 de modifier Calculator \xe0 chaque ajout d'une nouvelle op\xe9ration\r\nclass Calculator {\r\n    public double calculate(char operation, double a, double b) {\r\n        switch (operation) {\r\n            case '+': return a + b;\r\n            case '-': return a - b;\r\n            // Si nous avons besoin d'une op\xe9ration 'multiplier', nous modifions cette classe !\r\n            // case '*': return a * b; // Ceci modifie le code existant\r\n            default: throw new IllegalArgumentException(\"Invalid operation\");\r\n        }\r\n    }\r\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Respect (Extension avec de nouvelles fonctionnalit\xe9s) :"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"// Ouvert \xe0 l'extension : De nouvelles op\xe9rations peuvent \xeatre ajout\xe9es en impl\xe9mentant cette interface\r\ninterface Operation {\r\n    double apply(double a, double b);\r\n}\r\n\r\n// Impl\xe9mentations concr\xe8tes des op\xe9rations\r\nclass AddOperation implements Operation {\r\n    @Override\r\n    public double apply(double a, double b) {\r\n        return a + b;\r\n    }\r\n}\r\n\r\nclass SubtractOperation implements Operation {\r\n    @Override\r\n    public double apply(double a, double b) {\r\n        return a - b;\r\n    }\r\n}\r\n\r\n// Nouvelle fonctionnalit\xe9 ajout\xe9e sans modifier le Calculator existant ou les interfaces Operation\r\nclass MultiplyOperation implements Operation {\r\n    @Override\r\n    public double apply(double a, double b) {\r\n        return a * b;\r\n    }\r\n}\r\n\r\n// Ferm\xe9 \xe0 la modification : La classe Calculator n'a pas besoin de changer\r\nclass BetterCalculator {\r\n    public double calculate(Operation operation, double a, double b) {\r\n        return operation.apply(a, b);\r\n    }\r\n}\r\n\r\n// Utilisation :\r\n// BetterCalculator calc = new BetterCalculator();\r\n// System.out.println(calc.calculate(new AddOperation(), 5, 3)); // 8.0\r\n// System.out.println(calc.calculate(new MultiplyOperation(), 5, 3)); // 15.0\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"3-principe-de-substitution-de-liskov-lsp",children:"3. Principe de Substitution de Liskov (LSP)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"D\xe9finition :"})," Les sous-types doivent \xeatre substituables \xe0 leurs types de base sans alt\xe9rer la correction du programme."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Explication :"})," Ce principe signifie que si un programme utilise une classe de base, il devrait pouvoir utiliser n'importe laquelle de ses sous-classes de mani\xe8re interchangeable sans provoquer d'erreurs ou de comportements inattendus. Il traite principalement du sous-typage comportemental, garantissant que les classes d\xe9riv\xe9es \xe9tendent la fonctionnalit\xe9 de la classe de base sans enfreindre son contrat inh\xe9rent. Une violation courante se produit lorsqu'une sous-classe l\xe8ve une exception inattendue ou fournit une impl\xe9mentation sans op\xe9ration pour une m\xe9thode d\xe9finie dans la super-classe, brisant ainsi le comportement attendu."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Avantages :"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Robustesse :"})," Garantit que le polymorphisme fonctionne de mani\xe8re fiable."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Maintenabilit\xe9 :"})," Pr\xe9vient les effets secondaires inattendus lors de l'utilisation de sous-classes."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Correction :"})," Garantit que le code utilisant les types de base fonctionnera correctement avec les types d\xe9riv\xe9s."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Exemple (Non-respect vs. Respect) :"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Non-respect (Un carr\xe9 n'est pas un substitut parfait pour un rectangle) :"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'// Anti-patron : Square enfreint le contrat de Rectangle\r\nclass Rectangle {\r\n    protected int width;\r\n    protected int height;\r\n\r\n    public void setWidth(int width) { this.width = width; }\r\n    public void setHeight(int height) { this.height = height; }\r\n    public int getArea() { return width * height; }\r\n}\r\n\r\nclass Square extends Rectangle {\r\n    @Override\r\n    public void setWidth(int width) {\r\n        this.width = width;\r\n        this.height = width; // Changer la largeur change aussi la hauteur\r\n    }\r\n    @Override\r\n    public void setHeight(int height) {\r\n        this.width = height; // Changer la hauteur change aussi la largeur\r\n        this.height = height;\r\n    }\r\n}\r\n\r\n// M\xe9thode de test qui attend le comportement de Rectangle\r\nclass TestLSP {\r\n    public static void printArea(Rectangle r) {\r\n        r.setWidth(5);\r\n        r.setHeight(4); // Nous nous attendons \xe0 ce que la surface soit 20\r\n        System.out.println("Expected Area: " + 5 * 4 + ", Actual Area: " + r.getArea());\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        Rectangle rect = new Rectangle();\r\n        printArea(rect); // Attendu : 20, Actuel : 20 (Correct)\r\n\r\n        Rectangle square = new Square();\r\n        printArea(square); // Attendu : 20, Actuel : 16 (Violation ! Square a chang\xe9 la hauteur \xe0 5 apr\xe8s setWidth)\r\n    }\r\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Respect (Meilleure conception pour les formes ou utilisation d'abstractions s\xe9par\xe9es) :"}),"\r\nAu lieu de forcer ",(0,s.jsx)(n.code,{children:"Square"})," dans une relation ",(0,s.jsx)(n.code,{children:"est-un"})," ",(0,s.jsx)(n.code,{children:"Rectangle"})," alors que cela enfreint son contrat, consid\xe9rez :"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Avoir une classe de base abstraite ",(0,s.jsx)(n.code,{children:"Shape"})," avec une m\xe9thode ",(0,s.jsx)(n.code,{children:"getArea()"}),". ",(0,s.jsx)(n.code,{children:"Rectangle"})," et ",(0,s.jsx)(n.code,{children:"Square"})," sont tous deux des ",(0,s.jsx)(n.code,{children:"Shape"}),"s, mais n'h\xe9ritent pas directement l'un de l'autre si leurs comportements entrent en conflit."]}),"\n",(0,s.jsxs)(n.li,{children:["Si l'h\xe9ritage est souhait\xe9, assurez-vous que ",(0,s.jsx)(n.code,{children:"Square"})," ne surcharge pas les m\xe9thodes d'une mani\xe8re qui enfreint le contrat de ",(0,s.jsx)(n.code,{children:"Rectangle"}),". (Souvent, cela signifie que ",(0,s.jsx)(n.code,{children:"Square"})," ne devrait pas h\xe9riter directement de ",(0,s.jsx)(n.code,{children:"Rectangle"})," si ",(0,s.jsx)(n.code,{children:"Rectangle"})," a des setters de largeur/hauteur mutables)."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Un exemple d'adh\xe9rence plus simple :"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'interface Flyable {\r\n    void fly();\r\n}\r\n\r\nclass Bird implements Flyable {\r\n    @Override\r\n    public void fly() {\r\n        System.out.println("Bird is flying.");\r\n    }\r\n}\r\n\r\nclass Eagle extends Bird { // Eagle est un Bird, et peut voler\r\n    // Surcharge le comportement fly() mais respecte toujours le contrat Flyable\r\n    @Override\r\n    public void fly() {\r\n        System.out.println("Eagle is soaring.");\r\n    }\r\n}\r\n\r\n// Exemple de violation (si Penguin impl\xe9mente Flyable mais ne peut pas voler) :\r\n// class Penguin implements Flyable {\r\n//     @Override\r\n//     public void fly() {\r\n//         throw new UnsupportedOperationException("Penguins cannot fly!"); // Enfreint le LSP\r\n//     }\r\n// }\r\n\r\n// Mani\xe8re correcte pour Penguin (ne pas le forcer \xe0 impl\xe9menter Flyable)\r\nclass Penguin {\r\n    public void swim() {\r\n        System.out.println("Penguin is swimming.");\r\n    }\r\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Le LSP sugg\xe8re que ",(0,s.jsx)(n.code,{children:"Penguin"})," ne devrait pas impl\xe9menter ",(0,s.jsx)(n.code,{children:"Flyable"})," s'il ne peut pas r\xe9ellement voler, car cela briserait l'attente de tout code s'attendant \xe0 ce qu'un objet ",(0,s.jsx)(n.code,{children:"Flyable"})," soit capable de voler."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"4-principe-de-s\xe9gr\xe9gation-des-interfaces-isp",children:"4. Principe de S\xe9gr\xe9gation des Interfaces (ISP)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"D\xe9finition :"})," Les clients ne devraient pas \xeatre forc\xe9s de d\xe9pendre d'interfaces qu'ils n'utilisent pas. Plut\xf4t qu'une seule grande interface, de nombreuses interfaces plus petites et sp\xe9cifiques au client sont pr\xe9f\xe9rables."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Explication :"})," Ce principe vise \xe0 d\xe9composer les interfaces \"grasses\" en interfaces plus petites et plus sp\xe9cifiques. Si une interface a trop de m\xe9thodes, certaines classes l'impl\xe9mentant pourraient n'avoir besoin que d'un sous-ensemble de ces m\xe9thodes, \xe9tant forc\xe9es d'en impl\xe9menter d'autres qu'elles n'utilisent pas (souvent sous forme de m\xe9thodes vides ou levant des exceptions). La s\xe9gr\xe9gation des interfaces garantit qu'une classe ne d\xe9pend que des m\xe9thodes dont elle a r\xe9ellement besoin."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Avantages :"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Couplage r\xe9duit :"})," Les classes ne sont coupl\xe9es qu'aux interfaces qu'elles utilisent r\xe9ellement."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Maintenabilit\xe9 am\xe9lior\xe9e :"})," Plus facile de modifier ou de refactoriser les interfaces."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Flexibilit\xe9 accrue :"})," Plus facile d'impl\xe9menter uniquement les comportements n\xe9cessaires."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Exemple (Non-respect vs. Respect) :"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:'Non-respect (Une seule interface "grasse") :'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"// Anti-patron : Interface Worker polyvalente\r\ninterface Worker {\r\n    void work();\r\n    void eat();\r\n    void sleep(); // Tous les travailleurs n'ont pas forc\xe9ment besoin de \"dormir\" dans un contexte computationnel\r\n    void manage(); // Tous les travailleurs ne sont pas des managers\r\n}\r\n\r\nclass HumanWorker implements Worker {\r\n    @Override public void work() { /* ... */ }\r\n    @Override public void eat() { /* ... */ }\r\n    @Override public void sleep() { /* ... */ }\r\n    @Override public void manage() { /* ... */ } // Les travailleurs humains peuvent g\xe9rer\r\n}\r\n\r\nclass RobotWorker implements Worker {\r\n    @Override public void work() { /* ... */ }\r\n    @Override public void eat() { /* Le robot ne mange pas */ } // Forc\xe9 d'impl\xe9menter\r\n    @Override public void sleep() { /* Le robot ne dort pas */ } // Forc\xe9 d'impl\xe9menter\r\n    @Override public void manage() { /* Le robot ne g\xe8re pas */ } // Forc\xe9 d'impl\xe9menter\r\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Respect (Interfaces s\xe9gr\xe9gu\xe9es) :"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'// Interfaces plus petites et sp\xe9cifiques\r\ninterface Workable {\r\n    void work();\r\n}\r\n\r\ninterface Eatable {\r\n    void eat();\r\n}\r\n\r\ninterface Sleepable {\r\n    void sleep();\r\n}\r\n\r\ninterface Manageable {\r\n    void manage();\r\n}\r\n\r\nclass HumanWorker implements Workable, Eatable, Sleepable, Manageable {\r\n    @Override public void work() { System.out.println("Human working."); }\r\n    @Override public void eat() { System.out.println("Human eating."); }\r\n    @Override public void sleep() { System.out.println("Human sleeping."); }\r\n    @Override public void manage() { System.out.println("Human managing."); }\r\n}\r\n\r\nclass RobotWorker implements Workable { // N\'impl\xe9mente que ce dont il a besoin\r\n    @Override public void work() { System.out.println("Robot working."); }\r\n}\r\n\r\n// Si un robot pouvait aussi \xeatre g\xe9rable :\r\n// class ManagerRobot implements Workable, Manageable {\r\n//     @Override public void work() { System.out.println("Manager robot working."); }\r\n//     @Override public void manage() { System.out.println("Manager robot managing."); }\r\n// }\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"5-principe-dinversion-de-d\xe9pendances-dip",children:"5. Principe d'Inversion de D\xe9pendances (DIP)"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"D\xe9finition :"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Les modules de haut niveau ne devraient pas d\xe9pendre des modules de bas niveau. Tous deux devraient d\xe9pendre d'abstractions."}),"\n",(0,s.jsx)(n.li,{children:"Les abstractions ne devraient pas d\xe9pendre des d\xe9tails. Les d\xe9tails devraient d\xe9pendre des abstractions."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Explication :"})," Ce principe promeut le d\xe9couplage des modules logiciels. Au lieu qu'un module de haut niveau (qui contient une logique complexe) d\xe9pende directement d'un module de bas niveau (qui g\xe8re des t\xe2ches sp\xe9cifiques comme l'acc\xe8s \xe0 la base de donn\xe9es ou le contr\xf4le mat\xe9riel), les deux devraient d\xe9pendre d'une abstraction (une interface ou une classe abstraite). Cela permet un \xe9change plus facile des impl\xe9mentations et rend le syst\xe8me plus testable et flexible."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Avantages :"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Couplage faible :"})," Les modules de haut niveau et de bas niveau ne sont pas directement connect\xe9s."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Flexibilit\xe9 accrue :"})," Facile de changer les impl\xe9mentations de bas niveau sans affecter la logique de haut niveau."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Tests plus faciles :"})," Les d\xe9pendances de bas niveau peuvent \xeatre mock\xe9es ou simul\xe9es pour les tests unitaires."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Exemple (Non-respect vs. Respect) :"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Non-respect (Le module de haut niveau d\xe9pend d'un module concret de bas niveau) :"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'// Anti-patron : LightSwitch d\xe9pend directement d\'une impl\xe9mentation sp\xe9cifique de LightBulb\r\nclass LightBulb { // Module de bas niveau (d\xe9tail)\r\n    public void turnOn() { System.out.println("LightBulb: On"); }\r\n    public void turnOff() { System.out.println("LightBulb: Off"); }\r\n}\r\n\r\nclass LightSwitch { // Module de haut niveau (logique)\r\n    private LightBulb bulb; // D\xe9pendance directe \xe0 une classe concr\xe8te\r\n\r\n    public LightSwitch() {\r\n        this.bulb = new LightBulb(); // Fortement coupl\xe9 : LightSwitch cr\xe9e sa propre LightBulb\r\n    }\r\n\r\n    public void press() {\r\n        // Logique pour d\xe9cider d\'allumer ou d\'\xe9teindre\r\n        // Pour la simplicit\xe9, faisons simplement basculer\r\n        if (bulb.isOn()) { // En supposant une m\xe9thode isOn()\r\n            bulb.turnOff();\r\n        } else {\r\n            bulb.turnOn();\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Respect (Les deux d\xe9pendent d'une abstraction) :"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'// Abstraction (interface)\r\ninterface Switchable {\r\n    void turnOn();\r\n    void turnOff();\r\n    boolean isOn(); // Supposons une m\xe9thode isOn pour l\'\xe9tat\r\n}\r\n\r\n// Module de bas niveau (d\xe9tails) d\xe9pendent de l\'abstraction\r\nclass LightBulb implements Switchable {\r\n    private boolean on = false;\r\n    @Override public void turnOn() { System.out.println("LightBulb: On"); on = true; }\r\n    @Override public void turnOff() { System.out.println("LightBulb: Off"); on = false; }\r\n    @Override public boolean isOn() { return on; }\r\n}\r\n\r\nclass Fan implements Switchable { // Un autre d\xe9tail de bas niveau\r\n    private boolean on = false;\r\n    @Override public void turnOn() { System.out.println("Fan: On"); on = true; }\r\n    @Override public void turnOff() { System.out.println("Fan: Off"); on = false; }\r\n    @Override public boolean isOn() { return on; }\r\n}\r\n\r\n// Module de haut niveau (logique) d\xe9pend de l\'abstraction\r\nclass Button {\r\n    private Switchable device; // D\xe9pend de l\'abstraction\r\n\r\n    // Injection de D\xe9pendances : Le p\xe9riph\xe9rique Switchable est inject\xe9 (fourni de l\'ext\xe9rieur)\r\n    public Button(Switchable device) {\r\n        this.device = device;\r\n    }\r\n\r\n    public void press() {\r\n        if (device.isOn()) {\r\n            device.turnOff();\r\n        } else {\r\n            device.turnOn();\r\n        }\r\n    }\r\n}\r\n\r\n// Utilisation :\r\n// Button lightButton = new Button(new LightBulb()); // Injecter LightBulb\r\n// lightButton.press(); // LightBulb: On\r\n// lightButton.press(); // LightBulb: Off\r\n\r\n// Button fanButton = new Button(new Fan()); // Injecter Fan\r\n// fanButton.press(); // Fan: On\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Dans l'exemple de respect, le ",(0,s.jsx)(n.code,{children:"Button"})," (haut niveau) ne conna\xeet pas et ne se soucie pas du type concret du p\xe9riph\xe9rique ",(0,s.jsx)(n.code,{children:"Switchable"})," qu'il contr\xf4le. Il op\xe8re purement sur l'interface ",(0,s.jsx)(n.code,{children:"Switchable"}),", ce qui le rend tr\xe8s flexible. Vous pouvez connecter un ",(0,s.jsx)(n.code,{children:"Button"})," \xe0 une ",(0,s.jsx)(n.code,{children:"LightBulb"}),", un ",(0,s.jsx)(n.code,{children:"Fan"}),", ou tout autre p\xe9riph\xe9rique ",(0,s.jsx)(n.code,{children:"Switchable"})," sans modifier la classe ",(0,s.jsx)(n.code,{children:"Button"}),". C'est \xe9galement la base des frameworks d'injection de d\xe9pendances."]})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>a});var i=r(6540);const s={},t=i.createContext(s);function l(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);