"use strict";(self.webpackChunkmydevdocs=self.webpackChunkmydevdocs||[]).push([[4286],{1356:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"Angular/Observable/observables-vs-fetch","title":"observables-vs-fetch","description":"Observables vs. Fetch (Promises)","source":"@site/docs/Angular/Observable/observables-vs-fetch.md","sourceDirName":"Angular/Observable","slug":"/Angular/Observable/observables-vs-fetch","permalink":"/dev/fr/docs/Angular/Observable/observables-vs-fetch","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Microservices Architecture","permalink":"/dev/fr/docs/tech-related/microservices-architecture"},"next":{"title":"Observables in Angular","permalink":"/dev/fr/docs/Angular/Observable/observables"}}');var t=n(4848),i=n(8453);const o={},a=void 0,l={},c=[{value:"Observables vs. Fetch (Promises)",id:"observables-vs-fetch-promises",level:2},{value:"1. Number of Values (Streams vs. Single Shot)",id:"1-number-of-values-streams-vs-single-shot",level:3},{value:"2. Laziness vs. Eagerness",id:"2-laziness-vs-eagerness",level:3},{value:"3. Cancellability / Unsubscription",id:"3-cancellability--unsubscription",level:3},{value:"4. Rich Set of Operators",id:"4-rich-set-of-operators",level:3},{value:"5. Error Handling",id:"5-error-handling",level:3},{value:"6. Integration with Angular",id:"6-integration-with-angular",level:3},{value:"When might <code>fetch</code> (or Promises) still be useful?",id:"when-might-fetch-or-promises-still-be-useful",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const r={code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.h2,{id:"observables-vs-fetch-promises",children:"Observables vs. Fetch (Promises)"}),"\n",(0,t.jsx)(r.h3,{id:"1-number-of-values-streams-vs-single-shot",children:"1. Number of Values (Streams vs. Single Shot)"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsxs)(r.strong,{children:[(0,t.jsx)(r.code,{children:"fetch"})," (Promises):"]})," Represent a single future value. Once a Promise resolves (or rejects), it's done. You get one result (or one error) and then the Promise lifecycle is complete."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"fetch('/api/data')\r\n  .then(response => response.json())\r\n  .then(data => console.log(data)) // Get data once\r\n  .catch(error => console.error(error));\n"})}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Observables:"})," Represent a stream of zero, one, or ",(0,t.jsx)(r.em,{children:"multiple"})," values over time. They are ideal for situations where data might arrive continuously or in batches (e.g., real-time data, user input events, multiple API responses over time)."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-typescript",children:"// In Angular's HttpClient, it returns an Observable\r\nthis.http.get('/api/data').subscribe(data => {\r\n  console.log(data); // Can potentially receive multiple updates if it were a websocket\r\n                           // Or for HTTP, it's typically one value then completes\r\n});\r\n\r\n// More typical stream example: button clicks\r\nimport { fromEvent } from 'rxjs';\r\nconst clicks = fromEvent(document, 'click');\r\nclicks.subscribe(event => console.log('Clicked!', event)); // Logs every click\n"})}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Why this matters:"})," While an ",(0,t.jsx)(r.code,{children:"HttpClient"})," ",(0,t.jsx)(r.code,{children:"GET"})," request typically emits only one value (the response) and then completes, the ",(0,t.jsx)(r.em,{children:"ability"})," to handle multiple values is crucial for other scenarios within Angular (e.g., ",(0,t.jsx)(r.code,{children:"router.events"}),", ",(0,t.jsx)(r.code,{children:"form.valueChanges"}),", ",(0,t.jsx)(r.code,{children:"ngrx"})," state updates, WebSockets). By using a single paradigm (Observables) for all asynchronous operations, the codebase becomes more consistent and easier to reason about."]}),"\n",(0,t.jsx)(r.h3,{id:"2-laziness-vs-eagerness",children:"2. Laziness vs. Eagerness"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsxs)(r.strong,{children:[(0,t.jsx)(r.code,{children:"fetch"})," (Promises):"]}),' Are "eager." As soon as you define a Promise, the operation it encapsulates starts executing.']}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"const myPromise = new Promise(resolve => {\r\n  console.log('Promise is starting!'); // This logs immediately when `myPromise` is defined\r\n  setTimeout(() => resolve('Data'), 1000);\r\n});\r\n// The operation has already begun!\n"})}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Observables:"}),' Are "lazy." They don\'t start executing until someone ',(0,t.jsx)(r.code,{children:"subscribes"})," to them. If no one subscribes, nothing happens. This is incredibly powerful for performance and control."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-typescript",children:"import { of } from 'rxjs';\r\nconst myObservable = of('Data'); // Nothing happens yet\r\nconsole.log('Observable defined, but not yet subscribed');\r\nmyObservable.subscribe(data => console.log(data)); // Now it executes\n"})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Why this matters:"})}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Performance:"})," You don't perform unnecessary work (e.g., making an API call) if the result isn't needed by any component."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Control:"})," You have precise control over when the operation starts."]}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"3-cancellability--unsubscription",children:"3. Cancellability / Unsubscription"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsxs)(r.strong,{children:[(0,t.jsx)(r.code,{children:"fetch"})," (Promises):"]})," By default, Promises are not cancellable. Once an HTTP request is initiated via ",(0,t.jsx)(r.code,{children:"fetch"}),", it will run to completion (succeed or fail), even if the component that initiated it is destroyed or the user navigates away. While you can use ",(0,t.jsx)(r.code,{children:"AbortController"})," with ",(0,t.jsx)(r.code,{children:"fetch"})," to introduce cancellability, it's an imperative extra step."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"const controller = new AbortController();\r\nconst signal = controller.signal;\r\nfetch('/api/data', { signal })\r\n  .then(response => response.json())\r\n  .then(data => console.log(data))\r\n  .catch(error => {\r\n    if (error.name === 'AbortError') {\r\n      console.log('Fetch aborted');\r\n    } else {\r\n      console.error('Fetch error:', error);\r\n    }\r\n  });\r\n// Later...\r\ncontroller.abort(); // Manually abort\n"})}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Observables:"})," Are inherently cancellable through the ",(0,t.jsx)(r.code,{children:"unsubscribe()"})," method. When a component is destroyed, you can ",(0,t.jsx)(r.code,{children:"unsubscribe"})," from ongoing Observable streams, preventing memory leaks, unwanted side effects, and race conditions (where an old, slow request might return after a new, faster one, leading to stale data being displayed). Angular components often use operators like ",(0,t.jsx)(r.code,{children:"takeUntil"})," or ",(0,t.jsx)(r.code,{children:"async"})," pipe which handle unsubscription automatically."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-typescript",children:"import { Component, OnDestroy, OnInit } from '@angular/core';\r\nimport { HttpClient } from '@angular/common/http';\r\nimport { Subject } from 'rxjs';\r\nimport { takeUntil } from 'rxjs/operators';\r\n\r\n@Component({ /* ... */ })\r\nexport class MyComponent implements OnInit, OnDestroy {\r\n  private destroy$ = new Subject<void>();\r\n\r\n  constructor(private http: HttpClient) {}\r\n\r\n  ngOnInit() {\r\n    this.http.get('/api/data').pipe(\r\n      takeUntil(this.destroy$) // Automatically unsubscribe when destroy$ emits\r\n    ).subscribe(data => {\r\n      console.log(data);\r\n    });\r\n  }\r\n\r\n  ngOnDestroy() {\r\n    this.destroy$.next(); // Emit a value to complete the observable\r\n    this.destroy$.complete(); // Complete the subject\r\n  }\r\n}\n"})}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Why this matters:"})," Critical for Single Page Applications (SPAs) like Angular apps, where components are constantly being created and destroyed. Without proper unsubscription, you risk:"]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Memory Leaks:"})," Subscriptions that are never cleaned up."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Race Conditions:"})," Old data overwriting new data."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Unnecessary Work:"})," API calls continuing even when their results are no longer relevant."]}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"4-rich-set-of-operators",children:"4. Rich Set of Operators"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsxs)(r.strong,{children:[(0,t.jsx)(r.code,{children:"fetch"})," (Promises):"]})," Primarily use ",(0,t.jsx)(r.code,{children:"then()"})," for chaining and ",(0,t.jsx)(r.code,{children:"catch()"})," for error handling. Any complex data transformation, filtering, debouncing, or combining of multiple requests requires writing manual imperative code."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"fetch('/api/users')\r\n  .then(res => res.json())\r\n  .then(users => {\r\n    const activeUsers = users.filter(user => user.isActive);\r\n    return fetch(`/api/user-details/${activeUsers[0].id}`); // Chaining\r\n  })\r\n  .then(res => res.json())\r\n  .then(details => console.log(details));\n"})}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Observables:"})," Come with a vast library of powerful operators (RxJS) for transforming, filtering, combining, throttling, debouncing, and handling errors in a declarative and composable way. This is arguably the biggest advantage."]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Transformation:"})," ",(0,t.jsx)(r.code,{children:"map"}),", ",(0,t.jsx)(r.code,{children:"pluck"}),", ",(0,t.jsx)(r.code,{children:"switchMap"}),", ",(0,t.jsx)(r.code,{children:"mergeMap"}),", ",(0,t.jsx)(r.code,{children:"concatMap"}),", ",(0,t.jsx)(r.code,{children:"exhaustMap"})]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Filtering:"})," ",(0,t.jsx)(r.code,{children:"filter"}),", ",(0,t.jsx)(r.code,{children:"take"}),", ",(0,t.jsx)(r.code,{children:"takeUntil"}),", ",(0,t.jsx)(r.code,{children:"debounceTime"}),", ",(0,t.jsx)(r.code,{children:"throttleTime"})]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Combination:"})," ",(0,t.jsx)(r.code,{children:"forkJoin"}),", ",(0,t.jsx)(r.code,{children:"combineLatest"}),", ",(0,t.jsx)(r.code,{children:"merge"}),", ",(0,t.jsx)(r.code,{children:"zip"})]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Error Handling:"})," ",(0,t.jsx)(r.code,{children:"catchError"}),", ",(0,t.jsx)(r.code,{children:"retry"}),", ",(0,t.jsx)(r.code,{children:"retryWhen"})]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Debugging:"})," ",(0,t.jsx)(r.code,{children:"tap"})]}),"\n",(0,t.jsx)(r.li,{children:"And many more!"}),"\n"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-typescript",children:"import { HttpClient } from '@angular/common/http';\r\nimport { fromEvent, forkJoin } from 'rxjs';\r\nimport { map, filter, debounceTime, switchMap, catchError } from 'rxjs/operators';\r\nimport { of } from 'rxjs';\r\n\r\n// Example 1: Typeahead search\r\nconst searchInput = document.getElementById('search-box') as HTMLInputElement;\r\nfromEvent(searchInput, 'keyup').pipe(\r\n  map((event: any) => event.target.value),\r\n  debounceTime(300), // Wait 300ms after last keystroke\r\n  filter(text => text.length > 2), // Only search if input > 2 chars\r\n  switchMap(searchTerm => this.http.get(`/api/search?q=${searchTerm}`).pipe(\r\n    catchError(error => {\r\n      console.error('Search error', error);\r\n      return of([]); // Return empty array on error\r\n    })\r\n  ))\r\n).subscribe(results => console.log(results));\r\n\r\n// Example 2: Combine multiple API calls in parallel\r\nforkJoin([\r\n  this.http.get('/api/users'),\r\n  this.http.get('/api/products')\r\n]).subscribe(([users, products]) => {\r\n  console.log('Users:', users);\r\n  console.log('Products:', products);\r\n});\n"})}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Why this matters:"})," Operators enable highly complex asynchronous logic to be expressed concisely and declaratively. They promote functional programming principles and make code much easier to read, test, and maintain."]}),"\n",(0,t.jsx)(r.h3,{id:"5-error-handling",children:"5. Error Handling"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsxs)(r.strong,{children:[(0,t.jsx)(r.code,{children:"fetch"})," (Promises):"]})," Errors are typically handled with a single ",(0,t.jsx)(r.code,{children:".catch()"})," block at the end of a chain."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"fetch('/api/data')\r\n  .then(response => {\r\n    if (!response.ok) { // Fetch only catches network errors, not HTTP errors (404, 500)\r\n      throw new Error(`HTTP error! Status: ${response.status}`);\r\n    }\r\n    return response.json();\r\n  })\r\n  .then(data => console.log(data))\r\n  .catch(error => console.error('Caught an error:', error));\n"})}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Observables:"})," Error handling is integrated into the stream. Operators like ",(0,t.jsx)(r.code,{children:"catchError"})," allow you to intercept errors within the stream, potentially recover from them, log them, or re-throw them, all while maintaining the flow of the stream."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-typescript",children:"import { catchError } from 'rxjs/operators';\r\nimport { throwError, of } from 'rxjs';\r\n\r\nthis.http.get('/api/invalid-url').pipe(\r\n  catchError(error => {\r\n    console.error('API call failed:', error);\r\n    // You can return a new observable, throw a new error, or return an empty observable\r\n    return throwError(() => new Error('Something bad happened; please try again later.'));\r\n    // Or to recover: return of([]); // Return an empty array to allow the stream to complete normally\r\n  })\r\n).subscribe(\r\n  data => console.log(data),\r\n  error => console.log('Subscription error:', error.message) // This catches the new thrown error\r\n);\n"})}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Why this matters:"})," More granular and flexible error handling. You can implement sophisticated error recovery strategies (e.g., retrying specific requests) directly within the Observable pipeline."]}),"\n",(0,t.jsx)(r.h3,{id:"6-integration-with-angular",children:"6. Integration with Angular"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsxs)(r.strong,{children:[(0,t.jsx)(r.code,{children:"fetch"})," (Promises):"]})," While you ",(0,t.jsx)(r.em,{children:"could"})," use ",(0,t.jsx)(r.code,{children:"fetch"})," directly in Angular, it's not the idiomatic way. You'd lose out on Angular's ",(0,t.jsx)(r.code,{children:"HttpClient"})," features (interceptors, testing utilities) and the benefits of the RxJS ecosystem."]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Observables:"})," Angular's ",(0,t.jsx)(r.code,{children:"HttpClient"})," returns Observables by default. Reactive Forms (",(0,t.jsx)(r.code,{children:"valueChanges"}),"), Router events (",(0,t.jsx)(r.code,{children:"router.events"}),"), and many other parts of the Angular framework are built upon Observables. The ",(0,t.jsx)(r.code,{children:"async"})," pipe in templates automatically subscribes and unsubscribes from Observables."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-html",children:'\x3c!-- In your component template --\x3e\r\n<div *ngIf="data$ | async as data">\r\n  {{ data.message }}\r\n</div>\n'})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-typescript",children:"// In your component class\r\nimport { Observable } from 'rxjs';\r\nimport { HttpClient } from '@angular/common/http';\r\n\r\nconstructor(private http: HttpClient) {}\r\n\r\ndata$: Observable<any> = this.http.get('/api/some-data');\n"})}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Why this matters:"})," Consistency and leveraging the framework's strengths. Using Observables aligns with Angular's reactive paradigm, making your code more integrated and benefiting from built-in Angular features."]}),"\n",(0,t.jsx)(r.hr,{}),"\n",(0,t.jsxs)(r.h2,{id:"when-might-fetch-or-promises-still-be-useful",children:["When might ",(0,t.jsx)(r.code,{children:"fetch"})," (or Promises) still be useful?"]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Simple, non-Angular JavaScript contexts:"})," If you're building a small script or a simple web page where you just need to make a single, isolated API call and don't need the overhead or complexity of RxJS, ",(0,t.jsx)(r.code,{children:"fetch"})," is perfectly fine and often preferred for its native simplicity."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Interacting with older libraries:"})," Some legacy codebases or third-party libraries might primarily use Promises."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Specific one-off tasks:"})," For very simple \"fire and forget\" asynchronous tasks that aren't part of a larger data stream and don't require cancellation, a Promise might be slightly more concise."]}),"\n"]}),"\n",(0,t.jsx)(r.hr,{}),"\n",(0,t.jsx)(r.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsxs)(r.p,{children:["While ",(0,t.jsx)(r.code,{children:"fetch"})," and Promises are fundamental JavaScript constructs for handling asynchronous operations, Observables, powered by RxJS, provide a vastly more powerful and expressive way to manage complex asynchronous data streams in Angular. Their ability to handle multiple values, laziness, cancellability, and the rich set of operators make them the preferred choice for building robust, scalable, and reactive Angular applications. By embracing Observables, you align with Angular's core philosophy and gain significant advantages in managing the complexity of modern web UIs."]})]})}function h(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>o,x:()=>a});var s=n(6540);const t={},i=s.createContext(t);function o(e){const r=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(i.Provider,{value:r},e.children)}}}]);