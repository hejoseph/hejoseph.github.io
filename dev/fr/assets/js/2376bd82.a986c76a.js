"use strict";(self.webpackChunkmydevdocs=self.webpackChunkmydevdocs||[]).push([[7365],{8038:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>g,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"Portfolio/Jsonamic/database/indexeddb-persistence","title":"IndexedDB Persistence Layer","description":"Overview","source":"@site/docs/Portfolio/Jsonamic/database/indexeddb-persistence.md","sourceDirName":"Portfolio/Jsonamic/database","slug":"/Portfolio/Jsonamic/database/indexeddb-persistence","permalink":"/dev/fr/docs/Portfolio/Jsonamic/database/indexeddb-persistence","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"State Management System","permalink":"/dev/fr/docs/Portfolio/Jsonamic/contexts/state-management"},"next":{"title":"Dynamic JSON Visualizer - Complete Documentation Summary","permalink":"/dev/fr/docs/Portfolio/Jsonamic/summary"}}');var i=s(4848),t=s(8453);const a={},l="IndexedDB Persistence Layer",o={},c=[{value:"Overview",id:"overview",level:2},{value:"Database Architecture",id:"database-architecture",level:2},{value:"Database Structure",id:"database-structure",level:3},{value:"Database Initialization (<code>initDB</code>)",id:"database-initialization-initdb",level:3},{value:"JSON Object Storage",id:"json-object-storage",level:2},{value:"Storing Objects (<code>storeJsonObjects</code>)",id:"storing-objects-storejsonobjects",level:3},{value:"Nested Value Access (<code>getNestedValue</code>)",id:"nested-value-access-getnestedvalue",level:3},{value:"Data Retrieval and Manipulation",id:"data-retrieval-and-manipulation",level:2},{value:"Getting All Objects (<code>getAllJsonObjects</code>)",id:"getting-all-objects-getalljsonobjects",level:3},{value:"Flag Management (<code>updateObjectFlag</code>)",id:"flag-management-updateobjectflag",level:3},{value:"Bulk Operations",id:"bulk-operations",level:3},{value:"Flag Type Management",id:"flag-type-management",level:2},{value:"Adding Flag Types (<code>addFlagType</code>)",id:"adding-flag-types-addflagtype",level:3},{value:"Retrieving Flag Types (<code>getAllFlagTypes</code>)",id:"retrieving-flag-types-getallflagtypes",level:3},{value:"Configuration Management",id:"configuration-management",level:2},{value:"Configuration Storage",id:"configuration-storage",level:3},{value:"Getting Configuration (<code>getAppConfig</code>)",id:"getting-configuration-getappconfig",level:3},{value:"Saving Configuration",id:"saving-configuration",level:3},{value:"Key Benefits of IndexedDB",id:"key-benefits-of-indexeddb",level:2},{value:"Offline Capability",id:"offline-capability",level:3},{value:"Performance",id:"performance",level:3},{value:"Storage Capacity",id:"storage-capacity",level:3},{value:"Transaction Safety",id:"transaction-safety",level:3},{value:"Error Handling Patterns",id:"error-handling-patterns",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"indexeddb-persistence-layer",children:"IndexedDB Persistence Layer"})}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"The Dynamic JSON Visualizer uses IndexedDB, a browser-based NoSQL database, to store data locally on the user's device. This enables offline functionality, data persistence between sessions, and eliminates the need for a backend server. The persistence layer manages JSON objects, flag types, and application configuration."}),"\n",(0,i.jsx)(n.h2,{id:"database-architecture",children:"Database Architecture"}),"\n",(0,i.jsx)(n.h3,{id:"database-structure",children:"Database Structure"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const DB_NAME = 'jsonVisualizerDB';\r\nconst DB_VERSION = 1;\r\nconst OBJECT_STORE = 'jsonObjects';\r\nconst FLAGS_STORE = 'flagTypes';\r\nconst CONFIG_STORE = 'appConfig';\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The database contains three ",(0,i.jsx)(n.strong,{children:"object stores"})," (similar to tables in SQL databases):"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"jsonObjects"})})," - Stores the actual JSON data with unique IDs"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"flagTypes"})})," - Stores custom flag definitions (name, color, icon)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"appConfig"})})," - Stores application settings and user preferences"]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"database-initialization-initdb",children:["Database Initialization (",(0,i.jsx)(n.code,{children:"initDB"}),")"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"export const initDB = async () => {\r\n  const db = await openDB(DB_NAME, DB_VERSION, {\r\n    upgrade(db) {\r\n      if (!db.objectStoreNames.contains(OBJECT_STORE)) {\r\n        db.createObjectStore(OBJECT_STORE, { keyPath: '__id' });\r\n      }\r\n      \r\n      if (!db.objectStoreNames.contains(FLAGS_STORE)) {\r\n        db.createObjectStore(FLAGS_STORE, { keyPath: 'id' });\r\n      }\r\n      \r\n      if (!db.objectStoreNames.contains(CONFIG_STORE)) {\r\n        db.createObjectStore(CONFIG_STORE, { keyPath: 'key' });\r\n      }\r\n    },\r\n  });\r\n  \r\n  return db;\r\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"How database initialization works"}),":"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Opens database"})," - Uses the ",(0,i.jsx)(n.code,{children:"idb"})," library wrapper around native IndexedDB"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Version control"})," - Database version determines when upgrades run"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Upgrade function"})," - Only runs when database is first created or version increases"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Object store creation"})," - Creates the three stores with their primary keys:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"jsonObjects"})," uses ",(0,i.jsx)(n.code,{children:"__id"})," as the primary key"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"flagTypes"})," uses ",(0,i.jsx)(n.code,{children:"id"})," as the primary key"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"appConfig"})," uses ",(0,i.jsx)(n.code,{children:"key"})," as the primary key"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Idempotent"})," - Safe to call multiple times; won't recreate existing stores"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"json-object-storage",children:"JSON Object Storage"}),"\n",(0,i.jsxs)(n.h3,{id:"storing-objects-storejsonobjects",children:["Storing Objects (",(0,i.jsx)(n.code,{children:"storeJsonObjects"}),")"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"export const storeJsonObjects = async (objects: JSONObject[], uniqueFields: string[]) => {\r\n  const db = await initDB();\r\n  const tx = db.transaction(OBJECT_STORE, 'readwrite');\r\n  const store = tx.objectStore(OBJECT_STORE);\r\n  \r\n  const existingObjects = await store.getAll();\r\n  const existingMap = new Map(existingObjects.map(obj => [obj.__id, obj]));\r\n  \r\n  const processedIds = new Set<string>();\r\n  let newCount = 0;\r\n  let updatedCount = 0;\r\n  \r\n  for (const obj of objects) {\r\n    let objectId = '';\r\n    \r\n    if (uniqueFields.length > 0) {\r\n      const uniqueValues = uniqueFields\r\n        .map(field => {\r\n          const value = getNestedValue(obj, field);\r\n          return value !== undefined ? String(value) : '';\r\n        })\r\n        .filter(Boolean)\r\n        .join('_');\r\n        \r\n      objectId = uniqueValues || nanoid();\r\n    } else {\r\n      objectId = nanoid();\r\n    }\r\n\r\n    if (processedIds.has(objectId)) {\r\n      continue;\r\n    }\r\n    \r\n    processedIds.add(objectId);\r\n    \r\n    const existingObj = uniqueFields.length > 0 ? existingMap.get(objectId) : null;\r\n    \r\n    if (existingObj) {\r\n      updatedCount++;\r\n    } else {\r\n      newCount++;\r\n    }\r\n    \r\n    const newObj = {\r\n      ...obj,\r\n      __id: objectId,\r\n      __flags: existingObj?.__flags || {}\r\n    };\r\n    \r\n    await store.put(newObj);\r\n  }\r\n  \r\n  await tx.done;\r\n  return { newCount, updatedCount };\r\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Complex ID generation logic"}),":"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Unique field strategy"})," - If unique fields are configured:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Extracts values from specified fields using ",(0,i.jsx)(n.code,{children:"getNestedValue"})]}),"\n",(0,i.jsx)(n.li,{children:"Joins values with underscores to create composite ID"}),"\n",(0,i.jsx)(n.li,{children:"Falls back to random ID if no values found"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Random ID strategy"})," - If no unique fields configured:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Uses ",(0,i.jsx)(n.code,{children:"nanoid()"})," to generate random unique identifier"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Duplicate prevention"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"processedIds"})," Set prevents processing the same ID twice in one batch"]}),"\n",(0,i.jsx)(n.li,{children:"Skips objects that would create duplicate IDs"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Update vs Insert logic"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Checks if object with same ID already exists"}),"\n",(0,i.jsx)(n.li,{children:"Preserves existing flags when updating objects"}),"\n",(0,i.jsx)(n.li,{children:"Tracks counts for user feedback"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Transaction safety"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Uses database transactions for atomic operations"}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"await tx.done"})," ensures all operations complete before returning"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"nested-value-access-getnestedvalue",children:["Nested Value Access (",(0,i.jsx)(n.code,{children:"getNestedValue"}),")"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"export const getNestedValue = (obj: unknown, path: string): unknown => {\r\n  return path.split('.').reduce<unknown>((prev, curr) => {\r\n    if (prev && typeof prev === 'object' && curr in prev) {\r\n      return (prev as Record<string, unknown>)[curr];\r\n    }\r\n    return undefined;\r\n  }, obj);\r\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Purpose"}),": Safely extracts values from nested object paths for ID generation."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Example"}),": For path ",(0,i.jsx)(n.code,{children:'"user.profile.email"'})," and object ",(0,i.jsx)(n.code,{children:'{user: {profile: {email: "test@example.com"}}}'}),", returns ",(0,i.jsx)(n.code,{children:'"test@example.com"'}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"data-retrieval-and-manipulation",children:"Data Retrieval and Manipulation"}),"\n",(0,i.jsxs)(n.h3,{id:"getting-all-objects-getalljsonobjects",children:["Getting All Objects (",(0,i.jsx)(n.code,{children:"getAllJsonObjects"}),")"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"export const getAllJsonObjects = async (): Promise<JSONObject[]> => {\r\n  const db = await initDB();\r\n  return db.getAll(OBJECT_STORE);\r\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Simple retrieval of all stored JSON objects. IndexedDB's ",(0,i.jsx)(n.code,{children:"getAll()"})," is efficient for loading complete datasets."]}),"\n",(0,i.jsxs)(n.h3,{id:"flag-management-updateobjectflag",children:["Flag Management (",(0,i.jsx)(n.code,{children:"updateObjectFlag"}),")"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"export const updateObjectFlag = async (id: string, flagId: string, value: boolean) => {\r\n  const db = await initDB();\r\n  const tx = db.transaction(OBJECT_STORE, 'readwrite');\r\n  const store = tx.objectStore(OBJECT_STORE);\r\n  \r\n  const obj = await store.get(id);\r\n  if (obj) {\r\n    if (!obj.__flags) {\r\n      obj.__flags = {};\r\n    }\r\n    obj.__flags[flagId] = value;\r\n    await store.put(obj);\r\n  }\r\n  \r\n  await tx.done;\r\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Flag update process"}),":"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Retrieves object"})," by ID"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Initializes flags"})," object if it doesn't exist"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Sets flag value"})," (true/false) for the specific flag ID"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Saves updated object"})," back to database"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"bulk-operations",children:"Bulk Operations"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Delete Multiple Objects"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"export const deleteObjects = async (ids: string[]) => {\r\n  const db = await initDB();\r\n  const tx = db.transaction(OBJECT_STORE, 'readwrite');\r\n  const store = tx.objectStore(OBJECT_STORE);\r\n  \r\n  for (const id of ids) {\r\n    await store.delete(id);\r\n  }\r\n  \r\n  await tx.done;\r\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Clear All Data"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"export const clearAllObjects = async () => {\r\n  const db = await initDB();\r\n  const tx = db.transaction(OBJECT_STORE, 'readwrite');\r\n  await tx.objectStore(OBJECT_STORE).clear();\r\n  await tx.done;\r\n};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"flag-type-management",children:"Flag Type Management"}),"\n",(0,i.jsxs)(n.h3,{id:"adding-flag-types-addflagtype",children:["Adding Flag Types (",(0,i.jsx)(n.code,{children:"addFlagType"}),")"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"export const addFlagType = async (name: string, color: string, icon: string): Promise<FlagType> => {\r\n  const db = await initDB();\r\n  const newFlag: FlagType = {\r\n    id: nanoid(),\r\n    name,\r\n    color,\r\n    icon\r\n  };\r\n  \r\n  await db.add(FLAGS_STORE, newFlag);\r\n  return newFlag;\r\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Creates new flag types"})," with:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Random unique ID"}),"\n",(0,i.jsx)(n.li,{children:"User-specified name, color, and icon"}),"\n",(0,i.jsx)(n.li,{children:"Returns the created flag for immediate use"}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"retrieving-flag-types-getallflagtypes",children:["Retrieving Flag Types (",(0,i.jsx)(n.code,{children:"getAllFlagTypes"}),")"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"export const getAllFlagTypes = async (): Promise<FlagType[]> => {\r\n  const db = await initDB();\r\n  try {\r\n    const existingFlags = await db.getAll(FLAGS_STORE);\r\n    return existingFlags;\r\n  } catch (error) {\r\n    console.error('Error getting flag types:', error);\r\n    return [];\r\n  }\r\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Error handling"}),": Returns empty array if database operation fails, preventing application crashes."]}),"\n",(0,i.jsx)(n.h2,{id:"configuration-management",children:"Configuration Management"}),"\n",(0,i.jsx)(n.h3,{id:"configuration-storage",children:"Configuration Storage"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"appConfig"})," store uses a key-value pattern where each setting is stored as:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"{ key: 'settingName', value: actualValue }\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"getting-configuration-getappconfig",children:["Getting Configuration (",(0,i.jsx)(n.code,{children:"getAppConfig"}),")"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"export const getAppConfig = async (): Promise<AppConfig> => {\r\n  const db = await initDB();\r\n  try {\r\n    const uniqueFields = await db.get(CONFIG_STORE, 'uniqueFields');\r\n    const imageField = await db.get(CONFIG_STORE, 'imageField');\r\n    const displayFields = await db.get(CONFIG_STORE, 'displayFields');\r\n    return {\r\n      uniqueFields: uniqueFields?.value || [],\r\n      imageField: imageField?.value || null,\r\n      displayFields: displayFields?.value || []\r\n    };\r\n  } catch (error) {\r\n    console.error('Error getting app config:', error);\r\n    return {\r\n      uniqueFields: [],\r\n      imageField: null,\r\n      displayFields: []\r\n    };\r\n  }\r\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Graceful defaults"}),": Returns sensible default values if configuration doesn't exist or loading fails."]}),"\n",(0,i.jsx)(n.h3,{id:"saving-configuration",children:"Saving Configuration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"export const saveUniqueFields = async (fields: string[]) => {\r\n  const db = await initDB();\r\n  await db.put(CONFIG_STORE, { key: 'uniqueFields', value: fields });\r\n};\r\n\r\nexport const saveImageField = async (field: string | null) => {\r\n  const db = await initDB();\r\n  await db.put(CONFIG_STORE, { key: 'imageField', value: field });\r\n};\r\n\r\nexport const saveDisplayFields = async (fields: string[]) => {\r\n  const db = await initDB();\r\n  await db.put(CONFIG_STORE, { key: 'displayFields', value: fields });\r\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Individual setting updates"}),": Each configuration aspect can be saved independently without affecting others."]}),"\n",(0,i.jsx)(n.h2,{id:"key-benefits-of-indexeddb",children:"Key Benefits of IndexedDB"}),"\n",(0,i.jsx)(n.h3,{id:"offline-capability",children:"Offline Capability"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"No server required"})," - All data stored locally in the browser"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Works offline"})," - Application functions without internet connection"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Session persistence"})," - Data survives browser restarts"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"performance",children:"Performance"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Asynchronous operations"})," - Non-blocking database operations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Indexed access"})," - Fast lookups by primary key"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Bulk operations"})," - Efficient handling of large datasets"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"storage-capacity",children:"Storage Capacity"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Large storage limits"})," - Much larger than localStorage (typically GBs vs MBs)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Structured data"})," - Native support for complex objects"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Type preservation"})," - Maintains JavaScript data types"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"transaction-safety",children:"Transaction Safety"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"ACID properties"})," - Atomic, Consistent, Isolated, Durable operations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Rollback capability"})," - Failed transactions don't corrupt data"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Concurrent access"})," - Safe for multiple tabs/windows"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"error-handling-patterns",children:"Error Handling Patterns"}),"\n",(0,i.jsx)(n.p,{children:"The persistence layer implements consistent error handling:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Try-catch blocks"})," around all database operations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Graceful degradation"})," - Returns sensible defaults on failure"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Error logging"})," - Console errors for debugging"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"User feedback"})," - Some operations trigger toast notifications"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Transaction cleanup"})," - ",(0,i.jsx)(n.code,{children:"await tx.done"})," ensures proper cleanup"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This robust persistence layer enables the application to function as a fully offline-capable JSON data management tool."})]})}function g(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>l});var r=s(6540);const i={},t=r.createContext(i);function a(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);