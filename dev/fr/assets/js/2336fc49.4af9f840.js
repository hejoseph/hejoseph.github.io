"use strict";(self.webpackChunkmydevdocs=self.webpackChunkmydevdocs||[]).push([[3733],{6646:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"Angular/async","title":"When to Use Async in Angular","description":"There are different contexts for \\"async\\" in Angular. Let me explain both async/await and the async pipe:","source":"@site/docs/Angular/async.md","sourceDirName":"Angular","slug":"/Angular/async","permalink":"/dev/fr/docs/Angular/async","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Observables in Angular","permalink":"/dev/fr/docs/Angular/Observable/observables"},"next":{"title":"Interface vs Class in Angular: When and Why","permalink":"/dev/fr/docs/Angular/class-vs-interface"}}');var t=r(4848),i=r(8453);const a={},c="When to Use Async in Angular",l={},d=[{value:"1. Async/Await (JavaScript Feature)",id:"1-asyncawait-javascript-feature",level:2},{value:"When to Use Async/Await:",id:"when-to-use-asyncawait",level:3},{value:"\u2705 <strong>Good Use Cases:</strong>",id:"-good-use-cases",level:4},{value:"\u274c <strong>Avoid Async/Await When:</strong>",id:"-avoid-asyncawait-when",level:4},{value:"2. Async Pipe (Angular Feature)",id:"2-async-pipe-angular-feature",level:2},{value:"When to Use Async Pipe:",id:"when-to-use-async-pipe",level:3},{value:"\u2705 <strong>Always Prefer Async Pipe When:</strong>",id:"-always-prefer-async-pipe-when",level:4},{value:"\u274c <strong>Don&#39;t Use Async Pipe When:</strong>",id:"-dont-use-async-pipe-when",level:4},{value:"Decision Matrix",id:"decision-matrix",level:2},{value:"Best Practices Summary",id:"best-practices-summary",level:2}];function o(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"when-to-use-async-in-angular",children:"When to Use Async in Angular"})}),"\n",(0,t.jsxs)(n.p,{children:['There are different contexts for "async" in Angular. Let me explain both ',(0,t.jsx)(n.strong,{children:"async/await"})," and the ",(0,t.jsx)(n.strong,{children:"async pipe"}),":"]}),"\n",(0,t.jsx)(n.h2,{id:"1-asyncawait-javascript-feature",children:"1. Async/Await (JavaScript Feature)"}),"\n",(0,t.jsx)(n.h3,{id:"when-to-use-asyncawait",children:"When to Use Async/Await:"}),"\n",(0,t.jsxs)(n.h4,{id:"-good-use-cases",children:["\u2705 ",(0,t.jsx)(n.strong,{children:"Good Use Cases:"})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Sequential Operations:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"async ngOnInit() {\r\n  try {\r\n    const user = await this.userService.getUser().toPromise();\r\n    const profile = await this.profileService.getProfile(user.id).toPromise();\r\n    const settings = await this.settingsService.getSettings(profile.id).toPromise();\r\n    \r\n    this.userData = { user, profile, settings };\r\n  } catch (error) {\r\n    console.error('Error loading data:', error);\r\n  }\r\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Simple HTTP Calls with Error Handling:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"async loadData() {\r\n  this.loading = true;\r\n  try {\r\n    const data = await this.dataService.getData().toPromise();\r\n    this.processData(data);\r\n  } catch (error) {\r\n    this.handleError(error);\r\n  } finally {\r\n    this.loading = false;\r\n  }\r\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Form Submission:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"async onSubmit() {\r\n  if (this.form.valid) {\r\n    try {\r\n      this.submitting = true;\r\n      const result = await this.apiService.submitForm(this.form.value).toPromise();\r\n      this.router.navigate(['/success']);\r\n    } catch (error) {\r\n      this.showError(error.message);\r\n    } finally {\r\n      this.submitting = false;\r\n    }\r\n  }\r\n}\n"})}),"\n",(0,t.jsxs)(n.h4,{id:"-avoid-asyncawait-when",children:["\u274c ",(0,t.jsx)(n.strong,{children:"Avoid Async/Await When:"})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Real-time Data Streams:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// DON'T do this\r\nasync ngOnInit() {\r\n  while(true) {\r\n    const data = await this.realtimeService.getData().toPromise();\r\n    // This breaks the stream nature of observables\r\n  }\r\n}\r\n\r\n// DO this instead\r\nngOnInit() {\r\n  this.realtimeService.getData().subscribe(data => {\r\n    this.handleRealtimeData(data);\r\n  });\r\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Multiple Parallel Operations:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// DON'T do this (sequential)\r\nasync loadAllData() {\r\n  const users = await this.userService.getUsers().toPromise();\r\n  const products = await this.productService.getProducts().toPromise();\r\n  const orders = await this.orderService.getOrders().toPromise();\r\n}\r\n\r\n// DO this instead (parallel)\r\nngOnInit() {\r\n  forkJoin({\r\n    users: this.userService.getUsers(),\r\n    products: this.productService.getProducts(),\r\n    orders: this.orderService.getOrders()\r\n  }).subscribe(({ users, products, orders }) => {\r\n    // All requests completed in parallel\r\n  });\r\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"2-async-pipe-angular-feature",children:"2. Async Pipe (Angular Feature)"}),"\n",(0,t.jsx)(n.h3,{id:"when-to-use-async-pipe",children:"When to Use Async Pipe:"}),"\n",(0,t.jsxs)(n.h4,{id:"-always-prefer-async-pipe-when",children:["\u2705 ",(0,t.jsx)(n.strong,{children:"Always Prefer Async Pipe When:"})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Displaying Observable Data:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'@Component({\r\n  template: `\r\n    <div *ngIf="user$ | async as user">\r\n      <h1>{{user.name}}</h1>\r\n      <p>{{user.email}}</p>\r\n    </div>\r\n    \r\n    <ul>\r\n      <li *ngFor="let item of items$ | async">{{item.name}}</li>\r\n    </ul>\r\n  `\r\n})\r\nexport class UserComponent {\r\n  user$ = this.userService.getCurrentUser();\r\n  items$ = this.itemService.getItems();\r\n  \r\n  constructor(\r\n    private userService: UserService,\r\n    private itemService: ItemService\r\n  ) {}\r\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Loading States:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'@Component({\r\n  template: `\r\n    <div *ngIf="loading$ | async">Loading...</div>\r\n    <div *ngIf="error$ | async as error" class="error">{{error}}</div>\r\n    <div *ngFor="let item of data$ | async">{{item.name}}</div>\r\n  `\r\n})\r\nexport class DataComponent {\r\n  data$ = this.dataService.getData();\r\n  loading$ = this.dataService.loading$;\r\n  error$ = this.dataService.error$;\r\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Benefits of Async Pipe:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Automatic subscription/unsubscription"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"No memory leaks"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Cleaner code"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Automatic change detection"})}),"\n"]}),"\n",(0,t.jsxs)(n.h4,{id:"-dont-use-async-pipe-when",children:["\u274c ",(0,t.jsx)(n.strong,{children:"Don't Use Async Pipe When:"})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"You Need to Transform Data in Component:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'// Instead of multiple async pipes\r\n@Component({\r\n  template: `\r\n    <div>Total: {{(data$ | async)?.length}}</div>\r\n    <div>Active: {{(data$ | async)?.filter(item => item.active).length}}</div>\r\n  `\r\n})\r\n\r\n// Do this\r\n@Component({\r\n  template: `\r\n    <div *ngIf="processedData$ | async as data">\r\n      <div>Total: {{data.total}}</div>\r\n      <div>Active: {{data.active}}</div>\r\n    </div>\r\n  `\r\n})\r\nexport class DataComponent {\r\n  processedData$ = this.dataService.getData().pipe(\r\n    map(data => ({\r\n      total: data.length,\r\n      active: data.filter(item => item.active).length,\r\n      items: data\r\n    }))\r\n  );\r\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"decision-matrix",children:"Decision Matrix"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Scenario"}),(0,t.jsx)(n.th,{children:"Use Async/Await"}),(0,t.jsx)(n.th,{children:"Use Async Pipe"}),(0,t.jsx)(n.th,{children:"Use Subscribe"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Display data in template"}),(0,t.jsx)(n.td,{children:"\u274c"}),(0,t.jsx)(n.td,{children:"\u2705"}),(0,t.jsx)(n.td,{children:"\u274c"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Sequential API calls"}),(0,t.jsx)(n.td,{children:"\u2705"}),(0,t.jsx)(n.td,{children:"\u274c"}),(0,t.jsx)(n.td,{children:"\u274c"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Form submission"}),(0,t.jsx)(n.td,{children:"\u2705"}),(0,t.jsx)(n.td,{children:"\u274c"}),(0,t.jsx)(n.td,{children:"\u274c"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Real-time data streams"}),(0,t.jsx)(n.td,{children:"\u274c"}),(0,t.jsx)(n.td,{children:"\u2705"}),(0,t.jsx)(n.td,{children:"\u2705"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Complex data transformation"}),(0,t.jsx)(n.td,{children:"\u274c"}),(0,t.jsx)(n.td,{children:"\u2705 (with operators)"}),(0,t.jsx)(n.td,{children:"\u2705"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"One-time operations"}),(0,t.jsx)(n.td,{children:"\u2705"}),(0,t.jsx)(n.td,{children:"\u274c"}),(0,t.jsx)(n.td,{children:"\u2705"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Component lifecycle dependent"}),(0,t.jsx)(n.td,{children:"\u274c"}),(0,t.jsx)(n.td,{children:"\u2705"}),(0,t.jsx)(n.td,{children:"\u2705 (with unsubscribe)"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"best-practices-summary",children:"Best Practices Summary"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use async pipe for templates"})," - automatic memory management"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use async/await for imperative operations"})," - form submissions, sequential calls"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use observables with operators"})," for complex data transformations"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Avoid mixing patterns"})," - stick to one approach per use case"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Always handle errors"})," regardless of the pattern chosen"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The key is choosing the right tool for the specific use case!"})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>c});var s=r(6540);const t={},i=s.createContext(t);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);