"use strict";(self.webpackChunkmydevdocs=self.webpackChunkmydevdocs||[]).push([[9569],{2464:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>d,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"java/Memory/heap-stack","title":"M\xe9moire Tas vs. Pile","description":"Dans le contexte de la Machine Virtuelle Java (JVM) et du Mod\xe8le de M\xe9moire Java (JMM), le \\"Tas\\" (Heap) et la \\"Pile\\" (Stack) sont deux r\xe9gions de m\xe9moire fondamentales avec des objectifs, des caract\xe9ristiques et des approches de gestion distincts. Comprendre leurs diff\xe9rences est crucial pour saisir la mani\xe8re dont les programmes Java s\'ex\xe9cutent, g\xe8rent la m\xe9moire et traitent les op\xe9rations concurrentes.","source":"@site/i18n/fr/docusaurus-plugin-content-docs/current/java/2-Memory/1-heap-stack.md","sourceDirName":"java/2-Memory","slug":"/java/Memory/heap-stack","permalink":"/dev/fr/docs/java/Memory/heap-stack","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"java","permalink":"/dev/fr/docs/tags/java"},{"inline":true,"label":"jvm","permalink":"/dev/fr/docs/tags/jvm"},{"inline":true,"label":"modele de memoire","permalink":"/dev/fr/docs/tags/modele-de-memoire"},{"inline":true,"label":"tas","permalink":"/dev/fr/docs/tags/tas"},{"inline":true,"label":"pile","permalink":"/dev/fr/docs/tags/pile"},{"inline":true,"label":"ramasse-miettes","permalink":"/dev/fr/docs/tags/ramasse-miettes"}],"version":"current","sidebarPosition":1,"frontMatter":{"title":"M\xe9moire Tas vs. Pile","sidebar_position":1,"tags":["java","jvm","modele de memoire","tas","pile","ramasse-miettes"]},"sidebar":"tutorialSidebar","previous":{"title":"Garbage Collection","permalink":"/dev/fr/docs/java/garbage-collector"},"next":{"title":"Javascript","permalink":"/dev/fr/docs/category/javascript"}}');var l=t(4848),n=t(8453);const i={title:"M\xe9moire Tas vs. Pile",sidebar_position:1,tags:["java","jvm","modele de memoire","tas","pile","ramasse-miettes"]},a=void 0,d={},o=[{value:"1. La Pile (Pile JVM)",id:"1-la-pile-pile-jvm",level:3},{value:"2. Le Tas (Heap)",id:"2-le-tas-heap",level:3},{value:"Principales Diff\xe9rences R\xe9capitul\xe9es",id:"principales-diff\xe9rences-r\xe9capitul\xe9es",level:3},{value:"Interaction entre la Pile et le Tas",id:"interaction-entre-la-pile-et-le-tas",level:3}];function c(e){const s={code:"code",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,n.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(s.p,{children:'Dans le contexte de la Machine Virtuelle Java (JVM) et du Mod\xe8le de M\xe9moire Java (JMM), le "Tas" (Heap) et la "Pile" (Stack) sont deux r\xe9gions de m\xe9moire fondamentales avec des objectifs, des caract\xe9ristiques et des approches de gestion distincts. Comprendre leurs diff\xe9rences est crucial pour saisir la mani\xe8re dont les programmes Java s\'ex\xe9cutent, g\xe8rent la m\xe9moire et traitent les op\xe9rations concurrentes.'}),"\n",(0,l.jsx)(s.h3,{id:"1-la-pile-pile-jvm",children:"1. La Pile (Pile JVM)"}),"\n",(0,l.jsx)(s.p,{children:"Chaque thread s'ex\xe9cutant dans une JVM poss\xe8de sa propre pile d'ex\xe9cution priv\xe9e, appel\xe9e Pile JVM. Cette zone de m\xe9moire est principalement utilis\xe9e pour l'ex\xe9cution des m\xe9thodes Java."}),"\n",(0,l.jsx)(s.p,{children:(0,l.jsx)(s.strong,{children:"Caract\xe9ristiques Cl\xe9s :"})}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Sp\xe9cifique au Thread :"})," Chaque thread dans une application Java poss\xe8de sa propre pile ind\xe9pendante. Cela rend les op\xe9rations sur la pile intrins\xe8quement s\xfbres pour les threads (thread-safe)."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Ex\xe9cution de M\xe9thodes :"})," Lorsqu'une m\xe9thode est invoqu\xe9e, un nouveau ",(0,l.jsx)(s.strong,{children:"cadre"})," est empil\xe9 sur la pile. Lorsque la m\xe9thode se termine, son cadre est d\xe9pil\xe9 de la pile. Cela suit le principe du Dernier Entr\xe9, Premier Sorti (LIFO)."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Contenu d'un Cadre de Pile :"})," Chaque cadre contient :","\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Variables Locales :"})," Variables de types primitifs (par exemple, ",(0,l.jsx)(s.code,{children:"int"}),", ",(0,l.jsx)(s.code,{children:"boolean"}),", ",(0,l.jsx)(s.code,{children:"double"}),") et r\xe9f\xe9rences vers des objets (mais pas les objets eux-m\xeames)."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Pile d'Op\xe9randes :"})," Utilis\xe9e pour les calculs interm\xe9diaires lors de l'\xe9valuation d'expressions."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Donn\xe9es du Cadre (par exemple, Adresse de Retour) :"})," Informations n\xe9cessaires pour rendre le contr\xf4le \xe0 la m\xe9thode appelante."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Gestion Automatique de la M\xe9moire :"})," La m\xe9moire sur la pile est allou\xe9e et d\xe9sallou\xe9e automatiquement par la JVM. Il n'est pas n\xe9cessaire pour le programmeur de g\xe9rer explicitement la m\xe9moire. Cela rend les op\xe9rations sur la pile tr\xe8s rapides."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Taille Limit\xe9e :"})," Les piles ont g\xe9n\xe9ralement une taille relativement petite, fixe ou configurable. Si la pile d'un thread devient trop grande (par exemple, en raison d'une r\xe9cursion profonde sans cas de base), une ",(0,l.jsx)(s.code,{children:"StackOverflowError"})," est lev\xe9e."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Courte Dur\xe9e de Vie :"})," Les donn\xe9es sur la pile n'existent que pendant la dur\xe9e de l'appel de m\xe9thode. Une fois la m\xe9thode termin\xe9e, son cadre et tout son contenu sont supprim\xe9s."]}),"\n"]}),"\n",(0,l.jsx)(s.p,{children:(0,l.jsx)(s.strong,{children:"Exemple :"})}),"\n",(0,l.jsx)(s.pre,{children:(0,l.jsx)(s.code,{className:"language-java",children:"public class StackExample {\r\n    public static void main(String[] args) { // Cadre pour la m\xe9thode main()\r\n        int a = 10; // 'a' est une variable locale stock\xe9e sur la pile\r\n        String s = \"Hello\"; // 's' est une variable de r\xe9f\xe9rence stock\xe9e sur la pile\r\n                             // L'objet String \"Hello\" lui-m\xeame est sur le tas\r\n        \r\n        myMethod(a); // Nouveau cadre pour myMethod() empil\xe9 sur la pile\r\n    } // Le cadre de main() est d\xe9pil\xe9 lorsque la m\xe9thode se termine\r\n\r\n    public static void myMethod(int x) { // Cadre pour myMethod()\r\n        // 'x' est un param\xe8tre de m\xe9thode, stock\xe9 sur la pile\r\n        boolean flag = true; // 'flag' est une variable locale stock\xe9e sur la pile\r\n        \r\n        // ... quelques op\xe9rations\r\n        \r\n    } // Le cadre de myMethod() est d\xe9pil\xe9 lorsque la m\xe9thode se termine\r\n}\n"})}),"\n",(0,l.jsx)(s.h3,{id:"2-le-tas-heap",children:"2. Le Tas (Heap)"}),"\n",(0,l.jsx)(s.p,{children:"Le Tas est la plus grande zone de m\xe9moire de la JVM, et elle est partag\xe9e par tous les threads. C'est l\xe0 que tous les objets (instances de classes) et les tableaux sont allou\xe9s au moment de l'ex\xe9cution."}),"\n",(0,l.jsx)(s.p,{children:(0,l.jsx)(s.strong,{children:"Caract\xe9ristiques Cl\xe9s :"})}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Partag\xe9 par Tous les Threads :"})," Tous les objets cr\xe9\xe9s par n'importe quel thread r\xe9sident sur le tas et sont accessibles par tous les autres threads (sous r\xe9serve des r\xe8gles de visibilit\xe9). C'est pourquoi la m\xe9moire du tas est souvent la source de probl\xe8mes de concurrence tels que les conditions de course si elle n'est pas g\xe9r\xe9e correctement."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Allocation Dynamique de M\xe9moire :"})," Les objets sont allou\xe9s dynamiquement sur le tas \xe0 l'aide du mot-cl\xe9 ",(0,l.jsx)(s.code,{children:"new"}),". La taille de l'objet est d\xe9termin\xe9e au moment de l'ex\xe9cution."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Collecte de D\xe9chets :"})," La m\xe9moire sur le tas est g\xe9r\xe9e par le Ramasse-miettes (Garbage Collector ou GC) de la JVM. Lorsque les objets ne sont plus r\xe9f\xe9renc\xe9s par aucune partie du programme, ils deviennent \xe9ligibles \xe0 la collecte de d\xe9chets, et le GC r\xe9cup\xe8re leur m\xe9moire. Les programmeurs ne d\xe9sallouent pas explicitement la m\xe9moire sur le tas."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Taille Plus Grande :"})," Le tas est g\xe9n\xe9ralement beaucoup plus grand que la pile et peut \xeatre configur\xe9 pour cro\xeetre ou r\xe9tr\xe9cir dynamiquement en fonction des besoins en m\xe9moire. Si le tas manque de m\xe9moire, une ",(0,l.jsx)(s.code,{children:"OutOfMemoryError: Java heap space"})," est lev\xe9e."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Dur\xe9e de Vie Plus Longue :"})," Les objets sur le tas peuvent avoir une dur\xe9e de vie plus longue que les variables de pile. Un objet peut persister tant qu'il existe au moins une r\xe9f\xe9rence active pointant vers lui, quelle que soit la m\xe9thode ou le thread qui l'a cr\xe9\xe9."]}),"\n"]}),"\n",(0,l.jsx)(s.p,{children:(0,l.jsx)(s.strong,{children:"Exemple :"})}),"\n",(0,l.jsx)(s.pre,{children:(0,l.jsx)(s.code,{className:"language-java",children:"public class HeapExample {\r\n    public static void main(String[] args) {\r\n        // 'obj1' est une r\xe9f\xe9rence sur la pile, l'instance r\xe9elle de MyObject est sur le tas\r\n        MyObject obj1 = new MyObject(\"Instance 1\"); \r\n\r\n        // 'arr' est une r\xe9f\xe9rence sur la pile, l'objet tableau r\xe9el est sur le tas\r\n        int[] arr = new int[10];\r\n\r\n        // 'obj2' est une r\xe9f\xe9rence sur la pile, l'instance r\xe9elle de MyObject est sur le tas\r\n        MyObject obj2 = new MyObject(\"Instance 2\"); \r\n\r\n        // obj1 et obj2 (les objets eux-m\xeames) r\xe9sident sur le tas\r\n        // Leurs r\xe9f\xe9rences (obj1, obj2, arr) r\xe9sident sur la pile du thread principal\r\n    }\r\n}\r\n\r\nclass MyObject {\r\n    String name;\r\n    public MyObject(String name) {\r\n        this.name = name;\r\n    }\r\n}\n"})}),"\n",(0,l.jsx)(s.h3,{id:"principales-diff\xe9rences-r\xe9capitul\xe9es",children:"Principales Diff\xe9rences R\xe9capitul\xe9es"}),"\n",(0,l.jsxs)(s.table,{children:[(0,l.jsx)(s.thead,{children:(0,l.jsxs)(s.tr,{children:[(0,l.jsx)(s.th,{style:{textAlign:"left"},children:"Caract\xe9ristique"}),(0,l.jsx)(s.th,{style:{textAlign:"left"},children:"Pile"}),(0,l.jsx)(s.th,{style:{textAlign:"left"},children:"Tas"})]})}),(0,l.jsxs)(s.tbody,{children:[(0,l.jsxs)(s.tr,{children:[(0,l.jsx)(s.td,{style:{textAlign:"left"},children:(0,l.jsx)(s.strong,{children:"Objectif"})}),(0,l.jsx)(s.td,{style:{textAlign:"left"},children:"Ex\xe9cution de m\xe9thodes, stockage de variables locales."}),(0,l.jsx)(s.td,{style:{textAlign:"left"},children:"Stockage d'objets et de tableaux."})]}),(0,l.jsxs)(s.tr,{children:[(0,l.jsx)(s.td,{style:{textAlign:"left"},children:(0,l.jsx)(s.strong,{children:"Ce qu'elle Stocke"})}),(0,l.jsx)(s.td,{style:{textAlign:"left"},children:"Variables locales (primitives), r\xe9f\xe9rences d'objets, param\xe8tres de m\xe9thodes, adresses de retour."}),(0,l.jsx)(s.td,{style:{textAlign:"left"},children:"Tous les objets (instances de classes), tableaux."})]}),(0,l.jsxs)(s.tr,{children:[(0,l.jsx)(s.td,{style:{textAlign:"left"},children:(0,l.jsx)(s.strong,{children:"Gestion M\xe9moire"})}),(0,l.jsx)(s.td,{style:{textAlign:"left"},children:"Automatique (LIFO), par la JVM. Rapide."}),(0,l.jsx)(s.td,{style:{textAlign:"left"},children:"Collecte de d\xe9chets (GC). Plus lent, mais automatique."})]}),(0,l.jsxs)(s.tr,{children:[(0,l.jsx)(s.td,{style:{textAlign:"left"},children:(0,l.jsx)(s.strong,{children:"Acc\xe8s"})}),(0,l.jsx)(s.td,{style:{textAlign:"left"},children:"Priv\xe9 au thread."}),(0,l.jsx)(s.td,{style:{textAlign:"left"},children:"Partag\xe9 entre tous les threads."})]}),(0,l.jsxs)(s.tr,{children:[(0,l.jsx)(s.td,{style:{textAlign:"left"},children:(0,l.jsx)(s.strong,{children:"Dur\xe9e de Vie"})}),(0,l.jsx)(s.td,{style:{textAlign:"left"},children:"Courte (dur\xe9e de l'appel de m\xe9thode)."}),(0,l.jsx)(s.td,{style:{textAlign:"left"},children:"Longue (jusqu'\xe0 ce qu'il ne soit plus r\xe9f\xe9renc\xe9 et GC)."})]}),(0,l.jsxs)(s.tr,{children:[(0,l.jsx)(s.td,{style:{textAlign:"left"},children:(0,l.jsx)(s.strong,{children:"Taille"})}),(0,l.jsx)(s.td,{style:{textAlign:"left"},children:"G\xe9n\xe9ralement plus petite, fixe ou limit\xe9e."}),(0,l.jsx)(s.td,{style:{textAlign:"left"},children:"G\xe9n\xe9ralement plus grande, peut cro\xeetre dynamiquement."})]}),(0,l.jsxs)(s.tr,{children:[(0,l.jsx)(s.td,{style:{textAlign:"left"},children:(0,l.jsx)(s.strong,{children:"Erreur"})}),(0,l.jsx)(s.td,{style:{textAlign:"left"},children:(0,l.jsx)(s.code,{children:"StackOverflowError"})}),(0,l.jsx)(s.td,{style:{textAlign:"left"},children:(0,l.jsx)(s.code,{children:"OutOfMemoryError: Java heap space"})})]}),(0,l.jsxs)(s.tr,{children:[(0,l.jsx)(s.td,{style:{textAlign:"left"},children:(0,l.jsx)(s.strong,{children:"Performance"})}),(0,l.jsx)(s.td,{style:{textAlign:"left"},children:"Allocation/d\xe9sallocation plus rapide."}),(0,l.jsx)(s.td,{style:{textAlign:"left"},children:"Allocation plus lente, le GC peut introduire des pauses."})]})]})]}),"\n",(0,l.jsx)(s.h3,{id:"interaction-entre-la-pile-et-le-tas",children:"Interaction entre la Pile et le Tas"}),"\n",(0,l.jsx)(s.p,{children:"La pile et le tas fonctionnent ensemble de mani\xe8re transparente. Lorsque vous d\xe9clarez un objet :"}),"\n",(0,l.jsx)(s.pre,{children:(0,l.jsx)(s.code,{className:"language-java",children:"MyClass myObject = new MyClass();\n"})}),"\n",(0,l.jsxs)(s.ol,{children:["\n",(0,l.jsxs)(s.li,{children:["La ",(0,l.jsx)(s.strong,{children:"variable de r\xe9f\xe9rence"})," ",(0,l.jsx)(s.code,{children:"myObject"})," (qui contient l'adresse m\xe9moire de l'objet) est stock\xe9e sur la ",(0,l.jsx)(s.strong,{children:"pile"})," du thread en cours d'ex\xe9cution."]}),"\n",(0,l.jsxs)(s.li,{children:["L'",(0,l.jsx)(s.strong,{children:"instance d'objet"})," ",(0,l.jsx)(s.code,{children:"MyClass()"})," elle-m\xeame, ainsi que ses variables d'instance, sont allou\xe9es sur le ",(0,l.jsx)(s.strong,{children:"tas"}),"."]}),"\n"]}),"\n",(0,l.jsxs)(s.p,{children:["Cela permet aux m\xe9thodes sur la pile de manipuler des objets sur le tas en utilisant leurs r\xe9f\xe9rences. Lorsque la m\xe9thode se termine, la r\xe9f\xe9rence ",(0,l.jsx)(s.code,{children:"myObject"})," sur la pile est d\xe9pil\xe9e, mais l'objet ",(0,l.jsx)(s.code,{children:"MyClass"})," sur le tas peut toujours exister si d'autres r\xe9f\xe9rences y pointent ailleurs (par exemple, un autre thread ou un champ statique). Ce n'est que lorsqu'aucune r\xe9f\xe9rence ne pointe vers lui qu'il devient \xe9ligible \xe0 la collecte de d\xe9chets."]}),"\n",(0,l.jsx)(s.p,{children:"En r\xe9sum\xe9, la pile concerne le flux d'ex\xe9cution et les donn\xe9es locales temporaires, tandis que le tas concerne le stockage \xe0 long terme des donn\xe9es pour les objets partag\xe9s au sein de votre application."})]})}function u(e={}){const{wrapper:s}={...(0,n.R)(),...e.components};return s?(0,l.jsx)(s,{...e,children:(0,l.jsx)(c,{...e})}):c(e)}},8453:(e,s,t)=>{t.d(s,{R:()=>i,x:()=>a});var r=t(6540);const l={},n=r.createContext(l);function i(e){const s=r.useContext(n);return r.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:i(e.components),r.createElement(n.Provider,{value:s},e.children)}}}]);