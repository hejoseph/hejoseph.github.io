"use strict";(self.webpackChunkmydevdocs=self.webpackChunkmydevdocs||[]).push([[4062],{8453:(e,n,r)=>{r.d(n,{R:()=>t,x:()=>o});var a=r(6540);const i={},s=a.createContext(i);function t(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),a.createElement(s.Provider,{value:n},e.children)}},9504:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"java/Core/OOP/java-oop-principles","title":"Java OOP Principles","description":"Object-Oriented Programming (OOP) is a programming paradigm that organizes software design around data, or objects, rather than functions and logic. Java is a purely object-oriented language, meaning almost everything in Java revolves around classes and objects.","source":"@site/docs/java/1-Core/1-OOP/1-java-oop-principles.md","sourceDirName":"java/1-Core/1-OOP","slug":"/java/Core/OOP/java-oop-principles","permalink":"/dev/fr/docs/java/Core/OOP/java-oop-principles","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"java","permalink":"/dev/fr/docs/tags/java"},{"inline":true,"label":"oop","permalink":"/dev/fr/docs/tags/oop"},{"inline":true,"label":"object-oriented","permalink":"/dev/fr/docs/tags/object-oriented"},{"inline":true,"label":"programming","permalink":"/dev/fr/docs/tags/programming"}],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Java OOP Principles","sidebar_position":1,"tags":["java","oop","object-oriented","programming"]},"sidebar":"tutorialSidebar","previous":{"title":"Java","permalink":"/dev/fr/docs/category/java"},"next":{"title":"Interfaces vs. Classes Abstraites","permalink":"/dev/fr/docs/java/Core/OOP/interface-abstract"}}');var i=r(4848),s=r(8453);const t={title:"Java OOP Principles",sidebar_position:1,tags:["java","oop","object-oriented","programming"]},o=void 0,l={},c=[{value:"Core OOP Principles in Java",id:"core-oop-principles-in-java",level:3},{value:"1. Encapsulation",id:"1-encapsulation",level:4},{value:"2. Abstraction",id:"2-abstraction",level:4},{value:"3. Inheritance",id:"3-inheritance",level:4},{value:"4. Polymorphism",id:"4-polymorphism",level:4},{value:"Other Key OOP Concepts in Java",id:"other-key-oop-concepts-in-java",level:3},{value:"Benefits of OOP",id:"benefits-of-oop",level:3}];function d(e){const n={code:"code",em:"em",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Object-Oriented Programming (OOP) is a programming paradigm that organizes software design around data, or objects, rather than functions and logic. Java is a purely object-oriented language, meaning almost everything in Java revolves around classes and objects."}),"\n",(0,i.jsxs)(n.p,{children:["The core idea behind OOP is to model real-world entities as objects, which have both ",(0,i.jsx)(n.strong,{children:"state"})," (data/attributes) and ",(0,i.jsx)(n.strong,{children:"behavior"})," (methods/functions). This approach aims to make software more modular, reusable, understandable, and maintainable."]}),"\n",(0,i.jsx)(n.h3,{id:"core-oop-principles-in-java",children:"Core OOP Principles in Java"}),"\n",(0,i.jsx)(n.p,{children:"OOP in Java is built upon four fundamental pillars:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Encapsulation"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Abstraction"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Inheritance"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Polymorphism"})}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Let's explore each of these:"}),"\n",(0,i.jsx)(n.h4,{id:"1-encapsulation",children:"1. Encapsulation"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Definition:"})," Encapsulation is the bundling of data (attributes) and the methods that operate on the data into a single unit (a class). It also involves restricting direct access to some of an object's components, meaning internal representation of an object is hidden from the outside."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"How Java achieves it:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["By declaring instance variables (data) as ",(0,i.jsx)(n.code,{children:"private"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["By providing public ",(0,i.jsx)(n.code,{children:"getter"})," and ",(0,i.jsx)(n.code,{children:"setter"})," methods to access and modify these private variables."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'public class BankAccount {\r\n    private String accountNumber; // Encapsulated data\r\n    private double balance;       // Encapsulated data\r\n\r\n    public BankAccount(String accountNumber, double initialBalance) {\r\n        this.accountNumber = accountNumber;\r\n        this.balance = initialBalance;\r\n    }\r\n\r\n    // Public getter methods\r\n    public String getAccountNumber() {\r\n        return accountNumber;\r\n    }\r\n\r\n    public double getBalance() {\r\n        return balance;\r\n    }\r\n\r\n    // Public setter/behavior methods\r\n    public void deposit(double amount) {\r\n        if (amount > 0) {\r\n            this.balance += amount;\r\n            System.out.println("Deposited: " + amount);\r\n        }\r\n    }\r\n\r\n    public void withdraw(double amount) {\r\n        if (amount > 0 && this.balance >= amount) {\r\n            this.balance -= amount;\r\n            System.out.println("Withdrew: " + amount);\r\n        } else {\r\n            System.out.println("Insufficient balance or invalid amount.");\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["In this example, ",(0,i.jsx)(n.code,{children:"accountNumber"})," and ",(0,i.jsx)(n.code,{children:"balance"})," are private, so they can only be accessed or modified via the ",(0,i.jsx)(n.code,{children:"deposit"}),", ",(0,i.jsx)(n.code,{children:"withdraw"}),", ",(0,i.jsx)(n.code,{children:"getAccountNumber"}),", and ",(0,i.jsx)(n.code,{children:"getBalance"})," methods, providing controlled access."]}),"\n",(0,i.jsx)(n.h4,{id:"2-abstraction",children:"2. Abstraction"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Definition:"})," Abstraction is the process of hiding the complex implementation details and showing only the essential features of an object. It focuses on ",(0,i.jsx)(n.em,{children:"what"})," an object does rather than ",(0,i.jsx)(n.em,{children:"how"})," it does it."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"How Java achieves it:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Abstract Classes:"})," Classes declared with the ",(0,i.jsx)(n.code,{children:"abstract"})," keyword. They cannot be instantiated directly and can have both abstract (without implementation) and concrete (with implementation) methods."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Interfaces:"})," Blueprints of a class. They contain only abstract methods (prior to Java 8) and constants. From Java 8 onwards, they can have default and static methods. A class implements an interface, promising to provide concrete implementations for its abstract methods."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example (using Abstract Class):"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'// Abstract Class\r\nabstract class Shape {\r\n    abstract double getArea(); // Abstract method (no implementation)\r\n\r\n    public void display() { // Concrete method\r\n        System.out.println("This is a shape.");\r\n    }\r\n}\r\n\r\n// Concrete class implementing Shape\r\nclass Circle extends Shape {\r\n    private double radius;\r\n\r\n    public Circle(double radius) {\r\n        this.radius = radius;\r\n    }\r\n\r\n    @Override\r\n    double getArea() { // Implementation of abstract method\r\n        return Math.PI * radius * radius;\r\n    }\r\n}\r\n\r\n// Example (using Interface):\r\ninterface Drivable {\r\n    void start(); // Abstract method\r\n    void stop();  // Abstract method\r\n}\r\n\r\nclass Car implements Drivable {\r\n    @Override\r\n    public void start() {\r\n        System.out.println("Car started.");\r\n    }\r\n\r\n    @Override\r\n    public void stop() {\r\n        System.out.println("Car stopped.");\r\n    }\r\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Here, ",(0,i.jsx)(n.code,{children:"Shape"})," and ",(0,i.jsx)(n.code,{children:"Drivable"})," abstract the common behavior ",(0,i.jsx)(n.code,{children:"getArea()"}),", ",(0,i.jsx)(n.code,{children:"start()"}),", ",(0,i.jsx)(n.code,{children:"stop()"})," without revealing the internal calculations or mechanisms."]}),"\n",(0,i.jsx)(n.h4,{id:"3-inheritance",children:"3. Inheritance"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Definition:"}),' Inheritance is a mechanism where one class (subclass/child class) acquires the properties and behaviors (fields and methods) of another class (superclass/parent class). It promotes code reusability and establishes an "is-a" relationship.']}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"How Java achieves it:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Using the ",(0,i.jsx)(n.code,{children:"extends"})," keyword. A class can extend only one other class (single inheritance)."]}),"\n",(0,i.jsx)(n.li,{children:"Interfaces can also be extended by other interfaces."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'// Parent Class (Superclass)\r\nclass Animal {\r\n    String name;\r\n\r\n    public Animal(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public void eat() {\r\n        System.out.println(name + " is eating.");\r\n    }\r\n}\r\n\r\n// Child Class (Subclass) inheriting from Animal\r\nclass Dog extends Animal {\r\n    public Dog(String name) {\r\n        super(name); // Call parent class constructor\r\n    }\r\n\r\n    public void bark() {\r\n        System.out.println(name + " is barking.");\r\n    }\r\n}\r\n\r\n// Another Child Class\r\nclass Cat extends Animal {\r\n    public Cat(String name) {\r\n        super(name);\r\n    }\r\n\r\n    public void meow() {\r\n        System.out.println(name + " is meowing.");\r\n    }\r\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Here, ",(0,i.jsx)(n.code,{children:"Dog"})," and ",(0,i.jsx)(n.code,{children:"Cat"})," inherit the ",(0,i.jsx)(n.code,{children:"name"})," field and ",(0,i.jsx)(n.code,{children:"eat()"})," method from ",(0,i.jsx)(n.code,{children:"Animal"}),", reusing common functionalities."]}),"\n",(0,i.jsx)(n.h4,{id:"4-polymorphism",children:"4. Polymorphism"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Definition:"}),' Polymorphism means "many forms." It allows objects of different classes to be treated as objects of a common type. It enables a single interface to represent different underlying forms (data types or classes).']}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"How Java achieves it:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Method Overloading (Compile-time Polymorphism):"})," Defining multiple methods in the same class with the same name but different parameters (number, type, or order of arguments)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Method Overriding (Runtime Polymorphism):"})," Defining a method in a subclass that has the same signature (name, return type, and parameters) as a method in its superclass. This allows a subclass to provide a specific implementation of a method that is already defined in its superclass."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example (Method Overloading):"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"class Calculator {\r\n    public int add(int a, int b) {\r\n        return a + b;\r\n    }\r\n\r\n    public double add(double a, double b) { // Overloaded method\r\n        return a + b;\r\n    }\r\n\r\n    public int add(int a, int b, int c) { // Overloaded method\r\n        return a + b + c;\r\n    }\r\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"add"})," method takes different forms based on the arguments."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example (Method Overriding & Runtime Polymorphism):"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'class Vehicle {\r\n    public void speedUp() {\r\n        System.out.println("Vehicle speeding up.");\r\n    }\r\n}\r\n\r\nclass Car extends Vehicle {\r\n    @Override\r\n    public void speedUp() { // Overridden method\r\n        System.out.println("Car accelerating.");\r\n    }\r\n}\r\n\r\nclass Bicycle extends Vehicle {\r\n    @Override\r\n    public void speedUp() { // Overridden method\r\n        System.out.println("Bicycle pedaling faster.");\r\n    }\r\n}\r\n\r\npublic class PolyDemo {\r\n    public static void main(String[] args) {\r\n        Vehicle myCar = new Car();      // Polymorphic reference\r\n        Vehicle myBicycle = new Bicycle(); // Polymorphic reference\r\n\r\n        myCar.speedUp();       // Calls Car\'s speedUp()\r\n        myBicycle.speedUp();   // Calls Bicycle\'s speedUp()\r\n\r\n        Vehicle genericVehicle = new Vehicle();\r\n        genericVehicle.speedUp(); // Calls Vehicle\'s speedUp()\r\n    }\r\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Car accelerating.\r\nBicycle pedaling faster.\r\nVehicle speeding up.\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Here, ",(0,i.jsx)(n.code,{children:"myCar"})," and ",(0,i.jsx)(n.code,{children:"myBicycle"})," are declared as ",(0,i.jsx)(n.code,{children:"Vehicle"})," type but behave differently based on their actual object type at runtime."]}),"\n",(0,i.jsx)(n.h3,{id:"other-key-oop-concepts-in-java",children:"Other Key OOP Concepts in Java"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Class:"})," A blueprint or template for creating objects. It defines the common attributes and behaviors that all objects of that class will have."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Object:"})," An instance of a class. It's a concrete entity created from a class, representing a real-world item."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Constructor:"})," A special method in a class that is automatically called when an object of that class is created (instantiated). Its primary purpose is to initialize the object's state."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"benefits-of-oop",children:"Benefits of OOP"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Modularity:"})," Breaking down complex systems into smaller, manageable, and independent objects."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Reusability:"})," Inheritance allows code reuse, reducing development time and effort."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Maintainability:"})," Easier to locate, fix, and update issues due to modular structure."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Scalability:"})," Easier to add new features or expand functionality without affecting existing code."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Flexibility:"})," Polymorphism allows for more flexible and adaptable code."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Data Security:"})," Encapsulation protects data from accidental corruption."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"In summary, OOP in Java provides a structured and powerful way to design and develop software, making it more robust, maintainable, and scalable by organizing code around real-world objects and their interactions."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);