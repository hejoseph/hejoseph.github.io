"use strict";(self.webpackChunkmydevdocs=self.webpackChunkmydevdocs||[]).push([[4382],{1615:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>o,toc:()=>a});const o=JSON.parse('{"id":"Portfolio/Chatbot/copy-btn-on-code-block","title":"Enhancing Code Block Usability: A Sticky Copy Button","description":"This document details the process of adding a \\"Copy to Clipboard\\" button to code blocks within messages from the LLM in our chatbot application. It highlights an initial implementation problem and the subsequent solution to ensure the button remains consistently visible, even when the code content requires horizontal scrolling.","source":"@site/docs/Portfolio/Chatbot/10-copy-btn-on-code-block.md","sourceDirName":"Portfolio/Chatbot","slug":"/Portfolio/Chatbot/copy-btn-on-code-block","permalink":"/dev/fr/docs/Portfolio/Chatbot/copy-btn-on-code-block","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":10,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Markdown syntax highliting glitch","permalink":"/dev/fr/docs/Portfolio/Chatbot/syntax-highlight-glitch"},"next":{"title":"Feature: Enhancing Message Interaction with Copy and Delete Options","permalink":"/dev/fr/docs/Portfolio/Chatbot/msg-menu-action"}}');var r=t(4848),i=t(8453);const s={},l="Enhancing Code Block Usability: A Sticky Copy Button",c={},a=[{value:"1. The Goal",id:"1-the-goal",level:2},{value:"2. Initial Implementation: The Problematic Approach",id:"2-initial-implementation-the-problematic-approach",level:2},{value:"2.1. What I Did (Initial Implementation)",id:"21-what-i-did-initial-implementation",level:3},{value:"2.2. The Problem Encountered",id:"22-the-problem-encountered",level:3},{value:"3. The Solution: Introducing a Wrapper Element",id:"3-the-solution-introducing-a-wrapper-element",level:2},{value:"3.1. What I Did (Corrected Implementation)",id:"31-what-i-did-corrected-implementation",level:3},{value:"3.2. Why It Works",id:"32-why-it-works",level:3},{value:"4. Conclusion",id:"4-conclusion",level:2}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"enhancing-code-block-usability-a-sticky-copy-button",children:"Enhancing Code Block Usability: A Sticky Copy Button"})}),"\n",(0,r.jsx)(n.p,{children:'This document details the process of adding a "Copy to Clipboard" button to code blocks within messages from the LLM in our chatbot application. It highlights an initial implementation problem and the subsequent solution to ensure the button remains consistently visible, even when the code content requires horizontal scrolling.'}),"\n",(0,r.jsx)(n.h2,{id:"1-the-goal",children:"1. The Goal"}),"\n",(0,r.jsx)(n.p,{children:'The primary objective was to improve the user experience for users interacting with code snippets provided by the LLM. Manually selecting and copying code can be tedious, especially for large blocks. A readily available "Copy" button would streamline this process, making code interaction more efficient.'}),"\n",(0,r.jsx)(n.h2,{id:"2-initial-implementation-the-problematic-approach",children:"2. Initial Implementation: The Problematic Approach"}),"\n",(0,r.jsxs)(n.p,{children:["Our first attempt involved integrating the copy button directly into the existing ",(0,r.jsx)(n.code,{children:"<pre>"})," (preformatted text) elements that render the code blocks."]}),"\n",(0,r.jsx)(n.h3,{id:"21-what-i-did-initial-implementation",children:"2.1. What I Did (Initial Implementation)"}),"\n",(0,r.jsx)(n.p,{children:'I aimed to place a "Copy" button in the top-right corner of each code block.'}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["Styling (",(0,r.jsx)(n.code,{children:"message-bubble.component.ts"})," component's ",(0,r.jsx)(n.code,{children:"styles"})," property):"]})}),"\n",(0,r.jsxs)(n.p,{children:["I added CSS rules to position the button. The key was making the ",(0,r.jsx)(n.code,{children:"<pre>"})," element ",(0,r.jsx)(n.code,{children:"position: relative;"})," so that the ",(0,r.jsx)(n.code,{children:"position: absolute;"})," of the button would be relative to the code block itself."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Inside @Component styles array in message-bubble.component.ts\r\nstyles: [\r\n  `\r\n    .message-content ::ng-deep pre {\r\n      position: relative; /* This makes the pre element the positioning context */\r\n      /* ... other pre styles like background, padding, overflow ... */\r\n    }\r\n\r\n    .message-content ::ng-deep .copy-button {\r\n      position: absolute;\r\n      top: 12px;\r\n      right: 12px;\r\n      background-color: rgba(255, 255, 255, 0.1);\r\n      color: white;\r\n      border: 1px solid rgba(255, 255, 255, 0.2);\r\n      padding: 6px 10px;\r\n      border-radius: 6px;\r\n      font-size: 13px;\r\n      font-weight: 500;\r\n      cursor: pointer;\r\n      opacity: 0; /* Hidden by default */\r\n      transition: opacity 0.2s ease-in-out, background-color 0.2s ease;\r\n    }\r\n\r\n    .message-content ::ng-deep pre:hover .copy-button {\r\n      opacity: 1; /* Show on hover of the pre element */\r\n    }\r\n\r\n    .message-content ::ng-deep .copy-button:hover {\r\n      background-color: rgba(255, 255, 255, 0.2);\r\n    }\r\n\r\n    .message-content ::ng-deep .copy-button:active {\r\n      background-color: rgba(255, 255, 255, 0.3);\r\n    }\r\n    /* ... other component styles ... */\r\n  `\r\n]\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["TypeScript Logic (",(0,r.jsx)(n.code,{children:"message-bubble.component.ts"}),"):"]})}),"\n",(0,r.jsxs)(n.p,{children:["In the ",(0,r.jsx)(n.code,{children:"highlightCode"})," method, which executes after the message content is rendered, i dynamically created and attached the button to each ",(0,r.jsx)(n.code,{children:"<pre>"})," element."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Inside message-bubble.component.ts\r\n\r\nexport class MessageBubbleComponent implements AfterViewInit {\r\n  // ... existing properties and methods ...\r\n\r\n  private highlightCode(): void {\r\n    if (this.messageContent && !this.message.isUser) {\r\n      // Select all <pre> elements that contain <code>\r\n      const codeBlocks = this.messageContent.nativeElement.querySelectorAll('pre');\r\n      codeBlocks.forEach((preElement: HTMLElement) => {\r\n        const codeElement = preElement.querySelector('code');\r\n        if (codeElement) {\r\n          // Highlight the code using an external service (Prism.js in this case)\r\n          this.prismService.highlightElement(codeElement);\r\n          // Add the copy button\r\n          this.addCopyButton(preElement, codeElement);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  private addCopyButton(preElement: HTMLElement, codeElement: HTMLElement): void {\r\n    const copyButton = document.createElement('button');\r\n    copyButton.className = 'copy-button';\r\n    copyButton.textContent = 'Copy';\r\n    copyButton.addEventListener('click', () => this.copyToClipboard(codeElement, copyButton));\r\n\r\n    // IMPORTANT: This line was present or equivalent CSS ensured position:relative on pre\r\n    // preElement.style.position = 'relative'; // If not already set by CSS\r\n\r\n    // Append the button directly to the <pre> element\r\n    preElement.appendChild(copyButton);\r\n  }\r\n\r\n  private copyToClipboard(codeElement: HTMLElement, button: HTMLButtonElement): void {\r\n    const textToCopy = codeElement.innerText;\r\n    navigator.clipboard.writeText(textToCopy).then(() => {\r\n      button.textContent = 'Copied!';\r\n      setTimeout(() => {\r\n        button.textContent = 'Copy';\r\n      }, 2000);\r\n    }).catch(err => {\r\n      console.error('Failed to copy text: ', err);\r\n      button.textContent = 'Error';\r\n      setTimeout(() => {\r\n        button.textContent = 'Copy';\r\n      }, 2000);\r\n    });\r\n  }\r\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"22-the-problem-encountered",children:"2.2. The Problem Encountered"}),"\n",(0,r.jsxs)(n.p,{children:["The initial implementation worked well for code blocks that fit entirely within the message bubble's width. However, for ",(0,r.jsx)(n.strong,{children:"long lines of code"})," that caused the ",(0,r.jsx)(n.code,{children:"<pre>"})," element to generate a horizontal scrollbar, I observed a critical usability flaw:"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"The copy button would scroll horizontally along with the code content."})}),"\n",(0,r.jsxs)(n.p,{children:['When a user scrolled the code block to the right to view hidden characters, the "Copy" button, positioned absolutely ',(0,r.jsx)(n.em,{children:"inside"})," the ",(0,r.jsx)(n.code,{children:"<pre>"})," element, would also move to the right and eventually disappear off-screen. This defeated the purpose of a consistently available button."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Why it happened:"})," When ",(0,r.jsx)(n.code,{children:"overflow-x: auto;"})," (or similar) causes an element like ",(0,r.jsx)(n.code,{children:"<pre>"})," to scroll internally, any ",(0,r.jsx)(n.code,{children:"position: absolute;"})," children within it are positioned relative to the ",(0,r.jsx)(n.em,{children:"scrolling content area"})," of the parent, not its fixed visual boundaries. Thus, as the content scrolled, the absolute position of the button relative to that content box shifted too."]}),"\n",(0,r.jsx)(n.h2,{id:"3-the-solution-introducing-a-wrapper-element",children:"3. The Solution: Introducing a Wrapper Element"}),"\n",(0,r.jsxs)(n.p,{children:['To ensure the copy button remained "sticky" in the top-right corner of the ',(0,r.jsx)(n.em,{children:"visible"})," part of the code block, regardless of horizontal scrolling, I introduced a new intermediate HTML element: a ",(0,r.jsx)(n.code,{children:"div"})," wrapper."]}),"\n",(0,r.jsx)(n.h3,{id:"31-what-i-did-corrected-implementation",children:"3.1. What I Did (Corrected Implementation)"}),"\n",(0,r.jsxs)(n.p,{children:["The core change was to wrap each ",(0,r.jsx)(n.code,{children:"<pre>"})," element within a new ",(0,r.jsx)(n.code,{children:"div"})," that would serve as the stable positioning context for the button."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["Styling (",(0,r.jsx)(n.code,{children:"message-bubble.component.ts"})," component's ",(0,r.jsx)(n.code,{children:"styles"})," property):"]})}),"\n",(0,r.jsxs)(n.p,{children:["I modified the CSS to apply ",(0,r.jsx)(n.code,{children:"position: relative;"})," to the ",(0,r.jsx)(n.em,{children:"new wrapper"})," instead of the ",(0,r.jsx)(n.code,{children:"<pre>"})," element. The button's absolute positioning now references this stable wrapper."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Inside @Component styles array in message-bubble.component.ts\r\nstyles: [\r\n  `\r\n    /* Copy button for code blocks */\r\n    .message-content ::ng-deep .code-block-wrapper {\r\n      position: relative; /* This new wrapper is now the positioning context */\r\n      margin: 0.8em 0; /* Added margin to the wrapper for consistent spacing */\r\n      /* Note: the <pre> element itself no longer needs position: relative; */\r\n    }\r\n\r\n    .message-content ::ng-deep .copy-button {\r\n      position: absolute;\r\n      top: 12px;\r\n      right: 12px;\r\n      background-color: rgba(255, 255, 255, 0.1);\r\n      color: white;\r\n      border: 1px solid rgba(255, 255, 255, 0.2);\r\n      padding: 6px 10px;\r\n      border-radius: 6px;\r\n      font-size: 13px;\r\n      font-weight: 500;\r\n      cursor: pointer;\r\n      opacity: 0;\r\n      transition: opacity 0.2s ease-in-out, background-color 0.2s ease;\r\n    }\r\n\r\n    .message-content ::ng-deep .code-block-wrapper:hover .copy-button {\r\n      opacity: 1; /* Button now shows on hover of the new wrapper */\r\n    }\r\n\r\n    .message-content ::ng-deep .copy-button:hover {\r\n      background-color: rgba(255, 255, 255, 0.2);\r\n    }\r\n\r\n    .message-content ::ng-deep .copy-button:active {\r\n      background-color: rgba(255, 255, 255, 0.3);\r\n    }\r\n    /* ... other component styles ... */\r\n  `\r\n]\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["TypeScript Logic (",(0,r.jsx)(n.code,{children:"message-bubble.component.ts"}),"):"]})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"addCopyButton"})," method was significantly changed to create the wrapper, re-parent the ",(0,r.jsx)(n.code,{children:"<pre>"})," element, and then append the copy button to the ",(0,r.jsx)(n.em,{children:"newly created wrapper"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Inside message-bubble.component.ts\r\n\r\nexport class MessageBubbleComponent implements AfterViewInit {\r\n  // ... existing properties and methods ...\r\n\r\n  private highlightCode(): void {\r\n    if (this.messageContent && !this.message.isUser) {\r\n      const codeBlocks = this.messageContent.nativeElement.querySelectorAll('pre');\r\n      codeBlocks.forEach((preElement: HTMLElement) => {\r\n        const codeElement = preElement.querySelector('code');\r\n        if (codeElement) {\r\n          this.prismService.highlightElement(codeElement);\r\n          this.addCopyButton(preElement, codeElement);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  private addCopyButton(preElement: HTMLElement, codeElement: HTMLElement): void {\r\n    // 1. Create a new wrapper div\r\n    const wrapper = document.createElement('div');\r\n    wrapper.className = 'code-block-wrapper'; // Assign the new class\r\n\r\n    // 2. Insert the new wrapper into the DOM *before* the original <pre> element\r\n    // This ensures the wrapper takes the <pre>'s place structurally\r\n    preElement.parentNode?.insertBefore(wrapper, preElement);\r\n\r\n    // 3. Move (re-parent) the original <pre> element *inside* the new wrapper\r\n    wrapper.appendChild(preElement);\r\n\r\n    // 4. Create the copy button\r\n    const copyButton = document.createElement('button');\r\n    copyButton.className = 'copy-button';\r\n    copyButton.textContent = 'Copy';\r\n    copyButton.addEventListener('click', () => this.copyToClipboard(codeElement, copyButton));\r\n\r\n    // 5. Append the copy button to the *wrapper* (not the preElement)\r\n    wrapper.appendChild(copyButton);\r\n  }\r\n\r\n  private copyToClipboard(codeElement: HTMLElement, button: HTMLButtonElement): void {\r\n    // ... (same copy to clipboard logic as before) ...\r\n  }\r\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"32-why-it-works",children:"3.2. Why It Works"}),"\n",(0,r.jsxs)(n.p,{children:["By introducing the ",(0,r.jsx)(n.code,{children:"code-block-wrapper"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Stable Positioning Context:"})," The ",(0,r.jsx)(n.code,{children:"wrapper"})," div itself does not scroll horizontally. When ",(0,r.jsx)(n.code,{children:"position: relative;"})," is applied to this wrapper, it creates a fixed, non-scrolling reference point for its children."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Independent Scrolling:"})," The ",(0,r.jsx)(n.code,{children:"<pre>"})," element, now a child of the ",(0,r.jsx)(n.code,{children:"wrapper"}),", is free to scroll its content horizontally without affecting the layout of its parent or sibling elements (like the copy button)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fixed Button Position:"})," The copy button, being ",(0,r.jsx)(n.code,{children:"position: absolute;"})," relative to the ",(0,r.jsx)(n.code,{children:"wrapper"}),", remains anchored to the top-right corner of the ",(0,r.jsx)(n.em,{children:"wrapper's visible area"}),", regardless of how much the ",(0,r.jsx)(n.code,{children:"<pre>"})," element's content scrolls internally."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"4-conclusion",children:"4. Conclusion"}),"\n",(0,r.jsxs)(n.p,{children:["The problem of the horizontally scrolling copy button was directly addressed by refining our DOM structure. By simply wrapping the ",(0,r.jsx)(n.code,{children:"<pre>"})," element within a new ",(0,r.jsx)(n.code,{children:"div"}),' that acts as the positioning context, i achieved a truly "sticky" copy button. This small but effective change significantly improves the usability of code blocks in our chatbot, ensuring that the copy functionality is always readily accessible to the user, enhancing the overall user experience.']})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>l});var o=t(6540);const r={},i=o.createContext(r);function s(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);