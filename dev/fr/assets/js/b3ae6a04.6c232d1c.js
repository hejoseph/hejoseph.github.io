"use strict";(self.webpackChunkmydevdocs=self.webpackChunkmydevdocs||[]).push([[6291],{2918:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>l,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"java/Core/OOP/interface-abstract","title":"Interfaces vs. Classes Abstraites","description":"Dans le paradigme de la programmation orient\xe9e objet (POO) en Java, les interfaces et les classes abstraites fournissent toutes deux des m\xe9canismes pour atteindre l\'abstraction et le polymorphisme. Bien qu\'elles partagent certaines similitudes, leurs objectifs principaux, leurs capacit\xe9s et leurs cas d\'utilisation diff\xe8rent significativement.","source":"@site/i18n/fr/docusaurus-plugin-content-docs/current/java/1-Core/1-OOP/2-interface-abstract.md","sourceDirName":"java/1-Core/1-OOP","slug":"/java/Core/OOP/interface-abstract","permalink":"/dev/fr/docs/java/Core/OOP/interface-abstract","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"java","permalink":"/dev/fr/docs/tags/java"},{"inline":true,"label":"oop","permalink":"/dev/fr/docs/tags/oop"},{"inline":true,"label":"interfaces","permalink":"/dev/fr/docs/tags/interfaces"},{"inline":true,"label":"abstract classes","permalink":"/dev/fr/docs/tags/abstract-classes"},{"inline":true,"label":"polymorphism","permalink":"/dev/fr/docs/tags/polymorphism"}],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Interfaces vs. Classes Abstraites","sidebar_position":2,"tags":["java","oop","interfaces","abstract classes","polymorphism"]},"sidebar":"tutorialSidebar","previous":{"title":"Java OOP Principles","permalink":"/dev/fr/docs/java/Core/OOP/java-oop-principles"},"next":{"title":"Composition plut\xf4t qu\'h\xe9ritage","permalink":"/dev/fr/docs/java/Core/OOP/composition-inheritance"}}');var r=t(4848),i=t(8453);const l={title:"Interfaces vs. Classes Abstraites",sidebar_position:2,tags:["java","oop","interfaces","abstract classes","polymorphism"]},a=void 0,c={},d=[{value:"Interfaces",id:"interfaces",level:3},{value:"Classes Abstraites",id:"classes-abstraites",level:3},{value:"Principales diff\xe9rences r\xe9sum\xe9es",id:"principales-diff\xe9rences-r\xe9sum\xe9es",level:3},{value:"Quand choisir l&#39;un ou l&#39;autre",id:"quand-choisir-lun-ou-lautre",level:3}];function o(e){const s={code:"code",em:"em",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.p,{children:"Dans le paradigme de la programmation orient\xe9e objet (POO) en Java, les interfaces et les classes abstraites fournissent toutes deux des m\xe9canismes pour atteindre l'abstraction et le polymorphisme. Bien qu'elles partagent certaines similitudes, leurs objectifs principaux, leurs capacit\xe9s et leurs cas d'utilisation diff\xe8rent significativement."}),"\n",(0,r.jsx)(s.h3,{id:"interfaces",children:"Interfaces"}),"\n",(0,r.jsxs)(s.p,{children:["Une interface en Java est un mod\xe8le de classe. Elle peut avoir des champs ",(0,r.jsx)(s.code,{children:"static final"})," (constantes) et des m\xe9thodes abstraites. \xc0 partir de Java 8, les interfaces peuvent \xe9galement avoir des m\xe9thodes ",(0,r.jsx)(s.code,{children:"default"})," et ",(0,r.jsx)(s.code,{children:"static"}),". \xc0 partir de Java 9, les m\xe9thodes ",(0,r.jsx)(s.code,{children:"private"})," sont \xe9galement autoris\xe9es."]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Caract\xe9ristiques cl\xe9s :"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Abstraction \xe0 100 % :"})," Historiquement, toutes les m\xe9thodes d'une interface \xe9taient implicitement ",(0,r.jsx)(s.code,{children:"public abstract"})," et n'avaient pas d'impl\xe9mentation."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Champs :"})," Ne peuvent d\xe9clarer que des champs ",(0,r.jsx)(s.code,{children:"public static final"})," (constantes). Ceux-ci sont implicitement ",(0,r.jsx)(s.code,{children:"public static final"}),"."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"M\xe9thodes :"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["M\xe9thodes ",(0,r.jsx)(s.code,{children:"public abstract"})," (implicitement)."]}),"\n",(0,r.jsxs)(s.li,{children:["M\xe9thodes ",(0,r.jsx)(s.code,{children:"default"})," (\xe0 partir de Java 8) fournissent une impl\xe9mentation par d\xe9faut que les classes impl\xe9mentantes peuvent surcharger."]}),"\n",(0,r.jsxs)(s.li,{children:["M\xe9thodes ",(0,r.jsx)(s.code,{children:"static"})," (\xe0 partir de Java 8) sont des m\xe9thodes utilitaires li\xe9es \xe0 l'interface elle-m\xeame, et non \xe0 ses objets impl\xe9mentants."]}),"\n",(0,r.jsxs)(s.li,{children:["M\xe9thodes ",(0,r.jsx)(s.code,{children:"private"})," et ",(0,r.jsx)(s.code,{children:"private static"})," (\xe0 partir de Java 9) pour prendre en charge les m\xe9thodes ",(0,r.jsx)(s.code,{children:"default"})," et ",(0,r.jsx)(s.code,{children:"static"})," au sein de l'interface."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Constructeurs :"})," Ne peuvent pas avoir de constructeurs."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"H\xe9ritage :"})," Une classe ",(0,r.jsx)(s.code,{children:"impl\xe9mente"})," une interface. Une classe peut impl\xe9menter plusieurs interfaces (h\xe9ritage multiple de type). Une interface peut ",(0,r.jsx)(s.code,{children:"\xe9tendre"})," plusieurs autres interfaces."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Modificateurs d'acc\xe8s :"})," Tous les membres sont implicitement ",(0,r.jsx)(s.code,{children:"public"})," (sauf les m\xe9thodes priv\xe9es)."]}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Cas d'utilisation :"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"D\xe9finir des contrats :"})," Les interfaces sont id\xe9ales pour d\xe9finir des contrats auxquels les classes doivent adh\xe9rer. Toute classe impl\xe9mentant une interface garantit de fournir des impl\xe9mentations pour ses m\xe9thodes abstraites."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"R\xe9aliser l'h\xe9ritage multiple de type :"})," Puisqu'une classe peut impl\xe9menter plusieurs interfaces, elle peut acqu\xe9rir des comportements de plusieurs sources, contournant la limitation de l'h\xe9ritage simple de Java pour les classes."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Couplage faible :"})," Favorise un couplage faible en permettant aux classes d'interagir sur la base d'interfaces d\xe9finies plut\xf4t que d'impl\xe9mentations concr\xe8tes."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"M\xe9canismes de rappel (Callback) :"})," Souvent utilis\xe9es pour d\xe9finir des m\xe9thodes de rappel."]}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Exemple :"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-java",children:'interface Shape {\r\n    double PI = 3.14159; // public static final par d\xe9faut\r\n\r\n    double calculateArea(); // public abstract par d\xe9faut\r\n    double calculatePerimeter();\r\n\r\n    default void display() { // M\xe9thode par d\xe9faut\r\n        System.out.println("Ceci est une forme.");\r\n    }\r\n}\r\n\r\nclass Circle implements Shape {\r\n    private double radius;\r\n\r\n    public Circle(double radius) {\r\n        this.radius = radius;\r\n    }\r\n\r\n    @Override\r\n    public double calculateArea() {\r\n        return PI * radius * radius;\r\n    }\r\n\r\n    @Override\r\n    public double calculatePerimeter() {\r\n        return 2 * PI * radius;\r\n    }\r\n}\n'})}),"\n",(0,r.jsx)(s.h3,{id:"classes-abstraites",children:"Classes Abstraites"}),"\n",(0,r.jsx)(s.p,{children:"Une classe abstraite est une classe qui ne peut pas \xeatre instanci\xe9e seule et peut contenir des m\xe9thodes abstraites (m\xe9thodes sans impl\xe9mentation) ainsi que des m\xe9thodes concr\xe8tes (impl\xe9ment\xe9es). Elle sert de classe de base pour d'autres classes, fournissant des fonctionnalit\xe9s communes et d\xe9finissant un mod\xe8le pour les sous-classes."}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Caract\xe9ristiques cl\xe9s :"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Abstraction partielle :"})," Peut avoir \xe0 la fois des m\xe9thodes abstraites et des m\xe9thodes concr\xe8tes. Elle peut \xeatre abstraite \xe0 0 % (aucune m\xe9thode abstraite mais toujours d\xe9clar\xe9e ",(0,r.jsx)(s.code,{children:"abstract"}),") ou jusqu'\xe0 100 % abstraite (toutes les m\xe9thodes sont abstraites)."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Champs :"})," Peut avoir tout type de champs (statiques, non statiques, finaux, non finaux) avec n'importe quel modificateur d'acc\xe8s (",(0,r.jsx)(s.code,{children:"public"}),", ",(0,r.jsx)(s.code,{children:"protected"}),", ",(0,r.jsx)(s.code,{children:"private"}),", par d\xe9faut)."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"M\xe9thodes :"})," Peut avoir des m\xe9thodes abstraites (d\xe9clar\xe9es avec le mot-cl\xe9 ",(0,r.jsx)(s.code,{children:"abstract"}),") et des m\xe9thodes concr\xe8tes."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Constructeurs :"})," Peut avoir des constructeurs. Ces constructeurs sont appel\xe9s lorsqu'une sous-classe concr\xe8te est instanci\xe9e."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"H\xe9ritage :"})," Une classe ",(0,r.jsx)(s.code,{children:"\xe9tend"})," une classe abstraite. Une classe ne peut \xe9tendre qu'une seule classe abstraite (h\xe9ritage simple). Une classe abstraite peut ",(0,r.jsx)(s.code,{children:"\xe9tendre"})," une autre classe ou classe abstraite et peut ",(0,r.jsx)(s.code,{children:"impl\xe9menter"})," des interfaces."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Modificateurs d'acc\xe8s :"})," Les membres peuvent avoir n'importe quel modificateur d'acc\xe8s."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsxs)(s.strong,{children:["M\xe9thodes ",(0,r.jsx)(s.code,{children:"final"})," :"]})," Une classe abstraite peut avoir des m\xe9thodes ",(0,r.jsx)(s.code,{children:"final"}),", qui ne peuvent pas \xeatre surcharg\xe9es par les sous-classes."]}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Cas d'utilisation :"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"R\xe9utilisabilit\xe9 du code :"})," Fournit une base commune pour les classes apparent\xe9es, permettant aux sous-classes de partager des m\xe9thodes et des champs impl\xe9ment\xe9s en commun."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Mod\xe8le de m\xe9thode de gabarit (Template Method Pattern) :"})," Souvent utilis\xe9 pour impl\xe9menter le mod\xe8le de conception de m\xe9thode de gabarit, o\xf9 un squelette d'algorithme est d\xe9fini dans la classe abstraite, et les \xe9tapes concr\xe8tes sont laiss\xe9es aux sous-classes pour impl\xe9mentation."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Hi\xe9rarchie d'objets li\xe9s :"})," Le mieux adapt\xe9 lorsqu'il existe une relation \"est un\" et que vous souhaitez fournir un \xe9tat et un comportement communs \xe0 un groupe d'objets \xe9troitement li\xe9s."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Contr\xf4le de version :"})," Plus facile \xe0 faire \xe9voluer que les interfaces sans casser les impl\xe9mentations existantes, car vous pouvez ajouter de nouvelles m\xe9thodes concr\xe8tes sans forcer les sous-classes \xe0 les impl\xe9menter."]}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Exemple :"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-java",children:'abstract class Vehicle {\r\n    String brand;\r\n    int year;\r\n\r\n    public Vehicle(String brand, int year) { // Constructeur\r\n        this.brand = brand;\r\n        this.year = year;\r\n    }\r\n\r\n    public void displayInfo() { // M\xe9thode concr\xe8te\r\n        System.out.println("Marque : " + brand + ", Ann\xe9e : " + year);\r\n    }\r\n\r\n    public abstract void start(); // M\xe9thode abstraite\r\n    public abstract void stop();\r\n}\r\n\r\nclass Car extends Vehicle {\r\n    public Car(String brand, int year) {\r\n        super(brand, year);\r\n    }\r\n\r\n    @Override\r\n    public void start() {\r\n        System.out.println("La voiture d\xe9marre avec une cl\xe9.");\r\n    }\r\n\r\n    @Override\r\n    public void stop() {\r\n        System.out.println("La voiture s\'arr\xeate en appuyant sur le frein.");\r\n    }\r\n}\n'})}),"\n",(0,r.jsx)(s.h3,{id:"principales-diff\xe9rences-r\xe9sum\xe9es",children:"Principales diff\xe9rences r\xe9sum\xe9es"}),"\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{style:{textAlign:"left"},children:"Caract\xe9ristique"}),(0,r.jsx)(s.th,{style:{textAlign:"left"},children:"Interface"}),(0,r.jsx)(s.th,{style:{textAlign:"left"},children:"Classe Abstraite"})]})}),(0,r.jsxs)(s.tbody,{children:[(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{style:{textAlign:"left"},children:(0,r.jsx)(s.strong,{children:"Type de membres"})}),(0,r.jsxs)(s.td,{style:{textAlign:"left"},children:["Seulement champs ",(0,r.jsx)(s.code,{children:"public static final"}),". M\xe9thodes abstraites, par d\xe9faut, statiques et priv\xe9es."]}),(0,r.jsx)(s.td,{style:{textAlign:"left"},children:"Tout type de champs (statiques, non statiques, finaux, non finaux) avec n'importe quel modificateur d'acc\xe8s. M\xe9thodes abstraites et concr\xe8tes."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{style:{textAlign:"left"},children:(0,r.jsx)(s.strong,{children:"Abstraction"})}),(0,r.jsxs)(s.td,{style:{textAlign:"left"},children:["Historiquement, 100 % abstraite. Maintenant, peut avoir des m\xe9thodes concr\xe8tes ",(0,r.jsx)(s.code,{children:"default"})," et ",(0,r.jsx)(s.code,{children:"static"}),"."]}),(0,r.jsx)(s.td,{style:{textAlign:"left"},children:"Peut \xeatre abstraite de 0 % \xe0 100 % (peut avoir z\xe9ro ou plusieurs m\xe9thodes abstraites)."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{style:{textAlign:"left"},children:(0,r.jsx)(s.strong,{children:"M\xe9thodes"})}),(0,r.jsxs)(s.td,{style:{textAlign:"left"},children:["Les m\xe9thodes abstraites sont implicitement ",(0,r.jsx)(s.code,{children:"public abstract"}),". Peut avoir des m\xe9thodes ",(0,r.jsx)(s.code,{children:"default"}),", ",(0,r.jsx)(s.code,{children:"static"}),", ",(0,r.jsx)(s.code,{children:"private"}),"."]}),(0,r.jsxs)(s.td,{style:{textAlign:"left"},children:["Les m\xe9thodes abstraites sont explicitement ",(0,r.jsx)(s.code,{children:"abstract"}),". Peut avoir des m\xe9thodes concr\xe8tes avec n'importe quel modificateur d'acc\xe8s."]})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{style:{textAlign:"left"},children:(0,r.jsx)(s.strong,{children:"Constructeurs"})}),(0,r.jsx)(s.td,{style:{textAlign:"left"},children:"Ne peut pas avoir de constructeurs."}),(0,r.jsx)(s.td,{style:{textAlign:"left"},children:"Peut avoir des constructeurs."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{style:{textAlign:"left"},children:(0,r.jsx)(s.strong,{children:"H\xe9ritage"})}),(0,r.jsxs)(s.td,{style:{textAlign:"left"},children:["Une classe ",(0,r.jsx)(s.code,{children:"impl\xe9mente"})," des interfaces. Prend en charge l'h\xe9ritage multiple de type. Une interface ",(0,r.jsx)(s.code,{children:"\xe9tend"})," d'autres interfaces."]}),(0,r.jsxs)(s.td,{style:{textAlign:"left"},children:["Une classe ",(0,r.jsx)(s.code,{children:"\xe9tend"})," une classe abstraite. Prend en charge l'h\xe9ritage simple uniquement."]})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{style:{textAlign:"left"},children:(0,r.jsx)(s.strong,{children:'"Est un" vs "Peut faire"'})}),(0,r.jsx)(s.td,{style:{textAlign:"left"},children:'D\xe9finit une capacit\xe9 "peut faire" ou un contrat.'}),(0,r.jsx)(s.td,{style:{textAlign:"left"},children:'D\xe9finit une relation "est un" ou une base commune.'})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{style:{textAlign:"left"},children:(0,r.jsx)(s.strong,{children:"Mots-cl\xe9s"})}),(0,r.jsxs)(s.td,{style:{textAlign:"left"},children:[(0,r.jsx)(s.code,{children:"interface"}),", ",(0,r.jsx)(s.code,{children:"implements"}),", ",(0,r.jsx)(s.code,{children:"extends"})]}),(0,r.jsxs)(s.td,{style:{textAlign:"left"},children:[(0,r.jsx)(s.code,{children:"abstract"}),", ",(0,r.jsx)(s.code,{children:"class"}),", ",(0,r.jsx)(s.code,{children:"extends"}),", ",(0,r.jsx)(s.code,{children:"implements"})]})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{style:{textAlign:"left"},children:(0,r.jsx)(s.strong,{children:"M\xe9thodes Finales"})}),(0,r.jsxs)(s.td,{style:{textAlign:"left"},children:["Les m\xe9thodes ne peuvent pas \xeatre ",(0,r.jsx)(s.code,{children:"final"})," (mais les m\xe9thodes ",(0,r.jsx)(s.code,{children:"default"})," et ",(0,r.jsx)(s.code,{children:"static"})," ne sont implicitement pas destin\xe9es \xe0 \xeatre surcharg\xe9es directement par les sous-classes)."]}),(0,r.jsxs)(s.td,{style:{textAlign:"left"},children:["Peut avoir des m\xe9thodes ",(0,r.jsx)(s.code,{children:"final"}),", qui ne peuvent pas \xeatre surcharg\xe9es."]})]})]})]}),"\n",(0,r.jsx)(s.h3,{id:"quand-choisir-lun-ou-lautre",children:"Quand choisir l'un ou l'autre"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Choisissez une Interface quand :"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Vous voulez d\xe9finir un contrat pour ce que les classes ",(0,r.jsx)(s.em,{children:"peuvent faire"}),", ind\xe9pendamment de leur position dans la hi\xe9rarchie d'h\xe9ritage."]}),"\n",(0,r.jsx)(s.li,{children:"Vous avez besoin de r\xe9aliser l'h\xe9ritage multiple de type."}),"\n",(0,r.jsx)(s.li,{children:"Vous voulez promouvoir un couplage faible entre les composants."}),"\n",(0,r.jsx)(s.li,{children:"Vous d\xe9finissez une API ou un ensemble de comportements que des classes non li\xe9es pourraient impl\xe9menter."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Choisissez une Classe Abstraite quand :"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Vous voulez fournir une impl\xe9mentation de base commune pour des classes apparent\xe9es, partageant du code et de l'\xe9tat."}),"\n",(0,r.jsx)(s.li,{children:"Vous avez des m\xe9thodes qui devraient \xeatre impl\xe9ment\xe9es par les sous-classes, mais aussi des m\xe9thodes avec une impl\xe9mentation par d\xe9faut qui peuvent \xeatre h\xe9rit\xe9es."}),"\n",(0,r.jsx)(s.li,{children:"Vous avez besoin de d\xe9finir des champs (variables) communs que les sous-classes partageront."}),"\n",(0,r.jsx)(s.li,{children:"Vous voulez imposer une hi\xe9rarchie sp\xe9cifique pour un ensemble de classes."}),"\n",(0,r.jsx)(s.li,{children:"Vous avez besoin de fournir des constructeurs pour les sous-classes."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["En substance, les interfaces d\xe9finissent ce qu'un objet peut faire (son contrat/comportement), tandis que les classes abstraites d\xe9finissent ce qu'un objet ",(0,r.jsx)(s.em,{children:"est"})," (son type et son impl\xe9mentation partag\xe9e). Souvent, les conceptions complexes peuvent utiliser une combinaison des deux pour r\xe9aliser des architectures robustes et extensibles."]})]})}function u(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}},8453:(e,s,t)=>{t.d(s,{R:()=>l,x:()=>a});var n=t(6540);const r={},i=n.createContext(r);function l(e){const s=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),n.createElement(i.Provider,{value:s},e.children)}}}]);